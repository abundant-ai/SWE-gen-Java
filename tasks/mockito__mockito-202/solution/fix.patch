diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 9201a39cb..48842b845 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -41,15 +41,7 @@ Things we pay attention in a PR :
 * On pull requests, please document the change, what it brings, what is the benefit. If the issue exists on the old issue tracker on [Google Code](https://code.google.com/p/mockito/issues/list), please add cross links. But don't create a new one there.
 * **Clean commit history** in the topic branch in your fork of the repository, even during review. That means that commits are _rebased_ and _squashed_ if necessary, so that each commit clearly changes one things and there are no extraneous fix-ups.
 
-  For that matter it's possible to commit [_semantic_ changes](http://lemike-de.tumblr.com/post/79041908218/semantic-commits). _Tests are an asset, so is history_.
-  
-  _Exemple gratia_:
-  
-  ```
-  Fixes #73 : The new feature
-  Fixes #73 : Refactors this part of Mockito to make feature possible
-  ```
-  
+  For that matter it's possible to commit [_semantic_ changes](http://lemike-de.tumblr.com/post/79041908218/semantic-commits) (like starting with `Fixes #issue_id`). _Tests are an asset, so is history_.
 * In the code, always test your feature / change, in unit tests and in our `acceptance test suite` located in `org.mockitousage`. Older tests will be migrated when a test is modified.
 * New test methods should follow a snake case convention (`ensure_that_stuff_is_doing_that`), this allows the test name to be fully expressive on intent while still readable.
 * When reporting errors to the users, if it's a user report report it gently and explain how a user should deal with it, see the `Reporter` class. However not all errors should go there, some unlikely technical errors don't need to be in the `Reporter` class.
diff --git a/doc/release-notes/official.md b/doc/release-notes/official.md
index 4fa93f594..3eb11c5c7 100644
--- a/doc/release-notes/official.md
+++ b/doc/release-notes/official.md
@@ -1,15 +1,3 @@
-### 2.0.6-beta (2015-04-17 09:55 UTC)
-
-* Authors: 3
-* Commits: 9
-  * 7: Brice Dutheil
-  * 1: bruce
-  * 1: Hans Joachim Desserud
-* Improvements: 3
-  * Fixes #200 : ArgumentCaptor.forClass is more friendly with generic types [(#201)](https://github.com/mockito/mockito/pull/201)
-  * ArgumentCaptor.fromClass's return type should match a parameterized type [(#200)](https://github.com/mockito/mockito/issues/200)
-  * Fixes typo [(#184)](https://github.com/mockito/mockito/pull/184)
-
 ### 2.0.5-beta (2015-02-26 22:31 UTC)
 
 * Authors: 2
diff --git a/src/org/mockito/ArgumentCaptor.java b/src/org/mockito/ArgumentCaptor.java
index 78c41c89f..0efe061cf 100644
--- a/src/org/mockito/ArgumentCaptor.java
+++ b/src/org/mockito/ArgumentCaptor.java
@@ -65,7 +65,7 @@ public class ArgumentCaptor<T> {
     HandyReturnValues handyReturnValues = new HandyReturnValues();
 
     private final CapturingMatcher<T> capturingMatcher = new CapturingMatcher<T>();
-    private final Class<? extends T> clazz;
+    private final Class<T> clazz;
 
     /**
      * @deprecated
@@ -87,7 +87,7 @@ public class ArgumentCaptor<T> {
         this.clazz = null;
     }
 
-    private ArgumentCaptor(Class<? extends T> clazz) {
+    ArgumentCaptor(Class<T> clazz) {
         this.clazz = clazz;
     }
 
@@ -163,11 +163,10 @@ public class ArgumentCaptor<T> {
      * future major release.
      *
      * @param clazz Type matching the parameter to be captured.
-     * @param <S> Type of clazz
-     * @param <U> Type of object captured by the newly built ArgumentCaptor
+     * @param <T> Type of clazz
      * @return A new ArgumentCaptor
      */
-    public static <U,S extends U> ArgumentCaptor<U> forClass(Class<S> clazz) {
-        return new ArgumentCaptor<U>(clazz);
+    public static <T> ArgumentCaptor<T> forClass(Class<T> clazz) {
+        return new ArgumentCaptor<T>(clazz);
     }
 }
\ No newline at end of file
diff --git a/src/org/mockito/exceptions/Reporter.java b/src/org/mockito/exceptions/Reporter.java
index 7ae75886c..e0b1105da 100644
--- a/src/org/mockito/exceptions/Reporter.java
+++ b/src/org/mockito/exceptions/Reporter.java
@@ -8,7 +8,13 @@ package org.mockito.exceptions;
 import org.mockito.exceptions.base.MockitoAssertionError;
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.exceptions.misusing.*;
-import org.mockito.exceptions.verification.*;
+import org.mockito.exceptions.verification.NeverWantedButInvoked;
+import org.mockito.exceptions.verification.NoInteractionsWanted;
+import org.mockito.exceptions.verification.SmartNullPointerException;
+import org.mockito.exceptions.verification.TooLittleActualInvocations;
+import org.mockito.exceptions.verification.TooManyActualInvocations;
+import org.mockito.exceptions.verification.VerificationInOrderFailure;
+import org.mockito.exceptions.verification.WantedButNotInvoked;
 import org.mockito.internal.debugging.LocationImpl;
 import org.mockito.internal.exceptions.MockitoLimitations;
 import org.mockito.internal.exceptions.VerificationAwareInvocation;
@@ -22,6 +28,7 @@ import org.mockito.invocation.Invocation;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.invocation.Location;
 import org.mockito.listeners.InvocationListener;
+import org.mockito.mock.MockName;
 import org.mockito.mock.SerializableMode;
 
 import java.lang.reflect.Field;
@@ -231,7 +238,7 @@ public class Reporter {
     public void invalidUseOfMatchers(int expectedMatchersCount, List<LocalizedMatcher> recordedMatchers) {
         throw new InvalidUseOfMatchersException(join(
                 "Invalid use of argument matchers!",
-                expectedMatchersCount + " matchers expected, " + recordedMatchers.size()+ " recorded:" +
+                expectedMatchersCount + " matchers expected, " + recordedMatchers.size() + " recorded:" +
                         locationsOf(recordedMatchers),
                 "",
                 "This exception may occur if matchers are combined with raw values:",
@@ -387,7 +394,7 @@ public class Reporter {
     private String createTooLittleInvocationsMessage(org.mockito.internal.reporting.Discrepancy discrepancy, DescribedInvocation wanted,
                                                      Location lastActualInvocation) {
         String ending =
-                (lastActualInvocation != null)? lastActualInvocation + "\n" : "\n";
+                (lastActualInvocation != null) ? lastActualInvocation + "\n" : "\n";
 
         String message = join(
                 wanted.toString(),
@@ -420,7 +427,7 @@ public class Reporter {
         throw new NoInteractionsWanted(join(
                 "No interactions wanted here:",
                 new LocationImpl(),
-                "But found this interaction on mock '" + undesired.getMock() + "':",
+                "But found this interaction on mock '" + safelyGetMockName(undesired.getMock()) + "':",
                 undesired.getLocation(),
                 scenario
         ));
@@ -430,7 +437,7 @@ public class Reporter {
         throw new VerificationInOrderFailure(join(
                 "No interactions wanted here:",
                 new LocationImpl(),
-                "But found this interaction on mock '" + undesired.getMock() + "':",
+                "But found this interaction on mock '" + safelyGetMockName(undesired.getMock()) + "':",
                 undesired.getLocation()
         ));
     }
@@ -489,6 +496,18 @@ public class Reporter {
         ));
     }
 
+    public void wrongTypeReturnedByDefaultAnswer(Object mock, String expectedType, String actualType, String methodName) {
+        throw new WrongTypeOfReturnValue(join(
+                "Default answer returned a result with the wrong type:",
+                actualType + " cannot be returned by " + methodName + "()",
+                methodName + "() should return " + expectedType,
+                "",
+                "The default answer of " + safelyGetMockName(mock) + " that was configured on the mock is probably incorrectly implemented.",
+                ""
+        ));
+    }
+
+
     public void wantedAtMostX(int maxNumberOfInvocations, int foundSize) {
         throw new MockitoAssertionError(join("Wanted at most " + pluralize(maxNumberOfInvocations) + " but was " + foundSize));
     }
@@ -641,7 +660,7 @@ public class Reporter {
 
     public void fieldInitialisationThrewException(Field field, Throwable details) {
         throw new MockitoException(join(
-                "Cannot instantiate @InjectMocks field named '" + field.getName() + "' of type '" + field.getType() +  "'.",
+                "Cannot instantiate @InjectMocks field named '" + field.getName() + "' of type '" + field.getType() + "'.",
                 "You haven't provided the instance at field declaration so I tried to construct the instance.",
                 "However the constructor or the initialization block threw an exception : " + details.getMessage(),
                 ""), details);
@@ -664,14 +683,21 @@ public class Reporter {
 
     public void cannotInjectDependency(Field field, Object matchingMock, Exception details) {
         throw new MockitoException(join(
-                "Mockito couldn't inject mock dependency '" + new MockUtil().getMockName(matchingMock) + "' on field ",
+                "Mockito couldn't inject mock dependency '" + safelyGetMockName(matchingMock) + "' on field ",
                 "'" + field + "'",
                 "whose type '" + field.getDeclaringClass().getCanonicalName() + "' was annotated by @InjectMocks in your test.",
-                "Also I failed because: " + details.getCause().getMessage(),
+                "Also I failed because: " + exceptionCauseMessageIfAvailable(details),
                 ""
         ), details);
     }
 
+    private String exceptionCauseMessageIfAvailable(Exception details) {
+        if (details.getCause() == null) {
+            return details.getMessage();
+        }
+        return details.getCause().getMessage();
+    }
+
     public void mockedTypeIsInconsistentWithDelegatedInstanceType(Class mockedType, Object delegatedInstance) {
         throw new MockitoException(join(
                 "Mocked type must be the same as the type of your delegated instance.",
@@ -686,7 +712,7 @@ public class Reporter {
     public void spyAndDelegateAreMutuallyExclusive() {
         throw new MockitoException(join(
                 "Settings should not define a spy instance and a delegated instance at the same time."
-        )) ;
+        ));
     }
 
     public void invalidArgumentRangeAtIdentityAnswerCreationTime() {
@@ -699,7 +725,7 @@ public class Reporter {
     public int invalidArgumentPositionRangeAtInvocationTime(InvocationOnMock invocation, boolean willReturnLastParameter, int argumentIndex) {
         throw new MockitoException(
                 join("Invalid argument index for the current invocation of method : ",
-                        " -> " + new MockUtil().getMockName(invocation.getMock()) + "." + invocation.getMethod().getName() + "()",
+                        " -> " + safelyGetMockName(invocation.getMock()) + "." + invocation.getMethod().getName() + "()",
                         "",
                         (willReturnLastParameter ?
                                 "Last parameter wanted" :
@@ -732,7 +758,7 @@ public class Reporter {
         throw new WrongTypeOfReturnValue(join(
                 "The argument of type '" + actualType.getSimpleName() + "' cannot be returned because the following ",
                 "method should return the type '" + expectedType + "'",
-                " -> " + new MockUtil().getMockName(invocation.getMock()) + "." + invocation.getMethod().getName() + "()",
+                " -> " + safelyGetMockName(invocation.getMock()) + "." + invocation.getMethod().getName() + "()",
                 "",
                 "The reason for this error can be :",
                 "1. The wanted argument position is incorrect.",
@@ -765,28 +791,32 @@ public class Reporter {
                 ""
         ));
     }
-    
+
     public void delegatedMethodHasWrongReturnType(Method mockMethod, Method delegateMethod, Object mock, Object delegate) {
-    	throw new MockitoException(join(
-    	        "Methods called on delegated instance must have compatible return types with the mock.",
-    	        "When calling: " + mockMethod + " on mock: " + new MockUtil().getMockName(mock),
-    	        "return type should be: " + mockMethod.getReturnType().getSimpleName() + ", but was: " + delegateMethod.getReturnType().getSimpleName(),
-    	        "Check that the instance passed to delegatesTo() is of the correct type or contains compatible methods",
-    	        "(delegate instance had type: " + delegate.getClass().getSimpleName() + ")"
-    	));
-    }
-
-	public void delegatedMethodDoesNotExistOnDelegate(Method mockMethod, Object mock, Object delegate) {
-		throw new MockitoException(join(
-    	        "Methods called on mock must exist in delegated instance.",
-    	        "When calling: " + mockMethod + " on mock: " + new MockUtil().getMockName(mock),
-    	        "no such method was found.",
-    	        "Check that the instance passed to delegatesTo() is of the correct type or contains compatible methods",
-    	        "(delegate instance had type: " + delegate.getClass().getSimpleName() + ")"
-    	));
-	}
+        throw new MockitoException(join(
+                "Methods called on delegated instance must have compatible return types with the mock.",
+                "When calling: " + mockMethod + " on mock: " + safelyGetMockName(mock),
+                "return type should be: " + mockMethod.getReturnType().getSimpleName() + ", but was: " + delegateMethod.getReturnType().getSimpleName(),
+                "Check that the instance passed to delegatesTo() is of the correct type or contains compatible methods",
+                "(delegate instance had type: " + delegate.getClass().getSimpleName() + ")"
+        ));
+    }
+
+    public void delegatedMethodDoesNotExistOnDelegate(Method mockMethod, Object mock, Object delegate) {
+        throw new MockitoException(join(
+                "Methods called on mock must exist in delegated instance.",
+                "When calling: " + mockMethod + " on mock: " + safelyGetMockName(mock),
+                "no such method was found.",
+                "Check that the instance passed to delegatesTo() is of the correct type or contains compatible methods",
+                "(delegate instance had type: " + delegate.getClass().getSimpleName() + ")"
+        ));
+    }
 
     public void usingConstructorWithFancySerializable(SerializableMode mode) {
         throw new MockitoException("Mocks instantiated with constructor cannot be combined with " + mode + " serialization mode.");
     }
+
+    private MockName safelyGetMockName(Object mock) {
+        return new MockUtil().getMockName(mock);
+    }
 }
diff --git a/src/org/mockito/internal/handler/MockHandlerImpl.java b/src/org/mockito/internal/handler/MockHandlerImpl.java
index a49c1a98b..00766a0d0 100644
--- a/src/org/mockito/internal/handler/MockHandlerImpl.java
+++ b/src/org/mockito/internal/handler/MockHandlerImpl.java
@@ -10,7 +10,12 @@ import org.mockito.internal.invocation.InvocationMatcher;
 import org.mockito.internal.invocation.MatchersBinder;
 import org.mockito.internal.progress.MockingProgress;
 import org.mockito.internal.progress.ThreadSafeMockingProgress;
-import org.mockito.internal.stubbing.*;
+import org.mockito.internal.stubbing.InvocationContainer;
+import org.mockito.internal.stubbing.InvocationContainerImpl;
+import org.mockito.internal.stubbing.OngoingStubbingImpl;
+import org.mockito.internal.stubbing.StubbedInvocationMatcher;
+import org.mockito.internal.stubbing.VoidMethodStubbableImpl;
+import org.mockito.internal.stubbing.answers.AnswersValidator;
 import org.mockito.internal.verification.MockAwareVerificationMode;
 import org.mockito.internal.verification.VerificationDataImpl;
 import org.mockito.invocation.Invocation;
@@ -23,9 +28,8 @@ import java.util.List;
 
 /**
  * Invocation handler set on mock objects.
- * 
- * @param <T>
- *            type of mock object to handle
+ *
+ * @param <T> type of mock object to handle
  */
 class MockHandlerImpl<T> implements InternalMockHandler<T> {
 
@@ -45,7 +49,7 @@ class MockHandlerImpl<T> implements InternalMockHandler<T> {
     }
 
     public Object handle(Invocation invocation) throws Throwable {
-		if (invocationContainerImpl.hasAnswersForStubbing()) {
+        if (invocationContainerImpl.hasAnswersForStubbing()) {
             // stubbing voids with stubVoid() or doAnswer() style
             InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(
                     mockingProgress.getArgumentMatcherStorage(),
@@ -90,7 +94,8 @@ class MockHandlerImpl<T> implements InternalMockHandler<T> {
             stubbedInvocation.captureArgumentsFrom(invocation);
             return stubbedInvocation.answer(invocation);
         } else {
-             Object ret = mockSettings.getDefaultAnswer().answer(invocation);
+            Object ret = mockSettings.getDefaultAnswer().answer(invocation);
+            new AnswersValidator().validateDefaultAnswerReturnedValue(invocation, ret);
 
             // redo setting invocation for potential stubbing in case of partial
             // mocks / spies.
@@ -100,7 +105,7 @@ class MockHandlerImpl<T> implements InternalMockHandler<T> {
             invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);
             return ret;
         }
-	}
+    }
 
     public VoidMethodStubbable<T> voidMethodStubbable(T mock) {
         return new VoidMethodStubbableImpl<T>(mock, invocationContainerImpl);
diff --git a/src/org/mockito/internal/invocation/InvocationImpl.java b/src/org/mockito/internal/invocation/InvocationImpl.java
index 19193fa16..dc77a57e2 100644
--- a/src/org/mockito/internal/invocation/InvocationImpl.java
+++ b/src/org/mockito/internal/invocation/InvocationImpl.java
@@ -105,6 +105,10 @@ public class InvocationImpl implements Invocation, VerificationAwareInvocation {
         return this.rawArguments;
     }
 
+    public Class<?> getRawReturnType() {
+        return method.getReturnType();
+    }
+
     public Object callRealMethod() throws Throwable {
         if (method.isAbstract()) {
             new Reporter().cannotCallAbstractRealMethod();
@@ -131,4 +135,4 @@ public class InvocationImpl implements Invocation, VerificationAwareInvocation {
     public void ignoreForVerification() {
         isIgnoredForVerification = true;
     }
-}
\ No newline at end of file
+}
diff --git a/src/org/mockito/internal/stubbing/answers/AnswersValidator.java b/src/org/mockito/internal/stubbing/answers/AnswersValidator.java
index 57adb3881..66bbf54c5 100644
--- a/src/org/mockito/internal/stubbing/answers/AnswersValidator.java
+++ b/src/org/mockito/internal/stubbing/answers/AnswersValidator.java
@@ -11,21 +11,21 @@ import org.mockito.stubbing.Answer;
 public class AnswersValidator {
 
     private final Reporter reporter = new Reporter();
-    
+
     public void validate(Answer<?> answer, Invocation invocation) {
         MethodInfo methodInfo = new MethodInfo(invocation);
         if (answer instanceof ThrowsException) {
             validateException((ThrowsException) answer, methodInfo);
         }
-        
+
         if (answer instanceof Returns) {
             validateReturnValue((Returns) answer, methodInfo);
         }
-        
+
         if (answer instanceof DoesNothing) {
             validateDoNothing((DoesNothing) answer, methodInfo);
         }
-        
+
         if (answer instanceof CallsRealMethods) {
             validateMockingConcreteClass((CallsRealMethods) answer, methodInfo);
         }
@@ -42,8 +42,8 @@ public class AnswersValidator {
         MethodInfo methodInfo = new MethodInfo(invocation);
         if (!methodInfo.isValidReturnType(returnsArgumentAt.returnedTypeOnSignature(invocation))) {
             new Reporter().wrongTypeOfArgumentToReturn(invocation, methodInfo.printMethodReturnType(),
-                                                       returnsArgumentAt.returnedTypeOnSignature(invocation),
-                                                       returnsArgumentAt.wantedArgumentPosition());
+                    returnsArgumentAt.returnedTypeOnSignature(invocation),
+                    returnsArgumentAt.wantedArgumentPosition());
         }
 
     }
@@ -64,10 +64,10 @@ public class AnswersValidator {
         if (methodInfo.isVoid()) {
             reporter.cannotStubVoidMethodWithAReturnValue(methodInfo.getMethodName());
         }
-        
+
         if (answer.returnsNull() && methodInfo.returnsPrimitive()) {
             reporter.wrongTypeOfReturnValue(methodInfo.printMethodReturnType(), "null", methodInfo.getMethodName());
-        } 
+        }
 
         if (!answer.returnsNull() && !methodInfo.isValidReturnType(answer.getReturnType())) {
             reporter.wrongTypeOfReturnValue(methodInfo.printMethodReturnType(), answer.printReturnType(), methodInfo.getMethodName());
@@ -79,13 +79,24 @@ public class AnswersValidator {
         if (throwable == null) {
             reporter.cannotStubWithNullThrowable();
         }
-        
+
         if (throwable instanceof RuntimeException || throwable instanceof Error) {
             return;
         }
-        
+
         if (!methodInfo.isValidException(throwable)) {
             reporter.checkedExceptionInvalid(throwable);
         }
     }
-}
\ No newline at end of file
+
+    public void validateDefaultAnswerReturnedValue(Invocation invocation, Object returnedValue) {
+        MethodInfo methodInfo = new MethodInfo(invocation);
+        if (returnedValue != null && !methodInfo.isValidReturnType(returnedValue.getClass())) {
+            reporter.wrongTypeReturnedByDefaultAnswer(
+                    invocation.getMock(),
+                    methodInfo.printMethodReturnType(),
+                    returnedValue.getClass().getSimpleName(),
+                    methodInfo.getMethodName());
+        }
+    }
+}
diff --git a/src/org/mockito/invocation/Invocation.java b/src/org/mockito/invocation/Invocation.java
index 014669730..7c1bdd557 100644
--- a/src/org/mockito/invocation/Invocation.java
+++ b/src/org/mockito/invocation/Invocation.java
@@ -41,6 +41,14 @@ public interface Invocation extends InvocationOnMock, DescribedInvocation {
      */
     Object[] getRawArguments();
 
+    /**
+     * Returns unprocessed arguments whereas {@link #getArguments()} returns
+     * arguments already processed (e.g. varargs expended, etc.).
+     *
+     * @return unprocessed arguments, exactly as provided to this invocation.
+     */
+    Class getRawReturnType();
+
     /**
      * Marks this invocation as verified so that it will not cause verification error at
      * {@link org.mockito.Mockito#verifyNoMoreInteractions(Object...)}
diff --git a/version.properties b/version.properties
index a5746b61b..d00805e8b 100644
--- a/version.properties
+++ b/version.properties
@@ -1,2 +1,2 @@
-version=2.0.7-beta
+version=2.0.6-beta
 mockito.testng.version=1.0
\ No newline at end of file
