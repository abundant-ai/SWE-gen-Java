diff --git a/core/src/main/scala/cats/Foldable.scala b/core/src/main/scala/cats/Foldable.scala
index 813eb76b3..21ce2f866 100644
--- a/core/src/main/scala/cats/Foldable.scala
+++ b/core/src/main/scala/cats/Foldable.scala
@@ -394,6 +394,26 @@ import Foldable.sentinel
     }
   }
 
+  /**
+   * Fold implemented using the given `Applicative[G]` and `Monoid[A]` instance.
+   *
+   * This method is identical to fold, except that we use `Applicative[G]` and `Monoid[A]`
+   * to combine a's inside an applicative G.
+   *
+   * For example:
+   *
+   * {{{
+   * scala> import cats.implicits._
+   * scala> val F = Foldable[List]
+   * scala> F.foldA(List(Either.right[String, Int](1), Either.right[String, Int](2)))
+   * res0: Either[String, Int] = Right(3)
+   * }}}
+   *
+   * `noop` usage description [[https://github.com/typelevel/simulacrum/issues/162 here]]
+   */
+  @noop def foldA[G[_], A](fga: F[G[A]])(implicit G: Applicative[G], A: Monoid[A]): G[A] =
+    fold(fga)(Applicative.monoid)
+
   /**
    * Fold implemented by mapping `A` values into `B` in a context `G` and then
    * combining them using the `MonoidK[G]` instance.
diff --git a/core/src/main/scala/cats/Reducible.scala b/core/src/main/scala/cats/Reducible.scala
index 6bb748a41..b04f581c9 100644
--- a/core/src/main/scala/cats/Reducible.scala
+++ b/core/src/main/scala/cats/Reducible.scala
@@ -82,6 +82,22 @@ import simulacrum.{noop, typeclass}
   def reduceLeftM[G[_], A, B](fa: F[A])(f: A => G[B])(g: (B, A) => G[B])(implicit G: FlatMap[G]): G[B] =
     reduceLeftTo(fa)(f)((gb, a) => G.flatMap(gb)(g(_, a)))
 
+  /**
+   * Reduce a `F[G[A]]` value using `Applicative[G]` and `Semigroup[A]`, a universal
+   * semigroup for `G[_]`.
+   *
+   * `noop` usage description [[https://github.com/typelevel/simulacrum/issues/162 here]]
+   */
+  @noop def reduceA[G[_], A](fga: F[G[A]])(implicit G: Apply[G], A: Semigroup[A]): G[A] =
+    reduce(fga)(Apply.semigroup)
+
+  /**
+   * Apply `f` to each `a` of `fa` and combine the result into Apply[G] using the
+   * given `Semigroup[B]`.
+   */
+  def reduceMapA[G[_], A, B](fa: F[A])(f: A => G[B])(implicit G: Apply[G], B: Semigroup[B]): G[B] =
+    reduceLeftTo(fa)(f)((gb, a) => G.map2(gb, f(a))(B.combine))
+
   /**
    * Monadic reducing by mapping the `A` values to `G[B]`. combining
    * the `B` values using the given `Semigroup[B]` instance.
diff --git a/core/src/main/scala/cats/syntax/foldable.scala b/core/src/main/scala/cats/syntax/foldable.scala
index 6f3909f1d..729f3f100 100644
--- a/core/src/main/scala/cats/syntax/foldable.scala
+++ b/core/src/main/scala/cats/syntax/foldable.scala
@@ -46,6 +46,9 @@ final class FoldableOps[F[_], A](private val fa: F[A]) extends AnyVal {
   def foldr[B](b: Eval[B])(f: (A, Eval[B]) => Eval[B])(implicit F: Foldable[F]): Eval[B] =
     F.foldRight(fa, b)(f)
 
+  def foldA[G[_], B](implicit F: Foldable[F], ev: A <:< G[B], G: Applicative[G], B: Monoid[B]): G[B] =
+    F.foldA[G, B](fa.asInstanceOf[F[G[B]]])
+
   /**
    * test if `F[A]` contains an `A`, named contains_ to avoid conflict with existing contains which uses universal equality
    *
diff --git a/core/src/main/scala/cats/syntax/reducible.scala b/core/src/main/scala/cats/syntax/reducible.scala
index 76e1ff1fa..0b542c874 100644
--- a/core/src/main/scala/cats/syntax/reducible.scala
+++ b/core/src/main/scala/cats/syntax/reducible.scala
@@ -30,4 +30,7 @@ final class ReducibleOps0[F[_], A](private val fa: F[A]) extends AnyVal {
    * }}}
    * */
   def reduceMapK[G[_], B](f: A => G[B])(implicit F: Reducible[F], G: SemigroupK[G]): G[B] = F.reduceMapK[G, A, B](fa)(f)
+
+  def reduceA[G[_], B](implicit F: Reducible[F], ev: A <:< G[B], G: Apply[G], B: Semigroup[B]): G[B] =
+    F.reduceA[G, B](fa.asInstanceOf[F[G[B]]])
 }
