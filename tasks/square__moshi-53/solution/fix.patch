diff --git a/moshi/src/main/java/com/squareup/moshi/ClassJsonAdapter.java b/moshi/src/main/java/com/squareup/moshi/ClassJsonAdapter.java
index a6b43618..f2cf8ce4 100644
--- a/moshi/src/main/java/com/squareup/moshi/ClassJsonAdapter.java
+++ b/moshi/src/main/java/com/squareup/moshi/ClassJsonAdapter.java
@@ -41,14 +41,14 @@ final class ClassJsonAdapter<T> extends JsonAdapter<T> {
       if (rawType.getEnclosingClass() != null && !Modifier.isStatic(rawType.getModifiers())) {
         if (rawType.getSimpleName().isEmpty()) {
           throw new IllegalArgumentException(
-              "cannot serialize anonymous class " + rawType.getName());
+              "Cannot serialize anonymous class " + rawType.getName());
         } else {
           throw new IllegalArgumentException(
-              "cannot serialize non-static nested class " + rawType.getName());
+              "Cannot serialize non-static nested class " + rawType.getName());
         }
       }
       if (Modifier.isAbstract(rawType.getModifiers())) {
-        throw new IllegalArgumentException("cannot serialize abstract class " + rawType.getName());
+        throw new IllegalArgumentException("Cannot serialize abstract class " + rawType.getName());
       }
 
       ClassFactory<Object> classFactory = ClassFactory.get(rawType);
@@ -79,7 +79,7 @@ final class ClassJsonAdapter<T> extends JsonAdapter<T> {
         // Store it using the field's name. If there was already a field with this name, fail!
         FieldBinding<?> replaced = fieldBindings.put(field.getName(), fieldBinding);
         if (replaced != null) {
-          throw new IllegalArgumentException("field name collision: '" + field.getName() + "'"
+          throw new IllegalArgumentException("Field name collision: '" + field.getName() + "'"
               + " declared by both " + replaced.field.getDeclaringClass().getName()
               + " and superclass " + fieldBinding.field.getDeclaringClass().getName());
         }
@@ -172,8 +172,7 @@ final class ClassJsonAdapter<T> extends JsonAdapter<T> {
     }
 
     @SuppressWarnings("unchecked") // We require that field's values are of type T.
-    private void write(JsonWriter writer, Object value)
-        throws IllegalAccessException, IOException {
+    private void write(JsonWriter writer, Object value) throws IllegalAccessException, IOException {
       T fieldValue = (T) field.get(value);
       adapter.toJson(writer, fieldValue);
     }
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonReader.java b/moshi/src/main/java/com/squareup/moshi/JsonReader.java
index defb5405..814f1d1b 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonReader.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonReader.java
@@ -919,7 +919,7 @@ public final class JsonReader implements Closeable {
       } catch (NumberFormatException ignored) {
         // Fall back to parse as a double below.
       }
-    } else {
+    } else if (p != PEEKED_BUFFERED) {
       throw new JsonDataException("Expected a long but was " + peek()
           + " at path " + getPath());
     }
@@ -1044,7 +1044,7 @@ public final class JsonReader implements Closeable {
       } catch (NumberFormatException ignored) {
         // Fall back to parse as a double below.
       }
-    } else {
+    } else if (p != PEEKED_BUFFERED) {
       throw new JsonDataException("Expected an int but was " + peek() + " at path " + getPath());
     }
 
@@ -1327,6 +1327,17 @@ public final class JsonReader implements Closeable {
     throw new IOException(message + " at path " + getPath());
   }
 
+  /**
+   * Changes the reader to treat the next name as a string value. This is useful for map adapters so
+   * that arbitrary type adapters can use {@link #nextString} to read a name value.
+   */
+  void promoteNameToValue() throws IOException {
+    if (hasNext()) {
+      peekedString = nextName();
+      peeked = PEEKED_BUFFERED;
+    }
+  }
+
   /**
    * A structure, name, or value type in a JSON-encoded string.
    */
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonWriter.java b/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
index 78b44ede..40566d87 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
@@ -180,6 +180,8 @@ public final class JsonWriter implements Closeable, Flushable {
 
   private boolean serializeNulls;
 
+  private boolean promoteNameToValue;
+
   /**
    * Creates a new instance that writes a JSON-encoded stream to {@code sink}.
    */
@@ -284,6 +286,7 @@ public final class JsonWriter implements Closeable, Flushable {
    * @return this writer.
    */
   public JsonWriter endObject() throws IOException {
+    promoteNameToValue = false;
     return close(EMPTY_OBJECT, NONEMPTY_OBJECT, "}");
   }
 
@@ -367,6 +370,7 @@ public final class JsonWriter implements Closeable, Flushable {
     }
     deferredName = name;
     pathNames[stackSize - 1] = name;
+    promoteNameToValue = false;
     return this;
   }
 
@@ -388,6 +392,9 @@ public final class JsonWriter implements Closeable, Flushable {
     if (value == null) {
       return nullValue();
     }
+    if (promoteNameToValue) {
+      return name(value);
+    }
     writeDeferredName();
     beforeValue(false);
     string(value);
@@ -439,6 +446,9 @@ public final class JsonWriter implements Closeable, Flushable {
     if (Double.isNaN(value) || Double.isInfinite(value)) {
       throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
     }
+    if (promoteNameToValue) {
+      return name(Double.toString(value));
+    }
     writeDeferredName();
     beforeValue(false);
     sink.writeUtf8(Double.toString(value));
@@ -452,6 +462,9 @@ public final class JsonWriter implements Closeable, Flushable {
    * @return this writer.
    */
   public JsonWriter value(long value) throws IOException {
+    if (promoteNameToValue) {
+      return name(Long.toString(value));
+    }
     writeDeferredName();
     beforeValue(false);
     sink.writeUtf8(Long.toString(value));
@@ -471,12 +484,15 @@ public final class JsonWriter implements Closeable, Flushable {
       return nullValue();
     }
 
-    writeDeferredName();
     String string = value.toString();
     if (!lenient
         && (string.equals("-Infinity") || string.equals("Infinity") || string.equals("NaN"))) {
       throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
     }
+    if (promoteNameToValue) {
+      return name(string);
+    }
+    writeDeferredName();
     beforeValue(false);
     sink.writeUtf8(string);
     pathIndices[stackSize - 1]++;
@@ -612,6 +628,18 @@ public final class JsonWriter implements Closeable, Flushable {
     }
   }
 
+  /**
+   * Changes the reader to treat the next string value as a name. This is useful for map adapters so
+   * that arbitrary type adapters can use {@link #value(String)} to write a name value.
+   */
+  void promoteNameToValue() throws IOException {
+    int context = peek();
+    if (context != NONEMPTY_OBJECT && context != EMPTY_OBJECT) {
+      throw new IllegalStateException("Nesting problem.");
+    }
+    promoteNameToValue = true;
+  }
+
   /**
    * Returns a <a href="http://goessner.net/articles/JsonPath/">JsonPath</a> to
    * the current location in the JSON value.
diff --git a/moshi/src/main/java/com/squareup/moshi/MapJsonAdapter.java b/moshi/src/main/java/com/squareup/moshi/MapJsonAdapter.java
index 289d034f..c4f15db1 100644
--- a/moshi/src/main/java/com/squareup/moshi/MapJsonAdapter.java
+++ b/moshi/src/main/java/com/squareup/moshi/MapJsonAdapter.java
@@ -34,21 +34,26 @@ final class MapJsonAdapter<K, V> extends JsonAdapter<Map<K, V>> {
       Class<?> rawType = Types.getRawType(type);
       if (rawType != Map.class) return null;
       Type[] keyAndValue = Types.mapKeyAndValueTypes(type, rawType);
-      if (keyAndValue[0] != String.class) return null;
-      return new MapJsonAdapter<>(moshi, keyAndValue[1]).nullSafe();
+      return new MapJsonAdapter<>(moshi, keyAndValue[0], keyAndValue[1]).nullSafe();
     }
   };
 
+  private final JsonAdapter<K> keyAdapter;
   private final JsonAdapter<V> valueAdapter;
 
-  public MapJsonAdapter(Moshi moshi, Type valueType) {
+  public MapJsonAdapter(Moshi moshi, Type keyType, Type valueType) {
+    this.keyAdapter = moshi.adapter(keyType);
     this.valueAdapter = moshi.adapter(valueType);
   }
 
   @Override public void toJson(JsonWriter writer, Map<K, V> map) throws IOException {
     writer.beginObject();
     for (Map.Entry<K, V> entry : map.entrySet()) {
-      writer.name((String) entry.getKey());
+      if (entry.getKey() == null) {
+        throw new JsonDataException("Map key is null at path " + writer.getPath());
+      }
+      writer.promoteNameToValue();
+      keyAdapter.toJson(writer, entry.getKey());
       valueAdapter.toJson(writer, entry.getValue());
     }
     writer.endObject();
@@ -58,12 +63,13 @@ final class MapJsonAdapter<K, V> extends JsonAdapter<Map<K, V>> {
     LinkedHashTreeMap<K, V> result = new LinkedHashTreeMap<>();
     reader.beginObject();
     while (reader.hasNext()) {
-      @SuppressWarnings("unchecked") // Currently 'K' is always 'String'.
-      K name = (K) reader.nextName();
+      reader.promoteNameToValue();
+      K name = keyAdapter.fromJson(reader);
       V value = valueAdapter.fromJson(reader);
       V replaced = result.put(name, value);
       if (replaced != null) {
-        throw new JsonDataException("object property '" + name + "' has multiple values");
+        throw new JsonDataException("Map key '" + name + "' has multiple values at path "
+            + reader.getPath());
       }
     }
     reader.endObject();
diff --git a/moshi/src/main/java/com/squareup/moshi/Moshi.java b/moshi/src/main/java/com/squareup/moshi/Moshi.java
index 5cf94286..00751756 100644
--- a/moshi/src/main/java/com/squareup/moshi/Moshi.java
+++ b/moshi/src/main/java/com/squareup/moshi/Moshi.java
@@ -90,7 +90,7 @@ public final class Moshi {
       deferredAdapters.remove(deferredAdapters.size() - 1);
     }
 
-    throw new IllegalArgumentException("no JsonAdapter for " + type + " annotated " + annotations);
+    throw new IllegalArgumentException("No JsonAdapter for " + type + " annotated " + annotations);
   }
 
   public static final class Builder {
@@ -172,12 +172,12 @@ public final class Moshi {
     }
 
     @Override public T fromJson(JsonReader reader) throws IOException {
-      if (delegate == null) throw new IllegalStateException("type adapter isn't ready");
+      if (delegate == null) throw new IllegalStateException("Type adapter isn't ready");
       return delegate.fromJson(reader);
     }
 
     @Override public void toJson(JsonWriter writer, T value) throws IOException {
-      if (delegate == null) throw new IllegalStateException("type adapter isn't ready");
+      if (delegate == null) throw new IllegalStateException("Type adapter isn't ready");
       delegate.toJson(writer, value);
     }
   }
