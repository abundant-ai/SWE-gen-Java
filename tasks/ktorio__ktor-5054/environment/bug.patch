diff --git a/ktor-http/common/src/io/ktor/http/content/Versions.kt b/ktor-http/common/src/io/ktor/http/content/Versions.kt
index 1a4333f13..bb5db9824 100644
--- a/ktor-http/common/src/io/ktor/http/content/Versions.kt
+++ b/ktor-http/common/src/io/ktor/http/content/Versions.kt
@@ -165,6 +165,7 @@ public fun EntityTagVersion(spec: String): EntityTagVersion {
  *
  * It never handles `If-None-Match: *`  as it is related to non-etag logic (for example, Last modified checks).
  *
+ *
  * [Report a problem](https://ktor.io/feedback/?fqname=io.ktor.http.content.EntityTagVersion)
  *
  * @param etag - entity tag, for example file's content hash
@@ -174,17 +175,13 @@ public fun EntityTagVersion(spec: String): EntityTagVersion {
  * [VersionCheckResult.PRECONDITION_FAILED] for failed If-Match
  */
 public data class EntityTagVersion(val etag: String, val weak: Boolean) : Version {
-    private val opaque: String = when {
+    private val normalized: String = when {
         etag == "*" -> etag
         etag.startsWith("\"") -> etag
         else -> etag.quote()
     }
 
-    private val normalized: String = if (weak) "W/$opaque" else opaque
-
     init {
-        require(!(weak && etag == STAR.etag)) { "Entity tag '*' could not be weak." }
-
         for (index in etag.indices) {
             val ch = etag[index]
             if (ch <= ' ' || ch == '\"') {
@@ -215,27 +212,19 @@ public data class EntityTagVersion(val etag: String, val weak: Boolean) : Versio
      * [Report a problem](https://ktor.io/feedback/?fqname=io.ktor.http.content.EntityTagVersion.match)
      */
     public fun match(other: EntityTagVersion): Boolean {
-        if (weak || other.weak) return false
-        return weakMatch(other)
-    }
-
-    /**
-     * Checks whether two entity-tags match (weak).
-     */
-    private fun weakMatch(other: EntityTagVersion): Boolean {
         if (this == STAR || other == STAR) return true
-        return opaque == other.opaque
+        return normalized == other.normalized
     }
 
     /**
-     * Specifies `If-None-Match` logic.
+     * Specifies `If-None-Match` logic using the [match] function.
      *
      * [Report a problem](https://ktor.io/feedback/?fqname=io.ktor.http.content.EntityTagVersion.noneMatch)
      */
     public fun noneMatch(givenNoneMatchEtags: List<EntityTagVersion>): VersionCheckResult {
         if (STAR in givenNoneMatchEtags) return VersionCheckResult.OK
 
-        if (givenNoneMatchEtags.any { weakMatch(it) }) {
+        if (givenNoneMatchEtags.any { match(it) }) {
             return VersionCheckResult.NOT_MODIFIED
         }
 
diff --git a/ktor-server/ktor-server-core/api/ktor-server-core.api b/ktor-server/ktor-server-core/api/ktor-server-core.api
index 0ad8ea8f2..7021a0bdb 100644
--- a/ktor-server/ktor-server-core/api/ktor-server-core.api
+++ b/ktor-server/ktor-server-core/api/ktor-server-core.api
@@ -809,15 +809,6 @@ public final class io/ktor/server/http/content/DefaultTransformKt {
 	public static final fun transformDefaultContent (Lio/ktor/server/application/ApplicationCall;Ljava/lang/Object;)Lio/ktor/http/content/OutgoingContent;
 }
 
-public abstract interface class io/ktor/server/http/content/ETagProvider {
-	public static final field Companion Lio/ktor/server/http/content/ETagProvider$Companion;
-	public abstract fun provide (Ljava/lang/Object;)Lio/ktor/http/content/EntityTagVersion;
-}
-
-public final class io/ktor/server/http/content/ETagProvider$Companion {
-	public final fun getStrongSha256 ()Lio/ktor/server/http/content/ETagProvider;
-}
-
 public abstract interface class io/ktor/server/http/content/FileSystemPaths {
 	public static final field Companion Lio/ktor/server/http/content/FileSystemPaths$Companion;
 	public abstract fun getPath (Ljava/lang/String;[Ljava/lang/String;)Ljava/nio/file/Path;
@@ -909,11 +900,9 @@ public final class io/ktor/server/http/content/StaticContentConfig {
 	public final fun contentType (Lkotlin/jvm/functions/Function1;)V
 	public final fun default (Ljava/lang/String;)V
 	public final fun enableAutoHeadResponse ()V
-	public final fun etag (Lio/ktor/server/http/content/ETagProvider;)V
 	public final fun exclude (Lkotlin/jvm/functions/Function1;)V
 	public final fun extensions ([Ljava/lang/String;)V
 	public final fun fallback (Lkotlin/jvm/functions/Function3;)V
-	public final fun lastModified (Lkotlin/jvm/functions/Function1;)V
 	public final fun modify (Lkotlin/jvm/functions/Function3;)V
 	public final fun preCompressed ([Lio/ktor/server/http/content/CompressedFileType;)V
 }
diff --git a/ktor-server/ktor-server-core/jvm/src/io/ktor/server/http/content/ETagProvider.kt b/ktor-server/ktor-server-core/jvm/src/io/ktor/server/http/content/ETagProvider.kt
deleted file mode 100644
index b92083d75..000000000
--- a/ktor-server/ktor-server-core/jvm/src/io/ktor/server/http/content/ETagProvider.kt
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * Copyright 2014-2025 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.
- */
-
-package io.ktor.server.http.content
-
-import io.ktor.http.content.*
-import io.ktor.util.logging.*
-import kotlinx.io.IOException
-import java.io.File
-import java.io.InputStream
-import java.net.URL
-import java.nio.file.Files
-import java.nio.file.Path
-import java.nio.file.attribute.BasicFileAttributes
-import java.security.MessageDigest
-import java.util.concurrent.ConcurrentHashMap
-import kotlin.io.inputStream
-import kotlin.use
-
-private val LOGGER = KtorSimpleLogger("io.ktor.server.http.content.ETagProvider")
-
-/**
- * Built‑in strategies for generating [io.ktor.http.HttpHeaders.ETag] for static content.
- *
- * Note: for this functionality to work, you need to install the [ConditionalHeaders] plugin.
- *
- * Usage:
- * ```
- * install(ConditionalHeaders)
- *
- * routing {
- *   staticFiles("/assets", File("assets")) {
- *     etag(ETagProvider.StrongSha256)
- *   }
- * }
- * ```
- *
- * [Report a problem](https://ktor.io/feedback/?fqname=io.ktor.server.http.content.ETagProvider)
- */
-public fun interface ETagProvider {
-
-    /**
-     * Provides an [EntityTagVersion] for the given resource or `null` if it cannot be provided.
-     */
-    public fun provide(resource: Any): EntityTagVersion?
-
-    public companion object {
-
-        private val etagCache by lazy { ConcurrentHashMap<String, EntityTagVersion>() }
-
-        /**
-         * Strong ETag provider based on SHA‑256 of the actual bytes of the resource.
-         * On I/O failures no ETag is produced
-         * Note: for this functionality to work, you need to install the [ConditionalHeaders] plugin.
-         *
-         * [Report a problem](https://ktor.io/feedback/?fqname=io.ktor.server.http.content.ETagProvider.Companion.StrongSha256)
-         */
-        public val StrongSha256: ETagProvider = ETagProvider { resource ->
-            val (key, streamSupplier) = try {
-                keyAndStreamSupplier(resource) ?: run {
-                    LOGGER.warn("StrongSha256 ETag not supported for ${resource::class}")
-                    return@ETagProvider null
-                }
-            } catch (cause: IOException) {
-                // failed to read metadata: no ETag
-                LOGGER.warn("Failed to prepare ETag computation for ${resource::class}: ${cause.message}")
-                return@ETagProvider null
-            }
-
-            etagCache[key] ?: run {
-                val computed = try {
-                    streamSupplier().use { ins ->
-                        val hex = sha256Hex(ins)
-                        EntityTagVersion(hex, weak = false)
-                    }
-                } catch (cause: IOException) {
-                    LOGGER.warn("Failed to compute ETag for resource $key: ${cause.message}")
-                    null // no ETag
-                }
-
-                if (computed != null) {
-                    etagCache.putIfAbsent(key, computed) ?: computed
-                } else {
-                    null
-                }
-            }
-        }
-    }
-}
-
-private fun keyAndStreamSupplier(resource: Any): Pair<String, () -> InputStream>? = when (resource) {
-    is File -> {
-        "${resource.absolutePath}:${resource.lastModified()}:${resource.length()}" to {
-            resource.inputStream()
-        }
-    }
-
-    is Path -> {
-        val path = resource.toAbsolutePath()
-        val attrs = Files.readAttributes(path, BasicFileAttributes::class.java)
-        "$path:${attrs.lastModifiedTime().toMillis()}:${attrs.size()}" to {
-            Files.newInputStream(path)
-        }
-    }
-
-    is URL -> {
-        val meta = runCatching {
-            val conn = resource.openConnection()
-            (conn.lastModified.takeIf { it > 0 }?.toString() ?: "") +
-                ":" + (conn.contentLengthLong.takeIf { it >= 0 }?.toString() ?: "")
-        }.getOrDefault("")
-        "${resource.toExternalForm()}:$meta" to { resource.openStream() }
-    }
-
-    else -> null
-}
-
-private fun sha256Hex(input: InputStream): String {
-    val md = MessageDigest.getInstance("SHA-256")
-    val buf = ByteArray(8192)
-    var n: Int
-    while (true) {
-        n = input.read(buf)
-        if (n == -1) break
-        md.update(buf, 0, n)
-    }
-    return md.digest().joinToString("") { "%02x".format(it) }
-}
diff --git a/ktor-server/ktor-server-core/jvm/src/io/ktor/server/http/content/PreCompressed.kt b/ktor-server/ktor-server-core/jvm/src/io/ktor/server/http/content/PreCompressed.kt
index e7ed2c38b..3905a7ee6 100644
--- a/ktor-server/ktor-server-core/jvm/src/io/ktor/server/http/content/PreCompressed.kt
+++ b/ktor-server/ktor-server-core/jvm/src/io/ktor/server/http/content/PreCompressed.kt
@@ -11,11 +11,9 @@ import io.ktor.server.request.*
 import io.ktor.server.response.*
 import io.ktor.server.routing.*
 import io.ktor.util.*
-import io.ktor.util.date.GMTDate
 import java.io.*
 import java.net.*
 import java.nio.file.*
-import kotlin.collections.plus
 import kotlin.io.path.*
 
 /**
@@ -121,8 +119,6 @@ internal suspend fun ApplicationCall.respondStaticFile(
     compressedTypes: List<CompressedFileType>?,
     contentType: (File) -> ContentType = { ContentType.defaultForFile(it) },
     cacheControl: (File) -> List<CacheControl> = { emptyList() },
-    lastModified: (File) -> GMTDate? = { null },
-    etag: ETagProvider = ETagProvider { null },
     modify: suspend (File, ApplicationCall) -> Unit = { _, _ -> }
 ) {
     attributes.put(StaticFileLocationProperty, requestedFile.path)
@@ -132,11 +128,7 @@ internal suspend fun ApplicationCall.respondStaticFile(
         if (requestedFile.isFile) {
             if (cacheControlValues.isNotEmpty()) response.header(HttpHeaders.CacheControl, cacheControlValues)
             modify(requestedFile, this)
-            val content = LocalFileContent(requestedFile, contentType(requestedFile)).apply {
-                etag.provide(requestedFile)?.let { versions += it }
-                lastModified(requestedFile)?.let { versions += LastModifiedVersion(it) }
-            }
-            respond(content)
+            respond(LocalFileContent(requestedFile, contentType(requestedFile)))
         }
         return
     }
@@ -148,10 +140,7 @@ internal suspend fun ApplicationCall.respondStaticFile(
         response.headers[HttpHeaders.Vary]?.plus(", ${HttpHeaders.AcceptEncoding}") ?: HttpHeaders.AcceptEncoding
     )
     modify(requestedFile, this)
-    val localFileContent = LocalFileContent(compressedFile, contentType(requestedFile)).apply {
-        etag.provide(compressedFile)?.let { versions += it }
-        lastModified(compressedFile)?.let { versions += LastModifiedVersion(it) }
-    }
+    val localFileContent = LocalFileContent(compressedFile, contentType(requestedFile))
     respond(PreCompressedResponse(localFileContent, bestCompressionFit.encoding))
 }
 
@@ -161,9 +150,7 @@ internal suspend fun ApplicationCall.respondStaticPath(
     compressedTypes: List<CompressedFileType>?,
     contentType: (Path) -> ContentType = { ContentType.defaultForPath(it) },
     cacheControl: (Path) -> List<CacheControl> = { emptyList() },
-    modify: suspend (Path, ApplicationCall) -> Unit = { _, _ -> },
-    lastModified: (Path) -> GMTDate? = { null },
-    etag: ETagProvider = ETagProvider { null },
+    modify: suspend (Path, ApplicationCall) -> Unit = { _, _ -> }
 ) {
     attributes.put(StaticFileLocationProperty, requestedPath.toString())
     val bestCompressionFit =
@@ -173,11 +160,7 @@ internal suspend fun ApplicationCall.respondStaticPath(
         if (requestedPath.exists()) {
             if (cacheControlValues.isNotEmpty()) response.header(HttpHeaders.CacheControl, cacheControlValues)
             modify(requestedPath, this)
-            val content = LocalPathContent(requestedPath, contentType(requestedPath)).apply {
-                etag.provide(requestedPath)?.let { versions += it }
-                lastModified(requestedPath)?.let { versions += LastModifiedVersion(it) }
-            }
-            respond(content)
+            respond(LocalPathContent(requestedPath, contentType(requestedPath)))
         }
         return
     }
@@ -185,10 +168,7 @@ internal suspend fun ApplicationCall.respondStaticPath(
     val (compressedPath, compression) = bestCompressionFit
     if (cacheControlValues.isNotEmpty()) response.header(HttpHeaders.CacheControl, cacheControlValues)
     modify(requestedPath, this)
-    val localFileContent = LocalPathContent(compressedPath, contentType(requestedPath)).apply {
-        etag.provide(compressedPath)?.let { versions += it }
-        lastModified(compressedPath)?.let { versions += LastModifiedVersion(it) }
-    }
+    val localFileContent = LocalPathContent(compressedPath, contentType(requestedPath))
     respond(PreCompressedResponse(localFileContent, compression.encoding))
 }
 
@@ -199,8 +179,6 @@ internal suspend fun ApplicationCall.respondStaticResource(
     contentType: (URL) -> ContentType = { ContentType.defaultForFileExtension(it.path.extension()) },
     cacheControl: (URL) -> List<CacheControl> = { emptyList() },
     modifier: suspend (URL, ApplicationCall) -> Unit = { _, _ -> },
-    lastModified: (URL) -> GMTDate? = { null },
-    etag: ETagProvider = ETagProvider { null },
     exclude: (URL) -> Boolean = { false }
 ) {
     attributes.put(StaticFileLocationProperty, requestedResource)
@@ -226,11 +204,7 @@ internal suspend fun ApplicationCall.respondStaticResource(
             response.headers[HttpHeaders.Vary]?.plus(", ${HttpHeaders.AcceptEncoding}") ?: HttpHeaders.AcceptEncoding
         )
         modifier(bestCompressionFit.url, this)
-        val content = PreCompressedResponse(bestCompressionFit.content, bestCompressionFit.compression.encoding).apply {
-            etag.provide(bestCompressionFit.url)?.let { versions += it }
-            lastModified(bestCompressionFit.url)?.let { versions += LastModifiedVersion(it) }
-        }
-        respond(content)
+        respond(PreCompressedResponse(bestCompressionFit.content, bestCompressionFit.compression.encoding))
         return
     }
 
@@ -247,10 +221,6 @@ internal suspend fun ApplicationCall.respondStaticResource(
         val cacheControlValues = cacheControl(content.first).joinToString(", ")
         if (cacheControlValues.isNotEmpty()) response.header(HttpHeaders.CacheControl, cacheControlValues)
         modifier(content.first, this)
-        val outgoingContent = content.second.apply {
-            etag.provide(content.first)?.let { versions += it }
-            lastModified(content.first)?.let { versions += LastModifiedVersion(it) }
-        }
-        respond(outgoingContent)
+        respond(content.second)
     }
 }
diff --git a/ktor-server/ktor-server-core/jvm/src/io/ktor/server/http/content/StaticContent.kt b/ktor-server/ktor-server-core/jvm/src/io/ktor/server/http/content/StaticContent.kt
index bbfa2ba13..6aa4fd63c 100644
--- a/ktor-server/ktor-server-core/jvm/src/io/ktor/server/http/content/StaticContent.kt
+++ b/ktor-server/ktor-server-core/jvm/src/io/ktor/server/http/content/StaticContent.kt
@@ -13,7 +13,6 @@ import io.ktor.server.http.content.FileSystemPaths.Companion.paths
 import io.ktor.server.response.*
 import io.ktor.server.routing.*
 import io.ktor.util.*
-import io.ktor.util.date.*
 import java.io.File
 import java.net.URL
 import java.nio.file.FileSystem
@@ -79,8 +78,6 @@ public class StaticContentConfig<Resource : Any> internal constructor() {
     internal var fallback: suspend (String, ApplicationCall) -> Unit = { _, _ -> }
     internal var preCompressedFileTypes: List<CompressedFileType> = emptyList()
     internal var autoHeadResponse: Boolean = false
-    internal var lastModifiedExtractor: (Resource) -> GMTDate? = { null }
-    internal var etagExtractor: ETagProvider = ETagProvider { null }
 
     /**
      * Enables pre-compressed files or resources.
@@ -185,32 +182,6 @@ public class StaticContentConfig<Resource : Any> internal constructor() {
         modifier = block
     }
 
-    /**
-     * Configures [HttpHeaders.LastModified] for requested static content.
-     * For files, [Resource] is a requested [File].
-     * For resources, [Resource] is a [URL] to a requested resource.
-     *
-     * Note: for this functionality to work, you need to install the [ConditionalHeaders] plugin.
-     *
-     * [Report a problem](https://ktor.io/feedback/?fqname=io.ktor.server.http.content.StaticContentConfig.lastModified)
-     */
-    public fun lastModified(block: (Resource) -> GMTDate?) {
-        lastModifiedExtractor = block
-    }
-
-    /**
-     * Configures [HttpHeaders.ETag] for requested content.
-     * For files, [Resource] is a requested [File].
-     * For resources, [Resource] is a [URL] to a requested resource.
-     *
-     * Note: for this functionality to work, you need to install the [ConditionalHeaders] plugin.
-     *
-     * [Report a problem](https://ktor.io/feedback/?fqname=io.ktor.server.http.content.StaticContentConfig.etag)
-     */
-    public fun etag(block: ETagProvider) {
-        etagExtractor = block
-    }
-
     /**
      * Configures resources that should not be served.
      * If this block returns `true` for [Resource], [Application] will respond with [HttpStatusCode.Forbidden].
@@ -271,8 +242,6 @@ public fun Route.staticFiles(
     val exclude = staticRoute.exclude
     val defaultPath = staticRoute.defaultPath
     val fallback = staticRoute.fallback
-    val lastModified = staticRoute.lastModifiedExtractor
-    val etag = staticRoute.etagExtractor
     return staticContentRoute(remotePath, autoHead) {
         respondStaticFile(
             index = index,
@@ -280,8 +249,6 @@ public fun Route.staticFiles(
             compressedTypes = compressedTypes,
             contentType = contentType,
             cacheControl = cacheControl,
-            lastModified = lastModified,
-            etag = etag,
             modify = modify,
             exclude = exclude,
             extensions = extensions,
@@ -319,8 +286,6 @@ public fun Route.staticResources(
     val exclude = staticRoute.exclude
     val defaultPath = staticRoute.defaultPath
     val fallback = staticRoute.fallback
-    val lastModified = staticRoute.lastModifiedExtractor
-    val etag = staticRoute.etagExtractor
     return staticContentRoute(remotePath, autoHead) {
         respondStaticResource(
             index = index,
@@ -328,8 +293,6 @@ public fun Route.staticResources(
             compressedTypes = compressedTypes,
             contentType = contentType,
             cacheControl = cacheControl,
-            lastModified = lastModified,
-            etag = etag,
             modifier = modifier,
             exclude = exclude,
             extensions = extensions,
@@ -437,8 +400,6 @@ public fun Route.staticFileSystem(
     val exclude = staticRoute.exclude
     val defaultPath = staticRoute.defaultPath
     val fallback = staticRoute.fallback
-    val lastModified = staticRoute.lastModifiedExtractor
-    val etag = staticRoute.etagExtractor
     return staticContentRoute(remotePath, autoHead) {
         respondStaticPath(
             fileSystem = fileSystem,
@@ -447,8 +408,6 @@ public fun Route.staticFileSystem(
             compressedTypes = compressedTypes,
             contentType = contentType,
             cacheControl = cacheControl,
-            lastModified = lastModified,
-            etag = etag,
             modify = modify,
             exclude = exclude,
             extensions = extensions,
@@ -490,10 +449,6 @@ public fun Route.preCompressed(
  *
  * [Report a problem](https://ktor.io/feedback/?fqname=io.ktor.server.http.content.staticRootFolder)
  */
-@Deprecated(
-    "This property only used in deprecated functions `files`, `file` and `default`. " +
-        "Please use `staticFiles` or `staticResources` instead"
-)
 public var Route.staticRootFolder: File?
     get() = attributes.getOrNull(staticRootFolderKey) ?: parent?.staticRootFolder
     set(value) {
@@ -721,8 +676,6 @@ private suspend fun ApplicationCall.respondStaticFile(
     compressedTypes: List<CompressedFileType>?,
     contentType: (File) -> ContentType,
     cacheControl: (File) -> List<CacheControl>,
-    lastModified: (File) -> GMTDate?,
-    etag: ETagProvider,
     modify: suspend (File, ApplicationCall) -> Unit,
     exclude: (File) -> Boolean,
     extensions: List<String>,
@@ -740,39 +693,23 @@ private suspend fun ApplicationCall.respondStaticFile(
 
     val isDirectory = requestedFile.isDirectory
     if (index != null && isDirectory) {
-        respondStaticFile(
-            File(requestedFile, index),
-            compressedTypes,
-            contentType,
-            cacheControl,
-            lastModified,
-            etag,
-            modify
-        )
+        respondStaticFile(File(requestedFile, index), compressedTypes, contentType, cacheControl, modify)
     } else if (!isDirectory) {
         if (checkExclude(requestedFile)) return
 
-        respondStaticFile(requestedFile, compressedTypes, contentType, cacheControl, lastModified, etag, modify)
+        respondStaticFile(requestedFile, compressedTypes, contentType, cacheControl, modify)
         if (isHandled) return
         for (extension in extensions) {
             val fileWithExtension = File("${requestedFile.path}.$extension")
             if (checkExclude(fileWithExtension)) return
-            respondStaticFile(fileWithExtension, compressedTypes, contentType, cacheControl, lastModified, etag, modify)
+            respondStaticFile(fileWithExtension, compressedTypes, contentType, cacheControl, modify)
             if (isHandled) return
         }
     }
 
     if (isHandled) return
     if (defaultPath != null) {
-        respondStaticFile(
-            File(dir, defaultPath),
-            compressedTypes,
-            contentType,
-            cacheControl,
-            lastModified,
-            etag,
-            modify
-        )
+        respondStaticFile(File(dir, defaultPath), compressedTypes, contentType, cacheControl, modify)
     }
 
     if (isHandled) return
@@ -786,8 +723,6 @@ private suspend fun ApplicationCall.respondStaticPath(
     compressedTypes: List<CompressedFileType>?,
     contentType: (Path) -> ContentType,
     cacheControl: (Path) -> List<CacheControl>,
-    lastModified: (Path) -> GMTDate?,
-    etag: ETagProvider,
     modify: suspend (Path, ApplicationCall) -> Unit,
     exclude: (Path) -> Boolean,
     extensions: List<String>,
@@ -805,43 +740,16 @@ private suspend fun ApplicationCall.respondStaticPath(
 
     val isDirectory = requestedPath.isDirectory()
     if (index != null && isDirectory) {
-        respondStaticPath(
-            fileSystem,
-            requestedPath.resolve(index),
-            compressedTypes,
-            contentType,
-            cacheControl,
-            modify,
-            lastModified,
-            etag
-        )
+        respondStaticPath(fileSystem, requestedPath.resolve(index), compressedTypes, contentType, cacheControl, modify)
     } else if (!isDirectory) {
         if (checkExclude(requestedPath)) return
 
-        respondStaticPath(
-            fileSystem,
-            requestedPath,
-            compressedTypes,
-            contentType,
-            cacheControl,
-            modify,
-            lastModified,
-            etag
-        )
+        respondStaticPath(fileSystem, requestedPath, compressedTypes, contentType, cacheControl, modify)
         if (isHandled) return
         for (extension in extensions) {
             val pathWithExtension = fileSystem.getPath("${requestedPath.pathString}.$extension")
             if (checkExclude(pathWithExtension)) return
-            respondStaticPath(
-                fileSystem,
-                pathWithExtension,
-                compressedTypes,
-                contentType,
-                cacheControl,
-                modify,
-                lastModified,
-                etag
-            )
+            respondStaticPath(fileSystem, pathWithExtension, compressedTypes, contentType, cacheControl, modify)
             if (isHandled) return
         }
     }
@@ -854,9 +762,7 @@ private suspend fun ApplicationCall.respondStaticPath(
             compressedTypes,
             contentType,
             cacheControl,
-            modify,
-            lastModified,
-            etag
+            modify
         )
     }
 
@@ -870,8 +776,6 @@ private suspend fun ApplicationCall.respondStaticResource(
     compressedTypes: List<CompressedFileType>?,
     contentType: (URL) -> ContentType,
     cacheControl: (URL) -> List<CacheControl>,
-    lastModified: (URL) -> GMTDate?,
-    etag: ETagProvider,
     modifier: suspend (URL, ApplicationCall) -> Unit,
     exclude: (URL) -> Boolean,
     extensions: List<String>,
@@ -887,8 +791,6 @@ private suspend fun ApplicationCall.respondStaticResource(
         contentType = contentType,
         cacheControl = cacheControl,
         modifier = modifier,
-        lastModified = lastModified,
-        etag = etag,
         exclude = exclude
     )
 
@@ -901,8 +803,6 @@ private suspend fun ApplicationCall.respondStaticResource(
             contentType = contentType,
             cacheControl = cacheControl,
             modifier = modifier,
-            lastModified = lastModified,
-            etag = etag,
             exclude = exclude
         )
         if (isHandled) return
@@ -915,9 +815,7 @@ private suspend fun ApplicationCall.respondStaticResource(
             compressedTypes = compressedTypes,
             contentType = contentType,
             cacheControl = cacheControl,
-            modifier = modifier,
-            lastModified = lastModified,
-            etag = etag,
+            modifier = modifier
         )
     }
 
@@ -929,9 +827,7 @@ private suspend fun ApplicationCall.respondStaticResource(
             compressedTypes = compressedTypes,
             contentType = contentType,
             cacheControl = cacheControl,
-            modifier = modifier,
-            lastModified = lastModified,
-            etag = etag,
+            modifier = modifier
         )
     }
 
diff --git a/ktor-server/ktor-server-tests/common/test/io/ktor/tests/server/plugins/ConditionalHeadersTests.kt b/ktor-server/ktor-server-tests/common/test/io/ktor/tests/server/plugins/ConditionalHeadersTests.kt
index 262a76f8b..08b2dad2b 100644
--- a/ktor-server/ktor-server-tests/common/test/io/ktor/tests/server/plugins/ConditionalHeadersTests.kt
+++ b/ktor-server/ktor-server-tests/common/test/io/ktor/tests/server/plugins/ConditionalHeadersTests.kt
@@ -157,11 +157,4 @@ class ETagsTest {
         }
         assertEquals(HttpStatusCode.PreconditionFailed, result.status)
     }
-
-    @Test
-    fun testInvalidWeakStarETag() {
-        assertFailsWith<IllegalArgumentException> {
-            EntityTagVersion(EntityTagVersion.STAR.etag, weak = true)
-        }
-    }
 }
diff --git a/ktor-server/ktor-server-tests/jvm/test/io/ktor/server/plugins/StaticContentTest.kt b/ktor-server/ktor-server-tests/jvm/test/io/ktor/server/plugins/StaticContentTest.kt
index 23bd53fbd..bdf890790 100644
--- a/ktor-server/ktor-server-tests/jvm/test/io/ktor/server/plugins/StaticContentTest.kt
+++ b/ktor-server/ktor-server-tests/jvm/test/io/ktor/server/plugins/StaticContentTest.kt
@@ -4,11 +4,10 @@
 
 package io.ktor.server.plugins
 
-import com.sun.nio.file.SensitivityWatchEventModifier
+import com.sun.nio.file.*
 import io.ktor.client.request.*
 import io.ktor.client.statement.*
 import io.ktor.http.*
-import io.ktor.http.content.*
 import io.ktor.server.application.*
 import io.ktor.server.http.content.*
 import io.ktor.server.plugins.autohead.*
@@ -19,18 +18,11 @@ import io.ktor.server.request.*
 import io.ktor.server.response.*
 import io.ktor.server.routing.*
 import io.ktor.server.testing.*
-import io.ktor.util.date.*
-import kotlinx.coroutines.delay
-import java.io.File
-import java.io.FileOutputStream
-import java.nio.file.FileSystems
-import java.nio.file.Files
-import java.nio.file.Paths
-import java.nio.file.StandardWatchEventKinds
-import java.util.zip.ZipEntry
-import java.util.zip.ZipOutputStream
-import kotlin.io.path.name
-import kotlin.io.path.pathString
+import kotlinx.coroutines.*
+import java.io.*
+import java.nio.file.*
+import java.util.zip.*
+import kotlin.io.path.*
 import kotlin.test.*
 
 class StaticContentTest {
@@ -1452,110 +1444,6 @@ class StaticContentTest {
         }
         return File(zipFileName)
     }
-
-    @Test
-    fun `test custom ETag and LastModified with ConditionalHeaders`() = testApplication {
-        val date = GMTDate()
-        val etag = "etag"
-
-        install(ConditionalHeaders)
-        routing {
-            staticResources("staticResources", "public") {
-                configure(etag, date)
-            }
-            staticFiles("staticFiles", basedir) {
-                configure(etag, date)
-            }
-            staticFileSystem("staticFileSystem", "jvm/test-resources/public") {
-                configure(etag, date)
-            }
-            staticZip("staticZip", "public", Paths.get("jvm/test-resources/public.zip")) {
-                configure(etag, date)
-            }
-
-            val filesDir = Files.createTempDirectory("assets").toFile()
-            val file = File(filesDir, "file.txt")
-            val brFile = File(filesDir, "file.txt.br")
-            file.writeText("file.txt")
-            brFile.writeText("temp.br")
-            staticFiles("staticFilesPrecompressed", filesDir) {
-                configure(etag, date)
-            }
-        }
-
-        testCustomEtagAndLastModified("staticFiles/plugins/PartialContentTest.kt", etag, date)
-        testCustomEtagAndLastModified("staticResources/nested/file-nested.txt", etag, date)
-        testCustomEtagAndLastModified("staticFileSystem/nested/file-nested.txt", etag, date)
-        testCustomEtagAndLastModified("staticZip/nested/file-nested.txt", etag, date)
-
-        // precompressed
-        testCustomEtagAndLastModified("staticFilesPrecompressed/file.txt", etag, date, "br")
-        testCustomEtagAndLastModified("staticResources/nested/file-nested.txt", etag, date, "br")
-        testCustomEtagAndLastModified("staticFileSystem/nested/file-nested.txt", etag, date, "br")
-        testCustomEtagAndLastModified("staticZip/nested/file-nested.txt", etag, date, "br")
-    }
-
-    private suspend fun ApplicationTestBuilder.testCustomEtagAndLastModified(
-        url: String,
-        expectedEtag: String,
-        expectedDate: GMTDate,
-        acceptEncoding: String? = null
-    ) {
-        val response = client.get(url) {
-            headers {
-                acceptEncoding?.let { append(HttpHeaders.AcceptEncoding, acceptEncoding) }
-            }
-        }
-        assertEquals(HttpStatusCode.OK, response.status)
-        val etag = response.headers[HttpHeaders.ETag] ?: fail("no ETag")
-        assertEquals(expectedEtag.quote(), etag)
-        assertEquals(expectedDate.toHttpDate(), response.headers[HttpHeaders.LastModified])
-    }
-
-    private fun StaticContentConfig<*>.configure(etag: String, date: GMTDate) {
-        preCompressed(CompressedFileType.BROTLI)
-        etag { EntityTagVersion(etag) }
-        lastModified { date }
-    }
-
-    @Test
-    fun `test strong etag`() = testApplication {
-        val filesDir = Files.createTempDirectory("etag-strong").toFile()
-        File(filesDir, "test.txt").apply { writeText("test.txt") }
-        File(filesDir, "test.txt.br").apply { writeText("test.txt.br") }
-        File(filesDir, "test.txt.gz").apply { writeText("test.txt.gz") }
-
-        install(ConditionalHeaders)
-        routing {
-            staticFiles("/static", filesDir) {
-                preCompressed(CompressedFileType.BROTLI, CompressedFileType.GZIP)
-                etag(ETagProvider.StrongSha256)
-            }
-        }
-
-        val idResponse = client.get("/static/test.txt")
-        assertEquals(HttpStatusCode.OK, idResponse.status)
-        val idEtag = idResponse.headers[HttpHeaders.ETag] ?: error("missing ETag for identity")
-        assertNull(idResponse.headers[HttpHeaders.ContentEncoding])
-
-        val brResponse = client.get("/static/test.txt") {
-            header(HttpHeaders.AcceptEncoding, "br")
-        }
-        assertEquals(HttpStatusCode.OK, brResponse.status)
-        val brEtag = brResponse.headers[HttpHeaders.ETag] ?: error("missing ETag for br")
-        assertEquals("br", brResponse.headers[HttpHeaders.ContentEncoding])
-
-        val gzResponse = client.get("/static/test.txt") {
-            header(HttpHeaders.AcceptEncoding, "gzip")
-        }
-        assertEquals(HttpStatusCode.OK, gzResponse.status)
-        val gzEtag = gzResponse.headers[HttpHeaders.ETag] ?: error("missing ETag for gz")
-        assertEquals("gzip", gzResponse.headers[HttpHeaders.ContentEncoding])
-
-        assertNotEquals(idEtag, brEtag)
-        assertNotEquals(idEtag, gzEtag)
-        assertNotEquals(gzEtag, brEtag)
-    }
 }
 
 private fun String.replaceSeparators() = replace("/", File.separator)
