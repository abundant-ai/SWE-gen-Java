diff --git a/buffer-netty/src/main/java/io/micronaut/buffer/netty/NettyByteBuffer.java b/buffer-netty/src/main/java/io/micronaut/buffer/netty/NettyByteBuffer.java
index 8a87d336a3..3050014270 100644
--- a/buffer-netty/src/main/java/io/micronaut/buffer/netty/NettyByteBuffer.java
+++ b/buffer-netty/src/main/java/io/micronaut/buffer/netty/NettyByteBuffer.java
@@ -38,7 +38,7 @@ import java.util.Arrays;
  * @since 1.0
  */
 @Internal
-final class NettyByteBuffer implements ByteBuffer<ByteBuf>, ReferenceCounted {
+class NettyByteBuffer implements ByteBuffer<ByteBuf>, ReferenceCounted {
 
     private ByteBuf delegate;
 
diff --git a/buffer-netty/src/main/java/io/micronaut/buffer/netty/NettyByteBufferConverters.java b/buffer-netty/src/main/java/io/micronaut/buffer/netty/NettyByteBufferConverters.java
deleted file mode 100644
index 3b36195a22..0000000000
--- a/buffer-netty/src/main/java/io/micronaut/buffer/netty/NettyByteBufferConverters.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
- * Copyright 2017-2022 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.buffer.netty;
-
-import io.micronaut.core.annotation.Internal;
-import io.micronaut.core.convert.MutableConversionService;
-import io.micronaut.core.convert.TypeConverterRegistrar;
-import io.micronaut.core.io.buffer.ByteBuffer;
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ByteBufUtil;
-import io.netty.buffer.CompositeByteBuf;
-import io.netty.buffer.Unpooled;
-
-import java.util.Optional;
-
-/**
- * Factory for {@link ByteBuf} and {@link NettyByteBuffer} related converters.
- *
- * @author Denis Stepanov
- * @since 4.6
- */
-@Internal
-public final class NettyByteBufferConverters implements TypeConverterRegistrar {
-    @Override
-    public void register(MutableConversionService conversionService) {
-
-        conversionService.addConverter(
-            NettyByteBuffer.class,
-            ByteBuf.class,
-            NettyByteBuffer::asNativeBuffer
-        );
-
-        conversionService.addConverter(
-            ByteBuf.class,
-            ByteBuffer.class,
-            NettyByteBuffer::new
-        );
-
-        conversionService.addConverter(
-            java.nio.ByteBuffer.class,
-            ByteBuf.class,
-            nioBuffer -> Unpooled.copiedBuffer(nioBuffer)
-        );
-
-        conversionService.addConverter(
-            ByteBuf.class,
-            CharSequence.class,
-            (byteBuf, target, context) -> Optional.of(byteBuf.toString(context.getCharset()))
-        );
-
-        conversionService.addConverter(
-            ByteBuf.class,
-            String.class,
-            (byteBuf, target, context) -> Optional.of(byteBuf.toString(context.getCharset()))
-        );
-
-        conversionService.addConverter(
-            CompositeByteBuf.class,
-            CharSequence.class,
-            (object, targetType, context) -> Optional.of(object.toString(context.getCharset()))
-        );
-
-        conversionService.addConverter(
-            ByteBuf.class,
-            byte[].class,
-            byteBuf -> ByteBufUtil.getBytes(byteBuf)
-        );
-
-        conversionService.addConverter(
-            byte[].class,
-            ByteBuf.class,
-            array -> Unpooled.wrappedBuffer(array)
-        );
-    }
-
-}
diff --git a/buffer-netty/src/main/java/io/micronaut/buffer/netty/NettyByteBufferFactory.java b/buffer-netty/src/main/java/io/micronaut/buffer/netty/NettyByteBufferFactory.java
index c628999fbe..0c60be79bd 100644
--- a/buffer-netty/src/main/java/io/micronaut/buffer/netty/NettyByteBufferFactory.java
+++ b/buffer-netty/src/main/java/io/micronaut/buffer/netty/NettyByteBufferFactory.java
@@ -17,6 +17,8 @@ package io.micronaut.buffer.netty;
 
 import io.micronaut.context.annotation.BootstrapContextCompatible;
 import io.micronaut.core.annotation.Internal;
+import io.micronaut.core.convert.MutableConversionService;
+import io.micronaut.core.convert.TypeConverterRegistrar;
 import io.micronaut.core.io.buffer.ByteBuffer;
 import io.micronaut.core.io.buffer.ByteBufferFactory;
 import io.netty.buffer.ByteBuf;
@@ -35,7 +37,7 @@ import java.util.function.Supplier;
 @Internal
 @Singleton
 @BootstrapContextCompatible
-public final class NettyByteBufferFactory implements ByteBufferFactory<ByteBufAllocator, ByteBuf> {
+public final class NettyByteBufferFactory implements ByteBufferFactory<ByteBufAllocator, ByteBuf>, TypeConverterRegistrar {
 
     /**
      * Default Netty ByteBuffer Factory.
@@ -58,6 +60,17 @@ public final class NettyByteBufferFactory implements ByteBufferFactory<ByteBufAl
         this.allocatorSupplier = () -> allocator;
     }
 
+    @Override
+    public void register(MutableConversionService conversionService) {
+        conversionService.addConverter(ByteBuf.class, ByteBuffer.class, DEFAULT::wrap);
+        conversionService.addConverter(ByteBuffer.class, ByteBuf.class, byteBuffer -> {
+            if (byteBuffer instanceof NettyByteBuffer) {
+                return (ByteBuf) byteBuffer.asNativeBuffer();
+            }
+            throw new IllegalArgumentException("Unconvertible buffer type " + byteBuffer);
+        });
+    }
+
     @Override
     public ByteBufAllocator getNativeAllocator() {
         return allocatorSupplier.get();
diff --git a/buffer-netty/src/main/resources/META-INF/services/io.micronaut.core.convert.TypeConverterRegistrar b/buffer-netty/src/main/resources/META-INF/services/io.micronaut.core.convert.TypeConverterRegistrar
deleted file mode 100644
index c2c02a7dc7..0000000000
--- a/buffer-netty/src/main/resources/META-INF/services/io.micronaut.core.convert.TypeConverterRegistrar
+++ /dev/null
@@ -1 +0,0 @@
-io.micronaut.buffer.netty.NettyByteBufferConverters
diff --git a/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java b/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java
index e563539031..03f5914edf 100644
--- a/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java
+++ b/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java
@@ -381,7 +381,7 @@ public class DefaultHttpClient implements
                     new ClientFilterResolutionContext(null, AnnotationMetadata.EMPTY_METADATA)
             );
         }
-        this.webSocketRegistry = webSocketBeanRegistry;
+        this.webSocketRegistry = webSocketBeanRegistry != null ? webSocketBeanRegistry : WebSocketBeanRegistry.EMPTY;
         this.requestBinderRegistry = requestBinderRegistry;
         this.informationalServiceId = informationalServiceId;
         this.conversionService = conversionService;
@@ -562,9 +562,18 @@ public class DefaultHttpClient implements
                         here.""");
                 }
                 BlockHint blockHint = BlockHint.willBlockThisThread();
-                return Flux.from(DefaultHttpClient.this.exchange(request, bodyType, errorType, blockHint))
-                    .blockFirst();
-                // We don't have to release client response buffer
+                Flux<HttpResponse<O>> publisher = Flux.from(DefaultHttpClient.this.exchange(request, bodyType, errorType, blockHint));
+                return publisher.doOnNext(res -> {
+                    Optional<ByteBuf> byteBuf = res.getBody(ByteBuf.class);
+                    byteBuf.ifPresent(bb -> {
+                        if (bb.refCnt() > 0) {
+                            ReferenceCountUtil.safeRelease(bb);
+                        }
+                    });
+                    if (res instanceof FullNettyClientHttpResponse response) {
+                        response.onComplete();
+                    }
+                }).blockFirst();
             }
 
             @Override
@@ -576,7 +585,7 @@ public class DefaultHttpClient implements
                     return (O) response.getStatus();
                 } else {
                     Optional<O> body = response.getBody();
-                    if (body.isEmpty() && response.getBody(Argument.of(byte[].class)).isPresent()) {
+                    if (!body.isPresent() && response.getBody(Argument.of(byte[].class)).isPresent()) {
                         throw decorate(new HttpClientResponseException(
                         "Failed to decode the body for the given content type [%s]".formatted(response.getContentType().orElse(null)),
                             response
@@ -606,12 +615,12 @@ public class DefaultHttpClient implements
 
     private <I> Publisher<Event<ByteBuffer<?>>> eventStreamOrError(@NonNull io.micronaut.http.HttpRequest<I> request, @NonNull Argument<?> errorType) {
 
-        if (request instanceof MutableHttpRequest<?> httpRequest) {
+        if (request instanceof MutableHttpRequest httpRequest) {
             httpRequest.accept(MediaType.TEXT_EVENT_STREAM_TYPE);
         }
 
         return Flux.create(emitter ->
-                dataStream(request, errorType).subscribe(new Subscriber<>() {
+                dataStream(request, errorType).subscribe(new Subscriber<ByteBuffer<?>>() {
                     private Subscription dataSubscription;
                     private CurrentEvent currentEvent;
 
@@ -663,33 +672,39 @@ public class DefaultHttpClient implements
                                     if (fromIndex < len) {
                                         int toIndex = len - fromIndex;
                                         switch (type) {
-                                            case "data" -> {
-                                                ByteBuffer<?> content = buffer.slice(fromIndex, toIndex);
+                                            case "data":
+                                                ByteBuffer content = buffer.slice(fromIndex, toIndex);
                                                 byte[] d = currentEvent.data;
                                                 if (d == null) {
                                                     currentEvent.data = content.toByteArray();
                                                 } else {
                                                     currentEvent.data = ArrayUtils.concat(d, content.toByteArray());
                                                 }
-                                            }
-                                            case "id" -> {
-                                                ByteBuffer<?> id = buffer.slice(fromIndex, toIndex);
+
+
+                                                break;
+                                            case "id":
+                                                ByteBuffer id = buffer.slice(fromIndex, toIndex);
                                                 currentEvent.id = id.toString(StandardCharsets.UTF_8).trim();
-                                            }
-                                            case "event" -> {
-                                                ByteBuffer<?> event = buffer.slice(fromIndex, toIndex);
+
+                                                break;
+                                            case "event":
+                                                ByteBuffer event = buffer.slice(fromIndex, toIndex);
                                                 currentEvent.name = event.toString(StandardCharsets.UTF_8).trim();
-                                            }
-                                            case "retry" -> {
-                                                ByteBuffer<?> retry = buffer.slice(fromIndex, toIndex);
+
+                                                break;
+                                            case "retry":
+                                                ByteBuffer retry = buffer.slice(fromIndex, toIndex);
                                                 String text = retry.toString(StandardCharsets.UTF_8);
                                                 if (!StringUtils.isEmpty(text)) {
-                                                    currentEvent.retry = Duration.ofMillis(Long.parseLong(text));
+                                                    Long millis = Long.valueOf(text);
+                                                    currentEvent.retry = Duration.ofMillis(millis);
                                                 }
-                                            }
-                                            default -> {
+
+                                                break;
+                                            default:
                                                 // ignore message
-                                            }
+                                                break;
                                         }
                                     }
                                 }
@@ -838,7 +853,7 @@ public class DefaultHttpClient implements
                 return (O) response.getStatus();
             } else {
                 Optional<O> body = response.getBody();
-                if (body.isEmpty() && response.getBody(byte[].class).isPresent()) {
+                if (!body.isPresent() && response.getBody(byte[].class).isPresent()) {
                     throw decorate(new HttpClientResponseException(
                     "Failed to decode the body for the given content type [%s]".formatted(response.getContentType().orElse(null)),
                         response
@@ -1024,7 +1039,7 @@ public class DefaultHttpClient implements
                     AtomicReference<MutableHttpRequest<?>> requestWrapper = new AtomicReference<>(httpRequest);
                     Flux<HttpResponse<?>> proxyResponsePublisher = connectAndStream(request, request, requestURI, requestWrapper, true, false);
                     // apply filters
-                    //noinspection
+                    //noinspection unchecked
                     proxyResponsePublisher = Flux.from(
                             applyFilterToResponsePublisher(
                                     request,
@@ -1271,7 +1286,7 @@ public class DefaultHttpClient implements
      * @throws HttpPostRequestEncoder.ErrorDataEncoderException if there is an encoder exception
      */
     protected NettyRequestWriter buildNettyRequest(
-        MutableHttpRequest<?> request,
+        MutableHttpRequest request,
         URI requestURI,
         MediaType requestContentType,
         boolean permitsBody,
@@ -1293,7 +1308,7 @@ public class DefaultHttpClient implements
 
         HttpPostRequestEncoder postRequestEncoder = null;
         if (permitsBody) {
-            Optional<?> body = request.getBody();
+            Optional body = request.getBody();
             boolean hasBody = body.isPresent();
             if (requestContentType.equals(MediaType.APPLICATION_FORM_URLENCODED_TYPE) && hasBody) {
                 Object bodyValue = body.get();
@@ -1311,7 +1326,7 @@ public class DefaultHttpClient implements
                 postRequestEncoder = buildMultipartRequest(request, bodyValue);
                 return postToWriter(newUri, postRequestEncoder);
             } else {
-                ByteBuf bodyContent;
+                ByteBuf bodyContent = null;
                 if (hasBody) {
                     Object bodyValue = body.get();
                     DynamicMessageBodyWriter dynamicWriter = new DynamicMessageBodyWriter(handlerRegistry, List.of(requestContentType));
@@ -1432,6 +1447,7 @@ public class DefaultHttpClient implements
                                     try {
                                         FullHttpResponse fullHttpResponse = new DefaultFullHttpResponse(nettyResponse.protocolVersion(), nettyResponse.status(), buffer, nettyResponse.headers(), new DefaultHttpHeaders(true));
                                         final FullNettyClientHttpResponse<Object> fullNettyClientHttpResponse = new FullNettyClientHttpResponse<>(fullHttpResponse, handlerRegistry, (Argument<Object>) errorType, true, conversionService);
+                                        fullNettyClientHttpResponse.onComplete();
                                         emitter.error(decorate(new HttpClientResponseException(
                                             fullHttpResponse.status().reasonPhrase(),
                                             null,
@@ -1465,7 +1481,7 @@ public class DefaultHttpClient implements
 
         return Flux.from(loadBalancer.select(getLoadBalancerDiscriminator())).map(server -> {
                     Optional<String> authInfo = server.getMetadata().get(io.micronaut.http.HttpHeaders.AUTHORIZATION_INFO, String.class);
-                    if (request instanceof MutableHttpRequest<?> httpRequest && authInfo.isPresent()) {
+                    if (request instanceof MutableHttpRequest httpRequest && authInfo.isPresent()) {
                         httpRequest.getHeaders().auth(authInfo.get());
                     }
 
@@ -1607,8 +1623,9 @@ public class DefaultHttpClient implements
     }
 
     private ByteBuf charSequenceToByteBuf(CharSequence bodyValue, MediaType requestContentType) {
+        CharSequence charSequence = bodyValue;
         return byteBufferFactory.copiedBuffer(
-                bodyValue.toString().getBytes(
+                charSequence.toString().getBytes(
                         requestContentType.getCharset().orElse(defaultCharset)
                 )
         ).asNativeBuffer();
@@ -1664,7 +1681,7 @@ public class DefaultHttpClient implements
         }
     }
 
-    private HttpPostRequestEncoder buildFormDataRequest(MutableHttpRequest<?> clientHttpRequest, Object bodyValue) throws HttpPostRequestEncoder.ErrorDataEncoderException {
+    private HttpPostRequestEncoder buildFormDataRequest(MutableHttpRequest clientHttpRequest, Object bodyValue) throws HttpPostRequestEncoder.ErrorDataEncoderException {
         HttpPostRequestEncoder postRequestEncoder = new HttpPostRequestEncoder(NettyHttpRequestBuilder.asBuilder(clientHttpRequest).toHttpRequestWithoutBody(), false);
 
         Map<String, Object> formData;
@@ -1676,7 +1693,7 @@ public class DefaultHttpClient implements
         for (Map.Entry<String, Object> entry : formData.entrySet()) {
             Object value = entry.getValue();
             if (value != null) {
-                if (value instanceof Collection<?> collection) {
+                if (value instanceof Collection collection) {
                     for (Object val : collection) {
                         addBodyAttribute(postRequestEncoder, entry.getKey(), val);
                     }
@@ -1695,7 +1712,7 @@ public class DefaultHttpClient implements
         }
     }
 
-    private HttpPostRequestEncoder buildMultipartRequest(MutableHttpRequest<?> clientHttpRequest, Object bodyValue) throws HttpPostRequestEncoder.ErrorDataEncoderException {
+    private HttpPostRequestEncoder buildMultipartRequest(MutableHttpRequest clientHttpRequest, Object bodyValue) throws HttpPostRequestEncoder.ErrorDataEncoderException {
         HttpDataFactory factory = new DefaultHttpDataFactory(DefaultHttpDataFactory.MINSIZE);
         io.netty.handler.codec.http.HttpRequest request = NettyHttpRequestBuilder.asBuilder(clientHttpRequest).toHttpRequestWithoutBody();
         HttpPostRequestEncoder postRequestEncoder = new HttpPostRequestEncoder(factory, request, true, CharsetUtil.UTF_8, HttpPostRequestEncoder.EncoderMode.HTML5);
@@ -1703,7 +1720,7 @@ public class DefaultHttpClient implements
             bodyValue = builder.build();
         }
         if (bodyValue instanceof MultipartBody multipartBody) {
-            postRequestEncoder.setBodyHttpDatas(multipartBody.getData(new MultipartDataFactory<>() {
+            postRequestEncoder.setBodyHttpDatas(multipartBody.getData(new MultipartDataFactory<InterfaceHttpData>() {
                 @NonNull
                 @Override
                 public InterfaceHttpData createFileUpload(@NonNull String name, @NonNull String filename, @NonNull MediaType contentType, @Nullable String encoding, @Nullable Charset charset, long length) {
@@ -2132,7 +2149,7 @@ public class DefaultHttpClient implements
         protected abstract Function<URI, Publisher<? extends O>> makeRedirectHandler(io.micronaut.http.HttpRequest<?> parentRequest, MutableHttpRequest<Object> redirectRequest);
     }
 
-    private final class FullHttpResponseHandler<O> extends BaseHttpResponseHandler<HttpResponse<O>> {
+    private class FullHttpResponseHandler<O> extends BaseHttpResponseHandler<HttpResponse<O>> {
         private final Argument<O> bodyType;
         private final Argument<?> errorType;
         private final ConnectionManager.PoolHandle poolHandle;
@@ -2192,12 +2209,16 @@ public class DefaultHttpClient implements
 
                 if (convertBodyWithBodyType) {
                     responsePromise.trySuccess(response);
+                    response.onComplete();
                 } else { // error flow
                     try {
                         responsePromise.tryFailure(makeErrorFromRequestBody(msg.status(), response));
+                        response.onComplete();
                     } catch (HttpClientResponseException t) {
                         responsePromise.tryFailure(t);
+                        response.onComplete();
                     } catch (Exception t) {
+                        response.onComplete();
                         responsePromise.tryFailure(makeErrorBodyParseError(msg, t));
                     }
                 }
@@ -2255,6 +2276,8 @@ public class DefaultHttpClient implements
                     false,
                     conversionService
             );
+            // this onComplete call disables further parsing by HttpClientResponseException
+            errorResponse.onComplete();
             return decorate(new HttpClientResponseException(
                 "Error decoding HTTP error response body: " + t.getMessage(),
                 t,
@@ -2282,7 +2305,11 @@ public class DefaultHttpClient implements
                     }
                 }
             ));
-            forward.accept(clientResponseError);
+            try {
+                forward.accept(clientResponseError);
+            } finally {
+                response.onComplete();
+            }
         }
 
         @Override
@@ -2299,7 +2326,7 @@ public class DefaultHttpClient implements
         }
     }
 
-    private final class StreamHttpResponseHandler extends BaseHttpResponseHandler<MutableHttpResponse<?>> {
+    private class StreamHttpResponseHandler extends BaseHttpResponseHandler<MutableHttpResponse<?>> {
         static final String NAME_FLOW_CONTROL = ChannelPipelineCustomizer.HANDLER_MICRONAUT_HTTP_RESPONSE + "-flow-control";
         static final String NAME_PUBLISHER = ChannelPipelineCustomizer.HANDLER_MICRONAUT_HTTP_RESPONSE + "-publisher";
 
diff --git a/http-client/src/main/java/io/micronaut/http/client/netty/FullNettyClientHttpResponse.java b/http-client/src/main/java/io/micronaut/http/client/netty/FullNettyClientHttpResponse.java
index b8bc5d870a..b8c9c9d7ff 100644
--- a/http-client/src/main/java/io/micronaut/http/client/netty/FullNettyClientHttpResponse.java
+++ b/http-client/src/main/java/io/micronaut/http/client/netty/FullNettyClientHttpResponse.java
@@ -18,6 +18,7 @@ package io.micronaut.http.client.netty;
 import io.micronaut.buffer.netty.NettyByteBufferFactory;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.NonNull;
+import io.micronaut.core.async.subscriber.Completable;
 import io.micronaut.core.convert.ConversionService;
 import io.micronaut.core.convert.value.MutableConvertibleValues;
 import io.micronaut.core.convert.value.MutableConvertibleValuesMap;
@@ -54,7 +55,7 @@ import java.util.Optional;
  * @since 1.0
  */
 @Internal
-public class FullNettyClientHttpResponse<B> implements HttpResponse<B>, NettyHttpResponseBuilder {
+public class FullNettyClientHttpResponse<B> implements HttpResponse<B>, Completable, NettyHttpResponseBuilder {
 
     private static final Logger LOG = LoggerFactory.getLogger(DefaultHttpClient.class);
 
@@ -66,6 +67,7 @@ public class FullNettyClientHttpResponse<B> implements HttpResponse<B>, NettyHtt
     private final Map<Argument, Optional> convertedBodies = new HashMap<>();
     private final MessageBodyHandlerRegistry handlerRegistry;
     private final B body;
+    private boolean complete;
     private final ConversionService conversionService;
 
     /**
@@ -87,9 +89,8 @@ public class FullNettyClientHttpResponse<B> implements HttpResponse<B>, NettyHtt
         this.nettyHttpResponse = fullHttpResponse;
         // this class doesn't really have lifecycle management (we don't make the user release()
         // it), so we have to copy the data to a non-refcounted buffer.
-        ByteBuf buffer = Unpooled.buffer(fullHttpResponse.content().readableBytes());
-        buffer.writeBytes(fullHttpResponse.content(), 0, fullHttpResponse.content().readableBytes());
-        this.unpooledContent = Unpooled.unreleasableBuffer(buffer);
+        this.unpooledContent = Unpooled.buffer(fullHttpResponse.content().readableBytes());
+        unpooledContent.writeBytes(fullHttpResponse.content(), 0, fullHttpResponse.content().readableBytes());
         this.handlerRegistry = handlerRegistry;
         this.nettyCookies = new NettyCookies(fullHttpResponse.headers(), conversionService);
         Class<?> rawBodyType = bodyType != null ? bodyType.getType() : null;
@@ -169,7 +170,7 @@ public class FullNettyClientHttpResponse<B> implements HttpResponse<B>, NettyHtt
             final Argument finalArgument = isOptional ? argument.getFirstTypeVariable().orElse(argument) : argument;
             Optional<T> converted;
             try {
-                converted = convertByteBuf(finalArgument);
+                converted = convertByteBuf(unpooledContent, finalArgument);
             } catch (RuntimeException e) {
                 if (code() < 400) {
                     throw e;
@@ -198,8 +199,8 @@ public class FullNettyClientHttpResponse<B> implements HttpResponse<B>, NettyHtt
         return CharSequence.class.isAssignableFrom(rawBodyType) || Map.class.isAssignableFrom(rawBodyType);
     }
 
-    private <T> Optional<T> convertByteBuf(Argument<T> type) {
-        if (unpooledContent.refCnt() == 0 || unpooledContent.readableBytes() == 0) {
+    private <T> Optional<T> convertByteBuf(ByteBuf content, Argument<T> type) {
+        if (content.refCnt() == 0 || content.readableBytes() == 0) {
             if (LOG.isTraceEnabled()) {
                 LOG.trace("Full HTTP response received an empty body");
             }
@@ -220,14 +221,19 @@ public class FullNettyClientHttpResponse<B> implements HttpResponse<B>, NettyHtt
                 MessageBodyReader<T> r = reader.get();
                 MediaType ct = contentType.get();
                 if (r.isReadable(type, ct)) {
-                    return Optional.of(r.read(type, ct, headers, NettyByteBufferFactory.DEFAULT.wrap(unpooledContent)));
+                    return Optional.of(r.read(type, ct, headers, NettyByteBufferFactory.DEFAULT.wrap(content.retainedSlice())));
                 }
             }
         } else if (LOG.isTraceEnabled()) {
             LOG.trace("Missing or unknown Content-Type received from server.");
         }
         // last chance, try type conversion
-        return conversionService.convert(unpooledContent, ByteBuf.class, type);
+        return conversionService.convert(content, ByteBuf.class, type);
+    }
+
+    @Override
+    public void onComplete() {
+        this.complete = true;
     }
 
     @NonNull
diff --git a/http-client/src/test/groovy/io/micronaut/http/client/ResponseBodySpec.groovy b/http-client/src/test/groovy/io/micronaut/http/client/ResponseBodySpec.groovy
deleted file mode 100644
index 44bfb8b986..0000000000
--- a/http-client/src/test/groovy/io/micronaut/http/client/ResponseBodySpec.groovy
+++ /dev/null
@@ -1,150 +0,0 @@
-package io.micronaut.http.client
-
-import io.micronaut.context.ApplicationContext
-import io.micronaut.context.annotation.Requires
-import io.micronaut.core.convert.ConversionService
-import io.micronaut.core.io.buffer.ByteBuffer
-import io.micronaut.core.type.Argument
-import io.micronaut.core.type.MutableHeaders
-import io.micronaut.http.HttpRequest
-import io.micronaut.http.MediaType
-import io.micronaut.http.annotation.Controller
-import io.micronaut.http.annotation.Get
-import io.micronaut.http.body.MessageBodyWriter
-import io.micronaut.http.codec.CodecException
-import io.micronaut.runtime.server.EmbeddedServer
-import io.netty.buffer.ByteBuf
-import jakarta.inject.Singleton
-import spock.lang.AutoCleanup
-import spock.lang.Shared
-import spock.lang.Specification
-
-import java.nio.charset.StandardCharsets
-
-class ResponseBodySpec extends Specification {
-
-    @Shared
-    @AutoCleanup
-    EmbeddedServer server = ApplicationContext.run(EmbeddedServer, [
-            'spec.name': 'ResponseBodySpec'
-    ])
-
-    @AutoCleanup
-    HttpClient httpClient = server.applicationContext.createBean(HttpClient, server.getURI())
-
-    def "get a string of empty content type response"() {
-        when:
-            def response = httpClient.toBlocking().exchange(HttpRequest.GET("/response-body/string"))
-
-        then:
-            response.getContentType().isEmpty()
-            response.getBody(String).get() == "Hello"
-    }
-
-    def "get a number of empty content type response"() {
-        when:
-            def response = httpClient.toBlocking().exchange(HttpRequest.GET("/response-body/number"))
-
-        then:
-            response.getContentType().isEmpty()
-            response.getBody(numberClass).get() == numberValue
-
-        where:
-            numberClass || numberValue
-            BigDecimal  || BigDecimal.valueOf(12345)
-            Integer     || Integer.valueOf(12345)
-            Double      || Double.valueOf(12345)
-    }
-
-    def "get a string after releasing ByteRef of empty content type response"() {
-        when:
-            def response = httpClient.toBlocking().exchange(HttpRequest.GET("/response-body/string"))
-        then:
-            response.getContentType().isEmpty()
-        when:
-            def buffer = response.getBody(ByteBuf).get()
-            buffer.release()
-        then:
-            response.getBody(String).get() == "Hello"
-    }
-
-    def "get a ByteBuffer"() {
-        when:
-            def response = httpClient.toBlocking().exchange(HttpRequest.GET("/response-body/string"))
-        then:
-            response.getContentType().isEmpty()
-            response.getBody(ByteBuffer).isPresent()
-    }
-
-    def "get a ByteBuffer 2"() {
-        when:
-            def response = httpClient.toBlocking().exchange(HttpRequest.GET("/response-body/string"))
-        then:
-            response.getContentType().isEmpty()
-        when:
-            def buffer = response.getBody(ByteBuf).get()
-            buffer.release()
-        then:
-            response.getBody(ByteBuffer).isPresent()
-    }
-
-    def "get a ByteBuffer 3"() {
-        when:
-            def response = httpClient.toBlocking().exchange(HttpRequest.GET("/response-body/string"))
-        then:
-            response.getContentType().isEmpty()
-        when:
-            def buffer = response.getBody(ByteBuf).get()
-        then:
-            ConversionService.SHARED.convert(buffer, ByteBuffer).isPresent()
-    }
-
-    @Requires(property = 'spec.name', value = 'ResponseBodySpec')
-    @Controller("/response-body")
-    static class BodyController {
-
-        @Get("/string")
-        StringResponseNoContent string() {
-            return new StringResponseNoContent()
-        }
-
-        @Get("/number")
-        NumberResponseNoContent number() {
-            return new NumberResponseNoContent()
-        }
-    }
-
-    static class StringResponseNoContent {}
-
-    static class NumberResponseNoContent {}
-
-    @Requires(property = 'spec.name', value = 'ResponseBodySpec')
-    @Singleton
-    static class StringResponseNoContentWriter implements MessageBodyWriter<StringResponseNoContent> {
-
-        @Override
-        void writeTo(Argument<StringResponseNoContent> type,
-                     MediaType mediaType,
-                     StringResponseNoContent object,
-                     MutableHeaders outgoingHeaders,
-                     OutputStream outputStream) throws CodecException {
-            // Write response without content type
-            outputStream.write("Hello".getBytes(StandardCharsets.UTF_8))
-        }
-    }
-
-    @Requires(property = 'spec.name', value = 'ResponseBodySpec')
-    @Singleton
-    static class NumberResponseNoContentWriter implements MessageBodyWriter<NumberResponseNoContent> {
-
-        @Override
-        void writeTo(Argument<NumberResponseNoContent> type,
-                     MediaType mediaType,
-                     NumberResponseNoContent object,
-                     MutableHeaders outgoingHeaders,
-                     OutputStream outputStream) throws CodecException {
-            // Write response without content type
-            outputStream.write("12345".getBytes(StandardCharsets.UTF_8))
-        }
-    }
-}
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/converters/NettyConverters.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/converters/NettyConverters.java
index 07452c53b6..54b8b47626 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/converters/NettyConverters.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/converters/NettyConverters.java
@@ -19,6 +19,7 @@ import io.micronaut.context.BeanProvider;
 import io.micronaut.context.annotation.Prototype;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.convert.ArgumentConversionContext;
+import io.micronaut.core.convert.ConversionContext;
 import io.micronaut.core.convert.ConversionService;
 import io.micronaut.core.convert.MutableConversionService;
 import io.micronaut.core.convert.TypeConverterRegistrar;
@@ -185,6 +186,24 @@ public final class NettyConverters implements TypeConverterRegistrar {
         return converted;
     }
 
+    /**
+     * This method converts a
+     * {@link io.netty.util.ReferenceCounted netty reference counted object} and transfers release
+     * ownership to the new object.
+     *
+     * @param service    The conversion service
+     * @param input      The object to convert
+     * @param targetType The type to convert to
+     * @param context    The context to convert with
+     * @param <T>        Target type
+     * @return The converted object
+     */
+    public static <T> Optional<T> refCountAwareConvert(ConversionService service, ReferenceCounted input, Class<T> targetType, ConversionContext context) {
+        Optional<T> converted = service.convert(input, targetType, context);
+        postProcess(input, converted);
+        return converted;
+    }
+
     @SuppressWarnings("OptionalUsedAsFieldOrParameterType")
     private static <T> void postProcess(ReferenceCounted input, Optional<T> converted) {
         if (converted.isPresent()) {
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/converters/NettyConvertersSpi.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/converters/NettyConvertersSpi.java
index 424ae81ab7..2a622cf917 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/converters/NettyConvertersSpi.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/converters/NettyConvertersSpi.java
@@ -27,6 +27,8 @@ import io.micronaut.http.server.netty.multipart.NettyCompletedFileUpload;
 import io.micronaut.http.server.netty.multipart.NettyPartData;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufUtil;
+import io.netty.buffer.CompositeByteBuf;
+import io.netty.buffer.Unpooled;
 import io.netty.channel.WriteBufferWaterMark;
 import io.netty.handler.codec.http.multipart.Attribute;
 import io.netty.handler.codec.http.multipart.FileUpload;
@@ -54,6 +56,35 @@ public final class NettyConvertersSpi implements TypeConverterRegistrar {
                 NettyHttpServerConfiguration.NettyListenerConfiguration.Family.class,
                 new CharSequenceToEnumConverter<>()
         );
+        conversionService.addConverter(
+                ByteBuf.class,
+                CharSequence.class,
+                (byteBuf, target, context) -> Optional.of(byteBuf.toString(context.getCharset()))
+        );
+
+        conversionService.addConverter(
+                ByteBuf.class,
+                String.class,
+                (byteBuf, target, context) -> Optional.of(byteBuf.toString(context.getCharset()))
+        );
+
+        conversionService.addConverter(
+                CompositeByteBuf.class,
+                CharSequence.class,
+                (object, targetType, context) -> Optional.of(object.toString(context.getCharset()))
+        );
+
+        conversionService.addConverter(
+                ByteBuf.class,
+                byte[].class,
+                (object, targetType, context) -> Optional.of(ByteBufUtil.getBytes(object))
+        );
+
+        conversionService.addConverter(
+                byte[].class,
+                ByteBuf.class,
+                (object, targetType, context) -> Optional.of(Unpooled.wrappedBuffer(object))
+        );
 
         conversionService.addConverter(
                 FileUpload.class,
