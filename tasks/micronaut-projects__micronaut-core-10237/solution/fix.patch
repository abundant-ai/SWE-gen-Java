diff --git a/core-processor/src/main/java/io/micronaut/inject/ast/DefaultElementQuery.java b/core-processor/src/main/java/io/micronaut/inject/ast/DefaultElementQuery.java
index 269a0793ac..4b4cde2f3c 100644
--- a/core-processor/src/main/java/io/micronaut/inject/ast/DefaultElementQuery.java
+++ b/core-processor/src/main/java/io/micronaut/inject/ast/DefaultElementQuery.java
@@ -49,6 +49,7 @@ final class DefaultElementQuery<T extends Element> implements ElementQuery<T>, E
     private final boolean includeOverriddenMethods;
     private final boolean includeHiddenElements;
     private final boolean excludePropertyElements;
+    private final int hashcode;
 
     DefaultElementQuery(Class<T> elementType) {
         this(elementType, null, false, false, false, false, false, false, false, false, false, false, null, null, null, null, null);
@@ -89,6 +90,7 @@ final class DefaultElementQuery<T extends Element> implements ElementQuery<T>, E
         this.includeHiddenElements = includeHiddenElements;
         this.excludePropertyElements = excludePropertyElements;
         this.typePredicates = typePredicates;
+        this.hashcode = Objects.hash(elementType, onlyAccessibleType, onlyDeclared, onlyAbstract, onlyConcrete, onlyInjected, namePredicates, annotationPredicates, modifiersPredicates, elementPredicates, typePredicates, onlyInstance, onlyStatic, includeEnumConstants, includeOverriddenMethods, includeHiddenElements, excludePropertyElements);
     }
 
     @Override
@@ -561,4 +563,21 @@ final class DefaultElementQuery<T extends Element> implements ElementQuery<T>, E
     public Result<T> result() {
         return this;
     }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (o == null || getClass() != o.getClass()) {
+            return false;
+        }
+        DefaultElementQuery<?> that = (DefaultElementQuery<?>) o;
+        return onlyDeclared == that.onlyDeclared && onlyAbstract == that.onlyAbstract && onlyConcrete == that.onlyConcrete && onlyInjected == that.onlyInjected && onlyInstance == that.onlyInstance && onlyStatic == that.onlyStatic && includeEnumConstants == that.includeEnumConstants && includeOverriddenMethods == that.includeOverriddenMethods && includeHiddenElements == that.includeHiddenElements && excludePropertyElements == that.excludePropertyElements && Objects.equals(elementType, that.elementType) && Objects.equals(onlyAccessibleType, that.onlyAccessibleType) && Objects.equals(namePredicates, that.namePredicates) && Objects.equals(annotationPredicates, that.annotationPredicates) && Objects.equals(modifiersPredicates, that.modifiersPredicates) && Objects.equals(elementPredicates, that.elementPredicates) && Objects.equals(typePredicates, that.typePredicates);
+    }
+
+    @Override
+    public int hashCode() {
+        return hashcode;
+    }
 }
diff --git a/core-processor/src/main/java/io/micronaut/inject/ast/MethodElement.java b/core-processor/src/main/java/io/micronaut/inject/ast/MethodElement.java
index ae1c5cad5e..c4764c8bad 100644
--- a/core-processor/src/main/java/io/micronaut/inject/ast/MethodElement.java
+++ b/core-processor/src/main/java/io/micronaut/inject/ast/MethodElement.java
@@ -329,6 +329,10 @@ public interface MethodElement extends MemberElement {
                     return false;
                 }
             }
+            if (!getDeclaringType().isAssignable(memberElement.getDeclaringType())) {
+                // not a parent class
+                return false;
+            }
             ClassElement existingReturnType = hidden.getReturnType().getGenericType();
             ClassElement newTypeReturn = newMethod.getReturnType().getGenericType();
             if (!newTypeReturn.isAssignable(existingReturnType)) {
@@ -337,7 +341,7 @@ public interface MethodElement extends MemberElement {
             if (hidden.isPackagePrivate()) {
                 return newMethod.getDeclaringType().getPackageName().equals(hidden.getDeclaringType().getPackageName());
             }
-            return true;
+            return memberElement.isAccessible(getDeclaringType());
         }
         return false;
     }
diff --git a/core-processor/src/main/java/io/micronaut/inject/ast/utils/EnclosedElementsQuery.java b/core-processor/src/main/java/io/micronaut/inject/ast/utils/EnclosedElementsQuery.java
index ffb63c2c2a..07c2aac102 100644
--- a/core-processor/src/main/java/io/micronaut/inject/ast/utils/EnclosedElementsQuery.java
+++ b/core-processor/src/main/java/io/micronaut/inject/ast/utils/EnclosedElementsQuery.java
@@ -34,7 +34,7 @@ import java.util.Collection;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
@@ -54,7 +54,9 @@ import java.util.function.Predicate;
 public abstract class EnclosedElementsQuery<C, N> {
 
     private static final int MAX_ITEMS_IN_CACHE = 200;
+    private static final int MAX_RESULTS = 20;
     private final Map<CacheKey, Element> elementsCache = new LinkedHashMap<>();
+    private final Map<QueryResultKey, List<?>> resultsCache = new LinkedHashMap<>();
 
     /**
      * Get native class element.
@@ -87,6 +89,13 @@ public abstract class EnclosedElementsQuery<C, N> {
     public <T extends io.micronaut.inject.ast.Element> List<T> getEnclosedElements(ClassElement classElement, @NonNull ElementQuery<T> query) {
         Objects.requireNonNull(query, "Query cannot be null");
         ElementQuery.Result<T> result = query.result();
+
+        QueryResultKey queryResultKey = new QueryResultKey(result, classElement.getNativeType());
+        List<T> values = (List<T>) resultsCache.get(queryResultKey);
+        if (values != null) {
+            return values;
+        }
+
         Set<N> excludeElements = getExcludedNativeElements(result);
         Predicate<T> filter = element -> {
             if (excludeElements.contains(getNativeType(element))) {
@@ -153,19 +162,8 @@ public abstract class EnclosedElementsQuery<C, N> {
                 }
             }
             if (!result.getTypePredicates().isEmpty()) {
+                ClassElement ce = memberType(classElement, element);
                 for (Predicate<ClassElement> typePredicate : result.getTypePredicates()) {
-                    ClassElement ce;
-                    if (element instanceof ConstructorElement) {
-                        ce = classElement;
-                    } else if (element instanceof MethodElement methodElement) {
-                        ce = methodElement.getGenericReturnType();
-                    } else if (element instanceof ClassElement theClass) {
-                        ce = theClass;
-                    } else if (element instanceof FieldElement fieldElement) {
-                        ce = fieldElement.getGenericField();
-                    } else {
-                        throw new IllegalStateException("Unknown element: " + element);
-                    }
                     if (!typePredicate.test(ce)) {
                         return false;
                     }
@@ -173,11 +171,31 @@ public abstract class EnclosedElementsQuery<C, N> {
             }
             return true;
         };
-        Collection<T> allElements = getAllElements(getNativeClassType(classElement), result.isOnlyDeclared(), (t1, t2) -> reduceElements(t1, t2, result), result);
-        return allElements
-                .stream()
-                .filter(filter)
-                .toList();
+
+        C nativeClassType = getNativeClassType(classElement);
+        List<T> elements;
+        if (result.isOnlyDeclared() || classElement.getSuperType().isEmpty() && classElement.getInterfaces().isEmpty()) {
+            elements = getElements(nativeClassType, result, filter);
+        } else {
+            elements = getAllElements(nativeClassType, (t1, t2) -> reduceElements(t1, t2, result), result, filter);
+        }
+        resultsCache.put(queryResultKey, elements);
+        adjustMapCapacity(resultsCache, MAX_RESULTS);
+        return elements;
+    }
+
+    private <T extends Element> ClassElement memberType(ClassElement classElement, T element) {
+        if (element instanceof ConstructorElement) {
+            return classElement;
+        } else if (element instanceof MethodElement methodElement) {
+            return methodElement.getGenericReturnType();
+        } else if (element instanceof ClassElement theClass) {
+            return theClass;
+        } else if (element instanceof FieldElement fieldElement) {
+            return fieldElement.getGenericField();
+        } else {
+            throw new IllegalStateException("Unknown element: " + element);
+        }
     }
 
     private boolean reduceElements(io.micronaut.inject.ast.Element newElement,
@@ -203,76 +221,171 @@ public abstract class EnclosedElementsQuery<C, N> {
         return false;
     }
 
-    private <T extends io.micronaut.inject.ast.Element> Collection<T> getAllElements(C classNode,
-                                                                                     boolean onlyDeclared,
-                                                                                     BiPredicate<T, T> reduce,
-                                                                                     ElementQuery.Result<?> result) {
-        Set<T> elements = new LinkedHashSet<>();
-        List<List<N>> hierarchy = new ArrayList<>();
-        collectHierarchy(classNode, onlyDeclared, hierarchy, result);
-        for (List<N> classElements : hierarchy) {
-            Set<T> addedFromClassElements = new LinkedHashSet<>();
-            classElements:
-            for (N element : classElements) {
-                List<Predicate<String>> namePredicates = result.getNamePredicates();
-                if (!namePredicates.isEmpty()) {
-                    String elementName = getElementName(element);
-                    for (Predicate<String> namePredicate : namePredicates) {
-                        if (!namePredicate.test(elementName)) {
-                            continue classElements;
-                        }
-                    }
-                }
+    private <T extends io.micronaut.inject.ast.Element> List<T> getAllElements(C classNode,
+                                                                               BiPredicate<T, T> reduce,
+                                                                               ElementQuery.Result<?> result,
+                                                                               Predicate<T> filter) {
+
+        List<T> elements = new LinkedList<>();
+        List<T> addedFromClassElements = new ArrayList<>(20);
+        if (isInterface(classNode)) {
+            processInterfaceHierarchy(classNode, reduce, result, addedFromClassElements, elements, true);
+        } else {
+            boolean includeAbstract = isAbstractClass(classNode) || result.isIncludeOverriddenMethods();
+            processClassHierarchy(classNode, reduce, result, addedFromClassElements, elements, includeAbstract);
+        }
+        elements.removeIf(element -> !filter.test(element));
+        return elements;
+    }
+
+    private <T extends Element> void processClassHierarchy(C classNode,
+                                                           BiPredicate<T, T> reduce,
+                                                           ElementQuery.Result<?> result,
+                                                           List<T> addedFromClassElements,
+                                                           List<T> collectedElements,
+                                                           boolean includeAbstract) {
+        if (excludeClass(classNode)) {
+            return;
+        }
+        C superClass = getSuperClass(classNode);
+        if (superClass != null) {
+            processClassHierarchy(superClass, reduce, result, addedFromClassElements, collectedElements, includeAbstract);
+        }
+        reduce(collectedElements, getEnclosedElements(classNode, result, includeAbstract), reduce, result, addedFromClassElements, false, false);
+        for (C anInterface : getInterfaces(classNode)) {
+            processInterfaceHierarchy(anInterface, reduce, result, addedFromClassElements, collectedElements, includeAbstract);
+        }
+    }
+
+    private <T extends Element> void processInterfaceHierarchy(C classNode,
+                                                               BiPredicate<T, T> reduce,
+                                                               ElementQuery.Result<?> result,
+                                                               List<T> addedFromClassElements,
+                                                               Collection<T> collectedElements,
+                                                               boolean includeAbstract) {
+        if (excludeClass(classNode)) {
+            return;
+        }
+        for (C anInterface : getInterfaces(classNode)) {
+            processInterfaceHierarchy(anInterface, reduce, result, addedFromClassElements, collectedElements, includeAbstract);
+        }
+        reduce(collectedElements, getEnclosedElements(classNode, result, includeAbstract), reduce, result, addedFromClassElements, true, includeAbstract);
+    }
 
-                N nativeType = getCacheKey(element);
-                CacheKey cacheKey = new CacheKey(result.getElementType(), nativeType);
-                T newElement = (T) elementsCache.computeIfAbsent(cacheKey, ck -> toAstElement(nativeType, result.getElementType()));
-                if (result.getElementType() == MemberElement.class) {
-                    // Also cache members query results as it's original element type
-                    if (newElement instanceof FieldElement) {
-                        elementsCache.putIfAbsent(new CacheKey(FieldElement.class, nativeType), newElement);
-                    } else if (newElement instanceof ConstructorElement) {
-                        elementsCache.putIfAbsent(new CacheKey(ConstructorElement.class, nativeType), newElement);
-                        elementsCache.putIfAbsent(new CacheKey(MethodElement.class, nativeType), newElement);
-                    } else if (newElement instanceof MethodElement) {
-                        elementsCache.putIfAbsent(new CacheKey(MethodElement.class, nativeType), newElement);
-                    } else if (newElement instanceof PropertyElement) {
-                        elementsCache.putIfAbsent(new CacheKey(PropertyElement.class, nativeType), newElement);
+    private <T extends Element> void reduce(Collection<T> collectedElements,
+                                            List<N> classElements,
+                                            BiPredicate<T, T> reduce,
+                                            ElementQuery.Result<?> result,
+                                            List<T> addedFromClassElements,
+                                            boolean isInterface,
+                                            boolean includesAbstract) {
+        List<Predicate<String>> namePredicates = result.getNamePredicates();
+        boolean hasNamePredicates = !namePredicates.isEmpty();
+        addedFromClassElements.clear(); // Reusing this collection for all the calls
+        classElements:
+        for (N element : classElements) {
+            if (hasNamePredicates) {
+                String elementName = getElementName(element);
+                for (Predicate<String> namePredicate : namePredicates) {
+                    if (!namePredicate.test(elementName)) {
+                        continue classElements;
                     }
-                } else if (MemberElement.class.isAssignableFrom(result.getElementType())) {
-                    elementsCache.putIfAbsent(new CacheKey(MemberElement.class, nativeType), newElement);
                 }
-                if (elementsCache.size() == MAX_ITEMS_IN_CACHE) {
-                    Iterator<Map.Entry<CacheKey, Element>> iterator = elementsCache.entrySet().iterator();
-                    iterator.next();
-                    iterator.remove();
-                }
-                if (!result.getElementType().isInstance(newElement)) {
-                    // dirty cache
-                    elementsCache.remove(cacheKey);
-                    newElement = (T) elementsCache.computeIfAbsent(cacheKey, ck -> toAstElement(nativeType, result.getElementType()));
+            }
+            T newElement = convertElement(result, element);
+
+            for (Iterator<T> iterator = collectedElements.iterator(); iterator.hasNext(); ) {
+                T existingElement = iterator.next();
+                if (!existingElement.getName().equals(newElement.getName())) {
+                    continue;
                 }
-                for (Iterator<T> iterator = elements.iterator(); iterator.hasNext(); ) {
-                    T existingElement = iterator.next();
-                    if (newElement.equals(existingElement)) {
-                        continue;
+                if (isInterface) {
+                    if (existingElement == newElement) {
+                        continue classElements;
                     }
-                    if (reduce.test(newElement, existingElement)) {
+                    if (reduce.test(existingElement, newElement)) {
+                        continue classElements;
+                    } else if (includesAbstract && reduce.test(newElement, existingElement)) {
                         iterator.remove();
                         addedFromClassElements.add(newElement);
-                    } else if (reduce.test(existingElement, newElement)) {
                         continue classElements;
                     }
+                } else if (reduce.test(newElement, existingElement)) {
+                    iterator.remove();
+                    addedFromClassElements.add(newElement);
+                    continue classElements;
+                }
+
+            }
+            addedFromClassElements.add(newElement);
+        }
+        collectedElements.addAll(addedFromClassElements);
+    }
+
+    private <T extends io.micronaut.inject.ast.Element> List<T> getElements(C classNode,
+                                                                            ElementQuery.Result<?> result,
+                                                                            Predicate<T> filter) {
+        List<N> enclosedElements = getEnclosedElements(classNode, result, true);
+        List<T> elements = new ArrayList<>(enclosedElements.size());
+        List<Predicate<String>> namePredicates = result.getNamePredicates();
+        boolean hasNamePredicates = !namePredicates.isEmpty();
+        enclosedElementsLoop:
+        for (N enclosedElement : enclosedElements) {
+            if (hasNamePredicates) {
+                String elementName = getElementName(enclosedElement);
+                for (Predicate<String> namePredicate : namePredicates) {
+                    if (!namePredicate.test(elementName)) {
+                        continue enclosedElementsLoop;
+                    }
                 }
-                addedFromClassElements.add(newElement);
             }
-            elements.addAll(addedFromClassElements);
+            T element = convertElement(result, enclosedElement);
+            if (filter.test(element)) {
+                elements.add(element);
+            }
         }
         return elements;
     }
 
+    private <T extends Element> T convertElement(ElementQuery.Result<?> result, N element) {
+        N nativeType = getCacheKey(element);
+        CacheKey cacheKey = new CacheKey(result.getElementType(), nativeType);
+        T newElement = (T) elementsCache.computeIfAbsent(cacheKey, ck -> toAstElement(nativeType, result.getElementType()));
+        if (result.getElementType() == MemberElement.class) {
+            // Also cache members query results as it's original element type
+            if (newElement instanceof FieldElement) {
+                elementsCache.putIfAbsent(new CacheKey(FieldElement.class, nativeType), newElement);
+            } else if (newElement instanceof ConstructorElement) {
+                elementsCache.putIfAbsent(new CacheKey(ConstructorElement.class, nativeType), newElement);
+                elementsCache.putIfAbsent(new CacheKey(MethodElement.class, nativeType), newElement);
+            } else if (newElement instanceof MethodElement) {
+                elementsCache.putIfAbsent(new CacheKey(MethodElement.class, nativeType), newElement);
+            } else if (newElement instanceof PropertyElement) {
+                elementsCache.putIfAbsent(new CacheKey(PropertyElement.class, nativeType), newElement);
+            }
+        } else if (MemberElement.class.isAssignableFrom(result.getElementType())) {
+            elementsCache.putIfAbsent(new CacheKey(MemberElement.class, nativeType), newElement);
+        }
+        adjustMapCapacity(elementsCache, MAX_ITEMS_IN_CACHE);
+        if (!result.getElementType().isInstance(newElement)) {
+            // dirty cache
+            elementsCache.remove(cacheKey);
+            newElement = (T) elementsCache.computeIfAbsent(cacheKey, ck -> toAstElement(nativeType, result.getElementType()));
+        }
+        return newElement;
+    }
+
+    private void adjustMapCapacity(Map<?, ?> map, int size) {
+        if (map.size() == size) {
+            Iterator<?> iterator = map.entrySet().iterator();
+            iterator.next();
+            iterator.remove();
+        }
+    }
+
     /**
      * Gets the element name.
+     *
      * @param element The element
      * @return The name
      */
@@ -288,27 +401,6 @@ public abstract class EnclosedElementsQuery<C, N> {
         return element;
     }
 
-    private void collectHierarchy(C classNode,
-                                  boolean onlyDeclared,
-                                  List<List<N>> hierarchy,
-                                  ElementQuery.Result<?> result) {
-        if (excludeClass(classNode)) {
-            return;
-        }
-        if (!onlyDeclared) {
-            C superclass = getSuperClass(classNode);
-            if (superclass != null) {
-                collectHierarchy(superclass, false, hierarchy, result);
-            }
-            for (C interfaceNode : getInterfaces(classNode)) {
-                List<List<N>> interfaceElements = new ArrayList<>();
-                collectHierarchy(interfaceNode, false, interfaceElements, result);
-                hierarchy.addAll(interfaceElements);
-            }
-        }
-        hierarchy.add(getEnclosedElements(classNode, result));
-    }
-
     /**
      * Provides a collection of the native elements to exclude.
      *
@@ -337,6 +429,17 @@ public abstract class EnclosedElementsQuery<C, N> {
     @NonNull
     protected abstract Collection<C> getInterfaces(C classNode);
 
+    /**
+     * Extracts the enclosed elements of the class.
+     *
+     * @param classNode       The class
+     * @param result          The query result
+     * @param includeAbstract If abstract/non-default elements should be included
+     * @return The enclosed elements
+     */
+    @NonNull
+    protected abstract List<N> getEnclosedElements(C classNode, ElementQuery.Result<?> result, boolean includeAbstract);
+
     /**
      * Extracts the enclosed elements of the class.
      *
@@ -345,7 +448,9 @@ public abstract class EnclosedElementsQuery<C, N> {
      * @return The enclosed elements
      */
     @NonNull
-    protected abstract List<N> getEnclosedElements(C classNode, ElementQuery.Result<?> result);
+    protected List<N> getEnclosedElements(C classNode, ElementQuery.Result<?> result) {
+        return getEnclosedElements(classNode, result, true);
+    }
 
     /**
      * Checks if the class needs to be excluded.
@@ -355,11 +460,29 @@ public abstract class EnclosedElementsQuery<C, N> {
      */
     protected abstract boolean excludeClass(C classNode);
 
+    /**
+     * Is abstract class.
+     *
+     * @param classNode The class node
+     * @return true if abstract
+     * @since 4.3.0
+     */
+    protected abstract boolean isAbstractClass(C classNode);
+
+    /**
+     * Is interface.
+     *
+     * @param classNode The class node
+     * @return true if interface
+     * @since 4.3.0
+     */
+    protected abstract boolean isInterface(C classNode);
+
     /**
      * Converts the native element to the AST element.
      *
-     * @param nativeType The native element.
-     * @param elementType     The result type
+     * @param nativeType  The native element.
+     * @param elementType The result type
      * @return The AST element
      */
     @NonNull
@@ -367,4 +490,7 @@ public abstract class EnclosedElementsQuery<C, N> {
 
     private record CacheKey(Class<?> elementType, Object nativeType) {
     }
+
+    private record QueryResultKey(ElementQuery.Result<?> result, Object nativeType) {
+    }
 }
diff --git a/inject-groovy/src/main/groovy/io/micronaut/ast/groovy/visitor/GroovyClassElement.java b/inject-groovy/src/main/groovy/io/micronaut/ast/groovy/visitor/GroovyClassElement.java
index 5941eb650b..c3c7ebe09a 100644
--- a/inject-groovy/src/main/groovy/io/micronaut/ast/groovy/visitor/GroovyClassElement.java
+++ b/inject-groovy/src/main/groovy/io/micronaut/ast/groovy/visitor/GroovyClassElement.java
@@ -51,6 +51,7 @@ import io.micronaut.inject.ast.annotation.MutableAnnotationMetadataDelegate;
 import io.micronaut.inject.ast.utils.AstBeanPropertiesUtils;
 import io.micronaut.inject.ast.utils.EnclosedElementsQuery;
 import org.codehaus.groovy.ast.AnnotatedNode;
+import org.codehaus.groovy.ast.AnnotationNode;
 import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.ConstructorNode;
@@ -720,21 +721,25 @@ public class GroovyClassElement extends AbstractGroovyElement implements Arrayab
 
         @Override
         protected List<AnnotatedNode> getEnclosedElements(ClassNode classNode,
-                                                          ElementQuery.Result<?> result) {
+                                                          ElementQuery.Result<?> result,
+                                                          boolean includeAbstract) {
             Class<?> elementType = result.getElementType();
-            return getEnclosedElements(classNode, result, elementType);
+            return getEnclosedElements(classNode, result, elementType, includeAbstract);
         }
 
-        private List<AnnotatedNode> getEnclosedElements(ClassNode classNode, ElementQuery.Result<?> result, Class<?> elementType) {
+        private List<AnnotatedNode> getEnclosedElements(ClassNode classNode,
+                                                        ElementQuery.Result<?> result,
+                                                        Class<?> elementType,
+                                                        boolean includeAbstract) {
             if (elementType == MemberElement.class) {
                 return Stream.concat(
-                        getEnclosedElements(classNode, result, FieldElement.class).stream(),
-                        getEnclosedElements(classNode, result, MethodElement.class).stream()
+                        getEnclosedElements(classNode, result, FieldElement.class, includeAbstract).stream(),
+                        getEnclosedElements(classNode, result, MethodElement.class, includeAbstract).stream()
                 ).toList();
             } else if (elementType == MethodElement.class) {
                 return classNode.getMethods()
                         .stream()
-                        .filter(methodNode -> !JUNK_METHOD_FILTER.test(methodNode) && (methodNode.getModifiers() & Opcodes.ACC_SYNTHETIC) == 0)
+                        .filter(methodNode -> !JUNK_METHOD_FILTER.test(methodNode) && (methodNode.getModifiers() & Opcodes.ACC_SYNTHETIC) == 0 && (includeAbstract || isNonAbstract(classNode, methodNode)))
                         .<AnnotatedNode>map(m -> m)
                         .toList();
             } else if (elementType == FieldElement.class) {
@@ -761,6 +766,19 @@ public class GroovyClassElement extends AbstractGroovyElement implements Arrayab
             }
         }
 
+        private boolean isNonAbstract(ClassNode classNode, MethodNode methodNode) {
+            if (methodNode.isDefault()) {
+                return false;
+            }
+            if (methodNode.isPrivate() && classNode.isInterface()) {
+                return true;
+            }
+            if (!methodNode.isAbstract() && classNode.isInterface()) {
+                return false;
+            }
+            return !methodNode.isAbstract();
+        }
+
         @Override
         protected boolean excludeClass(ClassNode classNode) {
             String packageName = Objects.requireNonNullElse(classNode.getPackageName(), "");
@@ -775,6 +793,23 @@ public class GroovyClassElement extends AbstractGroovyElement implements Arrayab
                     || Script.class.getName().equals(className);
         }
 
+        @Override
+        protected boolean isAbstractClass(ClassNode classNode) {
+            return classNode.isAbstract();
+        }
+
+        @Override
+        protected boolean isInterface(ClassNode classNode) {
+            if (classNode.isInterface()) {
+                return true;
+            }
+            List<AnnotationNode> annotations = classNode.getAnnotations();
+            if (annotations != null) {
+                return annotations.stream().anyMatch(a -> a.getClassNode().getName().equals(groovy.transform.Trait.class.getName()));
+            }
+            return false;
+        }
+
         @Override
         protected Element toAstElement(AnnotatedNode nativeType, Class<?> elementType) {
             final GroovyElementFactory elementFactory = visitorContext.getElementFactory();
diff --git a/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaClassElement.java b/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaClassElement.java
index 602e011fd7..3c183b6632 100644
--- a/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaClassElement.java
+++ b/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaClassElement.java
@@ -103,6 +103,8 @@ public class JavaClassElement extends AbstractJavaElement implements ArrayableCl
     private Map<String, Map<String, ClassElement>> resolvedAllTypeArguments;
     @Nullable
     private ClassElement resolvedSuperType;
+    @Nullable
+    private List<ClassElement> resolvedInterfaces;
     private final JavaEnclosedElementsQuery enclosedElementsQuery = new JavaEnclosedElementsQuery(false);
     private final JavaEnclosedElementsQuery sourceEnclosedElementsQuery = new JavaEnclosedElementsQuery(true);
     @Nullable
@@ -256,7 +258,10 @@ public class JavaClassElement extends AbstractJavaElement implements ArrayableCl
 
     @Override
     public Collection<ClassElement> getInterfaces() {
-        return classElement.getInterfaces().stream().map(mirror -> newClassElement(mirror, getTypeArguments())).toList();
+        if (resolvedInterfaces == null) {
+            resolvedInterfaces = classElement.getInterfaces().stream().map(mirror -> newClassElement(mirror, getTypeArguments())).toList();
+        }
+        return resolvedInterfaces;
     }
 
     @Override
@@ -796,7 +801,7 @@ public class JavaClassElement extends AbstractJavaElement implements ArrayableCl
         }
 
         @Override
-        protected List<Element> getEnclosedElements(TypeElement classNode, ElementQuery.Result<?> result) {
+        protected List<Element> getEnclosedElements(TypeElement classNode, ElementQuery.Result<?> result, boolean includeAbstract) {
             List<? extends Element> ee;
             if (classNode == classElement) {
                 ee = getEnclosedElements();
@@ -804,7 +809,24 @@ public class JavaClassElement extends AbstractJavaElement implements ArrayableCl
                 ee = classNode.getEnclosedElements();
             }
             EnumSet<ElementKind> elementKinds = getElementKind(result);
-            return ee.stream().filter(element -> elementKinds.contains(element.getKind())).collect(Collectors.toList());
+            List<Element> list = new ArrayList<>(ee.size());
+            for (Element element : ee) {
+                Set<Modifier> modifiers = element.getModifiers();
+                if (elementKinds.contains(element.getKind()) && (includeAbstract || isNonAbstractMethod(modifiers))) {
+                    list.add(element);
+                }
+            }
+            return list;
+        }
+
+        private boolean isNonAbstractMethod(Set<Modifier> modifiers) {
+            if (modifiers.contains(Modifier.DEFAULT)) {
+                return true;
+            }
+            if (modifiers.contains(Modifier.PRIVATE)) {
+                return true;
+            }
+            return !modifiers.contains(Modifier.ABSTRACT);
         }
 
         @Override
@@ -813,6 +835,16 @@ public class JavaClassElement extends AbstractJavaElement implements ArrayableCl
                     || classNode.getQualifiedName().toString().equals(Enum.class.getName());
         }
 
+        @Override
+        protected boolean isAbstractClass(TypeElement classNode) {
+            return classNode.getModifiers().contains(Modifier.ABSTRACT);
+        }
+
+        @Override
+        protected boolean isInterface(TypeElement classNode) {
+            return classNode.getKind() == ElementKind.INTERFACE;
+        }
+
         @Override
         protected io.micronaut.inject.ast.Element toAstElement(Element nativeType, Class<?> elementType) {
             final JavaElementFactory elementFactory = visitorContext.getElementFactory();
@@ -892,4 +924,4 @@ public class JavaClassElement extends AbstractJavaElement implements ArrayableCl
 
     }
 
-}
\ No newline at end of file
+}
diff --git a/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/visitor/KotlinClassElement.kt b/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/visitor/KotlinClassElement.kt
index 199af8adf7..6d10821c8f 100644
--- a/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/visitor/KotlinClassElement.kt
+++ b/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/visitor/KotlinClassElement.kt
@@ -700,22 +700,24 @@ internal open class KotlinClassElement(
 
         override fun getEnclosedElements(
             classNode: KSClassDeclaration,
-            result: ElementQuery.Result<*>
+            result: ElementQuery.Result<*>,
+            includeAbstract: Boolean
         ): List<KSNode> {
             val elementType: Class<*> = result.elementType
-            return getEnclosedElements(classNode, result, elementType)
+            return getEnclosedElements(classNode, result, elementType, includeAbstract)
         }
 
         private fun getEnclosedElements(
             classNode: KSClassDeclaration,
             result: ElementQuery.Result<*>,
-            elementType: Class<*>
+            elementType: Class<*>,
+            includeAbstract: Boolean
         ): List<KSNode> {
             return when (elementType) {
                 MemberElement::class.java -> {
                     Stream.concat(
-                        getEnclosedElements(classNode, result, FieldElement::class.java).stream(),
-                        getEnclosedElements(classNode, result, MethodElement::class.java).stream()
+                        getEnclosedElements(classNode, result, FieldElement::class.java, includeAbstract).stream(),
+                        getEnclosedElements(classNode, result, MethodElement::class.java, includeAbstract).stream()
                     ).toList()
                 }
 
@@ -729,7 +731,7 @@ internal open class KotlinClassElement(
                                         "hashCode",
                                         "toString",
                                         "equals"
-                                    ).contains(func.simpleName.asString())
+                                    ).contains(func.simpleName.asString()) && (includeAbstract || !func.isAbstract || !classNode.isAbstract())
                         }
                         .toList()
                 }
@@ -772,6 +774,10 @@ internal open class KotlinClassElement(
                     classNode.qualifiedName.toString() == Enum::class.java.name
         }
 
+        override fun isAbstractClass(classNode: KSClassDeclaration) = classNode.isAbstract()
+
+        override fun isInterface(classNode: KSClassDeclaration) = classNode.classKind == ClassKind.INTERFACE
+
         override fun toAstElement(
             nativeType: KSNode,
             elementType: Class<*>
