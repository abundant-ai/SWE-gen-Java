diff --git a/src/main/java/org/mockito/internal/verification/Calls.java b/src/main/java/org/mockito/internal/verification/Calls.java
index 3d9bc84fa..e7e7eeef0 100644
--- a/src/main/java/org/mockito/internal/verification/Calls.java
+++ b/src/main/java/org/mockito/internal/verification/Calls.java
@@ -5,18 +5,20 @@
 
 package org.mockito.internal.verification;
 
-import static org.mockito.internal.verification.checkers.MissingInvocationChecker.checkMissingInvocation;
-import static org.mockito.internal.verification.checkers.NumberOfInvocationsChecker.checkNumberOfInvocationsNonGreedy;
-
-import java.util.List;
 import org.mockito.exceptions.base.MockitoException;
+import org.mockito.internal.invocation.InvocationMatcher;
+import org.mockito.invocation.MatchableInvocation;
 import org.mockito.internal.verification.api.VerificationData;
 import org.mockito.internal.verification.api.VerificationDataInOrder;
 import org.mockito.internal.verification.api.VerificationInOrderMode;
 import org.mockito.invocation.Invocation;
-import org.mockito.invocation.MatchableInvocation;
 import org.mockito.verification.VerificationMode;
 
+import static org.mockito.internal.verification.checkers.NonGreedyNumberOfInvocationsInOrderChecker.check;
+import static org.mockito.internal.verification.checkers.MissingInvocationChecker.checkMissingInvocation;
+
+import java.util.List;
+
 public class Calls implements VerificationMode, VerificationInOrderMode {
 
     final int wantedCount;
@@ -28,18 +30,16 @@ public class Calls implements VerificationMode, VerificationInOrderMode {
         this.wantedCount = wantedNumberOfInvocations;
     }
 
-    @Override
     public void verify(VerificationData data) {
         throw new MockitoException( "calls is only intended to work with InOrder" );
     }
 
-    @Override
     public void verifyInOrder(VerificationDataInOrder data) {
         List<Invocation> allInvocations = data.getAllInvocations();
         MatchableInvocation wanted = data.getWanted();
 
         checkMissingInvocation(allInvocations, wanted,  data.getOrderingContext());
-        checkNumberOfInvocationsNonGreedy(allInvocations, wanted, wantedCount, data.getOrderingContext());
+        check( allInvocations, wanted, wantedCount, data.getOrderingContext());
     }    
     
     @Override
diff --git a/src/main/java/org/mockito/internal/verification/Times.java b/src/main/java/org/mockito/internal/verification/Times.java
index d2895c544..5dbf0f444 100644
--- a/src/main/java/org/mockito/internal/verification/Times.java
+++ b/src/main/java/org/mockito/internal/verification/Times.java
@@ -6,14 +6,16 @@
 package org.mockito.internal.verification;
 
 import static org.mockito.internal.verification.checkers.MissingInvocationChecker.checkMissingInvocation;
-import static org.mockito.internal.verification.checkers.NumberOfInvocationsChecker.checkNumberOfInvocations;
 
 import java.util.List;
 import org.mockito.exceptions.base.MockitoException;
+import org.mockito.internal.invocation.InvocationMatcher;
 import org.mockito.invocation.MatchableInvocation;
 import org.mockito.internal.verification.api.VerificationData;
 import org.mockito.internal.verification.api.VerificationDataInOrder;
 import org.mockito.internal.verification.api.VerificationInOrderMode;
+import org.mockito.internal.verification.checkers.NumberOfInvocationsChecker;
+import org.mockito.internal.verification.checkers.NumberOfInvocationsInOrderChecker;
 import org.mockito.invocation.Invocation;
 import org.mockito.verification.VerificationMode;
 
@@ -28,7 +30,6 @@ public class Times implements VerificationInOrderMode, VerificationMode {
         this.wantedCount = wantedNumberOfInvocations;
     }
     
-    @Override
     public void verify(VerificationData data) {
         List<Invocation> invocations = data.getAllInvocations();
         MatchableInvocation wanted = data.getTarget();
@@ -36,10 +37,10 @@ public class Times implements VerificationInOrderMode, VerificationMode {
         if (wantedCount > 0) {
              checkMissingInvocation(data.getAllInvocations(), data.getTarget());
         }
-        checkNumberOfInvocations(invocations, wanted, wantedCount);
+        NumberOfInvocationsChecker numberOfInvocations = new NumberOfInvocationsChecker();
+        numberOfInvocations.check(invocations, wanted, wantedCount);
     }
     
-    @Override
     public void verifyInOrder(VerificationDataInOrder data) {
         List<Invocation> allInvocations = data.getAllInvocations();
         MatchableInvocation wanted = data.getWanted();
@@ -47,7 +48,8 @@ public class Times implements VerificationInOrderMode, VerificationMode {
         if (wantedCount > 0) {
             checkMissingInvocation(allInvocations, wanted, data.getOrderingContext());
         }
-        checkNumberOfInvocations(allInvocations, wanted, wantedCount, data.getOrderingContext());
+        NumberOfInvocationsInOrderChecker numberOfCalls = new NumberOfInvocationsInOrderChecker();
+        numberOfCalls.check(allInvocations, wanted, wantedCount, data.getOrderingContext());
     }    
     
     @Override
diff --git a/src/main/java/org/mockito/internal/verification/checkers/NonGreedyNumberOfInvocationsInOrderChecker.java b/src/main/java/org/mockito/internal/verification/checkers/NonGreedyNumberOfInvocationsInOrderChecker.java
new file mode 100644
index 000000000..3bccd0a39
--- /dev/null
+++ b/src/main/java/org/mockito/internal/verification/checkers/NonGreedyNumberOfInvocationsInOrderChecker.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2007 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+
+package org.mockito.internal.verification.checkers;
+
+import static org.mockito.internal.exceptions.Reporter.tooLittleActualInvocationsInOrder;
+import static org.mockito.internal.invocation.InvocationMarker.markVerified;
+import static org.mockito.internal.invocation.InvocationsFinder.findFirstMatchingUnverifiedInvocation;
+
+import java.util.List;
+
+import org.mockito.internal.invocation.InvocationMatcher;
+import org.mockito.internal.reporting.Discrepancy;
+import org.mockito.internal.verification.api.InOrderContext;
+import org.mockito.invocation.Invocation;
+import org.mockito.invocation.Location;
+import org.mockito.invocation.MatchableInvocation;
+
+public class NonGreedyNumberOfInvocationsInOrderChecker {
+
+    private NonGreedyNumberOfInvocationsInOrderChecker() {}
+
+    public static void check(List<Invocation> invocations, MatchableInvocation wanted, int wantedCount, InOrderContext context) {
+        int actualCount = 0;
+        Location lastLocation = null;
+        while( actualCount < wantedCount ){
+            Invocation next = findFirstMatchingUnverifiedInvocation(invocations, wanted, context );
+            if( next == null ){
+                throw tooLittleActualInvocationsInOrder(new Discrepancy(wantedCount, actualCount), wanted, lastLocation );
+            }
+            markVerified( next, wanted );
+            context.markVerified( next );
+            lastLocation = next.getLocation();
+            actualCount++;
+        }
+    }
+}
diff --git a/src/main/java/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java b/src/main/java/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java
index 531f4779c..938f8ffd3 100644
--- a/src/main/java/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java
+++ b/src/main/java/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java
@@ -7,29 +7,20 @@ package org.mockito.internal.verification.checkers;
 
 import java.util.List;
 import org.mockito.internal.reporting.Discrepancy;
-import org.mockito.internal.verification.api.InOrderContext;
 import org.mockito.invocation.Invocation;
 import org.mockito.invocation.Location;
 import org.mockito.invocation.MatchableInvocation;
 
 import static org.mockito.internal.exceptions.Reporter.neverWantedButInvoked;
 import static org.mockito.internal.exceptions.Reporter.tooLittleActualInvocations;
-import static org.mockito.internal.exceptions.Reporter.tooLittleActualInvocationsInOrder;
 import static org.mockito.internal.exceptions.Reporter.tooManyActualInvocations;
-import static org.mockito.internal.exceptions.Reporter.tooManyActualInvocationsInOrder;
 import static org.mockito.internal.invocation.InvocationMarker.markVerified;
-import static org.mockito.internal.invocation.InvocationMarker.markVerifiedInOrder;
-import static org.mockito.internal.invocation.InvocationsFinder.findFirstMatchingUnverifiedInvocation;
 import static org.mockito.internal.invocation.InvocationsFinder.findInvocations;
-import static org.mockito.internal.invocation.InvocationsFinder.findMatchingChunk;
 import static org.mockito.internal.invocation.InvocationsFinder.getLastLocation;
 
 public class NumberOfInvocationsChecker {
-    
-    private NumberOfInvocationsChecker() {
-    }
 
-    public static void checkNumberOfInvocations(List<Invocation> invocations, MatchableInvocation wanted, int wantedCount) {
+    public void check(List<Invocation> invocations, MatchableInvocation wanted, int wantedCount) {
         List<Invocation> actualInvocations = findInvocations(invocations, wanted);
         
         int actualCount = actualInvocations.size();
@@ -48,36 +39,4 @@ public class NumberOfInvocationsChecker {
 
         markVerified(actualInvocations, wanted);
     }
-    
-    public static void checkNumberOfInvocations(List<Invocation> invocations, MatchableInvocation wanted, int wantedCount, InOrderContext context) {
-        List<Invocation> chunk = findMatchingChunk(invocations, wanted, wantedCount, context);
-        
-        int actualCount = chunk.size();
-        
-        if (wantedCount > actualCount) {
-            Location lastInvocation = getLastLocation(chunk);
-            throw tooLittleActualInvocationsInOrder(new Discrepancy(wantedCount, actualCount), wanted, lastInvocation);
-        } 
-        if (wantedCount < actualCount) {
-            Location firstUndesired = chunk.get(wantedCount).getLocation();
-            throw tooManyActualInvocationsInOrder(wantedCount, actualCount, wanted, firstUndesired);
-        }
-        
-        markVerifiedInOrder(chunk, wanted, context);
-    }
-    
-    public static void checkNumberOfInvocationsNonGreedy(List<Invocation> invocations, MatchableInvocation wanted, int wantedCount, InOrderContext context) {
-        int actualCount = 0;
-        Location lastLocation = null;
-        while( actualCount < wantedCount ){
-            Invocation next = findFirstMatchingUnverifiedInvocation(invocations, wanted, context );
-            if( next == null ){
-                throw tooLittleActualInvocationsInOrder(new Discrepancy(wantedCount, actualCount), wanted, lastLocation );
-            }
-            markVerified( next, wanted );
-            context.markVerified( next );
-            lastLocation = next.getLocation();
-            actualCount++;
-        }
-    }
 }
diff --git a/src/main/java/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java b/src/main/java/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java
new file mode 100644
index 000000000..0445b383e
--- /dev/null
+++ b/src/main/java/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2007 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+
+package org.mockito.internal.verification.checkers;
+
+import static org.mockito.internal.exceptions.Reporter.tooLittleActualInvocationsInOrder;
+import static org.mockito.internal.exceptions.Reporter.tooManyActualInvocationsInOrder;
+import static org.mockito.internal.invocation.InvocationMarker.markVerifiedInOrder;
+import static org.mockito.internal.invocation.InvocationsFinder.findMatchingChunk;
+import static org.mockito.internal.invocation.InvocationsFinder.getLastLocation;
+
+import java.util.List;
+
+import org.mockito.internal.invocation.InvocationMatcher;
+import org.mockito.internal.reporting.Discrepancy;
+import org.mockito.internal.verification.api.InOrderContext;
+import org.mockito.invocation.Invocation;
+import org.mockito.invocation.Location;
+import org.mockito.invocation.MatchableInvocation;
+
+public class NumberOfInvocationsInOrderChecker {
+  
+    public void check(List<Invocation> invocations, MatchableInvocation wanted, int wantedCount, InOrderContext context) {
+        List<Invocation> chunk = findMatchingChunk(invocations, wanted, wantedCount, context);
+        
+        int actualCount = chunk.size();
+        
+        if (wantedCount > actualCount) {
+            Location lastInvocation = getLastLocation(chunk);
+            throw tooLittleActualInvocationsInOrder(new Discrepancy(wantedCount, actualCount), wanted, lastInvocation);
+        } 
+        if (wantedCount < actualCount) {
+            Location firstUndesired = chunk.get(wantedCount).getLocation();
+            throw tooManyActualInvocationsInOrder(wantedCount, actualCount, wanted, firstUndesired);
+        }
+        
+        markVerifiedInOrder(chunk, wanted, context);
+    }
+}
diff --git a/src/test/java/org/mockito/internal/verification/checkers/NumberOfInvocationsCheckerTest.java b/src/test/java/org/mockito/internal/verification/checkers/NumberOfInvocationsCheckerTest.java
index af9d3cb80..d692fac57 100644
--- a/src/test/java/org/mockito/internal/verification/checkers/NumberOfInvocationsCheckerTest.java
+++ b/src/test/java/org/mockito/internal/verification/checkers/NumberOfInvocationsCheckerTest.java
@@ -5,14 +5,10 @@
 
 package org.mockito.internal.verification.checkers;
 
-import static java.util.Arrays.asList;
-import static java.util.Collections.emptyList;
-import static org.assertj.core.api.Assertions.assertThat;
-
-import java.util.List;
 import org.hamcrest.BaseMatcher;
 import org.hamcrest.Description;
 import org.hamcrest.TypeSafeMatcher;
+import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
@@ -28,9 +24,17 @@ import org.mockito.invocation.Invocation;
 import org.mockito.junit.MockitoJUnitRunner;
 import org.mockitousage.IMethods;
 
+import java.util.List;
+
+import static java.util.Arrays.asList;
+import static java.util.Collections.emptyList;
+import static org.assertj.core.api.Assertions.assertThat;
+
 @RunWith(MockitoJUnitRunner.class)
 public class NumberOfInvocationsCheckerTest {
 
+    private NumberOfInvocationsChecker checker;
+
     private InvocationMatcher wanted;
 
     private List<Invocation> invocations;
@@ -44,6 +48,12 @@ public class NumberOfInvocationsCheckerTest {
     @Rule
     public TestName testName = new TestName();
 
+    @Before
+    public void setup() {
+        checker = new NumberOfInvocationsChecker();
+
+    }
+
     @Test
     public void shouldReportTooLittleActual() throws Exception {
         wanted = buildSimpleMethod().toInvocationMatcher();
@@ -54,7 +64,7 @@ public class NumberOfInvocationsCheckerTest {
         exception.expectMessage("Wanted 100 times");
         exception.expectMessage("But was 2 times");
 
-        NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100);
+        checker.check(invocations, wanted, 100);
     }
 
     @Test
@@ -68,7 +78,7 @@ public class NumberOfInvocationsCheckerTest {
         exception.expectMessage("But was 2 times");
         exception.expectMessage(containsTimes("-> at", 2));
 
-        NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100);
+        checker.check(invocations, wanted, 100);
     }
 
     @Test
@@ -82,7 +92,7 @@ public class NumberOfInvocationsCheckerTest {
         exception.expectMessage("But was 0 times");
         exception.expectMessage(containsTimes("-> at", 1));
 
-        NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100);
+        checker.check(invocations, wanted, 100);
     }
 
     @Test
@@ -96,7 +106,7 @@ public class NumberOfInvocationsCheckerTest {
 
         exception.expect(TooManyActualInvocations.class);
         exception.expectMessage("" + third.getLocation());
-        NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 2);
+        checker.check(invocations, wanted, 2);
     }
 
     @Test
@@ -110,7 +120,7 @@ public class NumberOfInvocationsCheckerTest {
         exception.expectMessage("Wanted 1 time");
         exception.expectMessage("But was 2 times");
 
-        NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1);
+        checker.check(invocations, wanted, 1);
     }
 
     @Test
@@ -125,7 +135,7 @@ public class NumberOfInvocationsCheckerTest {
         exception.expectMessage("But invoked here");
         exception.expectMessage("" + first.getLocation());
 
-        NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 0);
+        checker.check(invocations, wanted, 0);
     }
 
 	@Test
@@ -135,7 +145,7 @@ public class NumberOfInvocationsCheckerTest {
 
 		invocations = asList(invocation);
 		wanted = buildSimpleMethod().toInvocationMatcher();
-		NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1);
+		checker.check(invocations, wanted, 1);
 		assertThat(invocation.isVerified()).isTrue();
 	}
 
diff --git a/src/test/java/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderCheckerTest.java b/src/test/java/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderCheckerTest.java
index 2e7203323..4b1784125 100644
--- a/src/test/java/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderCheckerTest.java
+++ b/src/test/java/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderCheckerTest.java
@@ -12,6 +12,7 @@ import static org.mockito.Mockito.mock;
 
 import java.util.List;
 
+import org.assertj.core.api.Assertions;
 import org.hamcrest.BaseMatcher;
 import org.hamcrest.Description;
 import org.hamcrest.TypeSafeMatcher;
@@ -29,6 +30,7 @@ import org.mockitousage.IMethods;
 
 public class NumberOfInvocationsInOrderCheckerTest {
 
+    private NumberOfInvocationsInOrderChecker checker;
     private InvocationMatcher wanted;
     private List<Invocation> invocations;
     private InOrderContext context;
@@ -40,6 +42,7 @@ public class NumberOfInvocationsInOrderCheckerTest {
 
     @Before
     public void setup() {
+        checker = new NumberOfInvocationsInOrderChecker();
         context = new InOrderContextImpl();
         mock = mock(IMethods.class, "mock");
 
@@ -50,14 +53,14 @@ public class NumberOfInvocationsInOrderCheckerTest {
         wanted = buildSimpleMethod().toInvocationMatcher();
         invocations = emptyList();
 
-        NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 0, context);
+        checker.check(invocations, wanted, 0, context);
     }
 
     @Test
     public void shouldPassIfChunkMatches() throws Exception {
         wanted = buildSimpleMethod().toInvocationMatcher();
         invocations = asList(buildSimpleMethod().toInvocation());
-        NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1, context);
+        checker.check(invocations, wanted, 1, context);
     }
 
     @Test
@@ -73,7 +76,7 @@ public class NumberOfInvocationsInOrderCheckerTest {
         exception.expectMessage("Wanted 4 times");
         exception.expectMessage("But was 2 times");
 
-        NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 4, context);
+        checker.check(invocations, wanted, 4, context);
     }
 
     @Test
@@ -84,7 +87,7 @@ public class NumberOfInvocationsInOrderCheckerTest {
         wanted = buildSimpleMethod().toInvocationMatcher();
 
         assertThat(context.isVerified(invocation)).isFalse();
-        NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1, context);
+        checker.check(invocations, wanted, 1, context);
         assertThat(context.isVerified(invocation)).isTrue();
     }
 
@@ -98,7 +101,7 @@ public class NumberOfInvocationsInOrderCheckerTest {
         exception.expectMessage("Wanted 100 times");
         exception.expectMessage("But was 2 times");
 
-        NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100, context);
+        checker.check(invocations, wanted, 100, context);
     }
 
     @Test
@@ -112,7 +115,7 @@ public class NumberOfInvocationsInOrderCheckerTest {
         exception.expectMessage("But was 2 times");
         exception.expectMessage(containsTimes("-> at", 2));
 
-        NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100, context);
+        checker.check(invocations, wanted, 100, context);
 
     }
 
@@ -127,7 +130,7 @@ public class NumberOfInvocationsInOrderCheckerTest {
         exception.expectMessage("But was 0 times");
         exception.expectMessage(containsTimes("-> at", 1));
 
-        NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 100, context);
+        checker.check(invocations, wanted, 100, context);
     }
 
     @Test
@@ -141,7 +144,7 @@ public class NumberOfInvocationsInOrderCheckerTest {
 
         exception.expect(VerificationInOrderFailure.class);
         exception.expectMessage("" + third.getLocation());
-        NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 2, context);
+        checker.check(invocations, wanted, 2, context);
     }
 
     @Test
@@ -155,7 +158,7 @@ public class NumberOfInvocationsInOrderCheckerTest {
         exception.expectMessage("Wanted 1 time");
         exception.expectMessage("But was 2 times");
 
-        NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1, context);
+        checker.check(invocations, wanted, 1, context);
     }
 
     @Test
@@ -171,17 +174,17 @@ public class NumberOfInvocationsInOrderCheckerTest {
         exception.expectMessage("But was 1 time. Undesired invocation");
         exception.expectMessage("" + first.getLocation());
 
-        NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 0, context);
+        checker.check(invocations, wanted, 0, context);
     }
 
     @Test
     public void shouldMarkInvocationsAsVerified() throws Exception {
         Invocation invocation = buildSimpleMethod().toInvocation();
-        assertThat(invocation.isVerified()).isFalse();
+        Assertions.assertThat(invocation.isVerified()).isFalse();
 
         invocations = asList(invocation);
         wanted = buildSimpleMethod().toInvocationMatcher();
-        NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 1, context);
+        checker.check(invocations, wanted, 1, context);
         assertThat(invocation.isVerified()).isTrue();
     }
 
@@ -200,7 +203,6 @@ public class NumberOfInvocationsInOrderCheckerTest {
             this.amount = amount;
         }
 
-        @Override
         public boolean matchesSafely(String text) {
             int lastIndex = 0;
             int count = 0;
@@ -214,7 +216,6 @@ public class NumberOfInvocationsInOrderCheckerTest {
             return count == amount;
         }
 
-        @Override
         public void describeTo(Description description) {
             description.appendText("containing '" + expected + "' exactly " + amount + " times");
         }
