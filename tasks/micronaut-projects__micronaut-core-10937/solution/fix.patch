diff --git a/http-client-core/src/main/java/io/micronaut/http/client/HttpClientConfiguration.java b/http-client-core/src/main/java/io/micronaut/http/client/HttpClientConfiguration.java
index 87dc407a52..377a8dfc1e 100644
--- a/http-client-core/src/main/java/io/micronaut/http/client/HttpClientConfiguration.java
+++ b/http-client-core/src/main/java/io/micronaut/http/client/HttpClientConfiguration.java
@@ -106,6 +106,12 @@ public abstract class HttpClientConfiguration {
     @SuppressWarnings("WeakerAccess")
     public static final boolean DEFAULT_ALLOW_BLOCK_EVENT_LOOP = false;
 
+    /**
+     * The default value.
+     */
+    @SuppressWarnings("WeakerAccess")
+    public static final DnsResolutionMode DEFAULT_DNS_RESOLUTION_MODE = DnsResolutionMode.DEFAULT;
+
     private Map<String, Object> channelOptions = Collections.emptyMap();
 
     private Integer numOfThreads = null;
@@ -168,6 +174,11 @@ public abstract class HttpClientConfiguration {
 
     private boolean allowBlockEventLoop = DEFAULT_ALLOW_BLOCK_EVENT_LOOP;
 
+    private DnsResolutionMode dnsResolutionMode = DEFAULT_DNS_RESOLUTION_MODE;
+
+    @Nullable
+    private String addressResolverGroupName = null;
+
     /**
      * Default constructor.
      */
@@ -777,6 +788,51 @@ public abstract class HttpClientConfiguration {
         this.allowBlockEventLoop = allowBlockEventLoop;
     }
 
+    /**
+     * Configure how DNS records are resolved. Ignored if {@link #getAddressResolverGroupName()} is
+     * non-null. This option is specific to the netty client.
+     *
+     * @return The DNS resolution mode
+     * @since 4.6.0
+     */
+    @NonNull
+    public DnsResolutionMode getDnsResolutionMode() {
+        return dnsResolutionMode;
+    }
+
+    /**
+     * Configure how DNS records are resolved. Ignored if {@link #getAddressResolverGroupName()} is
+     * non-null. This option is specific to the netty client.
+     *
+     * @param dnsResolutionMode The DNS resolution mode
+     * @since 4.6.0
+     */
+    public void setDnsResolutionMode(@NonNull DnsResolutionMode dnsResolutionMode) {
+        this.dnsResolutionMode = dnsResolutionMode;
+    }
+
+    /**
+     * Name of a fixed netty AddressResolverGroup to use for this client, or {@code null} to
+     * instead use {@link #getDnsResolutionMode()}. This option is specific to the netty client.
+     *
+     * @return The bean name of the resolver group
+     * @since 4.6.0
+     */
+    public @Nullable String getAddressResolverGroupName() {
+        return addressResolverGroupName;
+    }
+
+    /**
+     * Name of a fixed netty AddressResolverGroup to use for this client, or {@code null} to
+     * instead use {@link #getDnsResolutionMode()}. This option is specific to the netty client.
+     *
+     * @param addressResolverGroupName The bean name of the resolver group
+     * @since 4.6.0
+     */
+    public void setAddressResolverGroupName(@Nullable String addressResolverGroupName) {
+        this.addressResolverGroupName = addressResolverGroupName;
+    }
+
     /**
      * Configuration for the HTTP client connnection pool.
      */
@@ -982,4 +1038,25 @@ public abstract class HttpClientConfiguration {
             this.enabled = enabled;
         }
     }
+
+    /**
+     * The DNS resolution mode.
+     *
+     * @since 4.6.0
+     */
+    public enum DnsResolutionMode {
+        /**
+         * Default netty resolution implementation. Addresses are resolved before connecting.
+         */
+        DEFAULT,
+        /**
+         * No-op resolution implementation. Addresses are resolved internally by the JDK during
+         * connection.
+         */
+        NOOP,
+        /**
+         * Pick a random resolved record for each connection.
+         */
+        ROUND_ROBIN,
+    }
 }
diff --git a/http-client/src/main/java/io/micronaut/http/client/netty/ConnectionManager.java b/http-client/src/main/java/io/micronaut/http/client/netty/ConnectionManager.java
index 75090391ce..3ce8414dd8 100644
--- a/http-client/src/main/java/io/micronaut/http/client/netty/ConnectionManager.java
+++ b/http-client/src/main/java/io/micronaut/http/client/netty/ConnectionManager.java
@@ -55,6 +55,7 @@ import io.netty.handler.codec.http.HttpHeaderNames;
 import io.netty.handler.codec.http.HttpMethod;
 import io.netty.handler.codec.http.HttpObjectAggregator;
 import io.netty.handler.codec.http.HttpScheme;
+import io.netty.handler.codec.http.HttpVersion;
 import io.netty.handler.codec.http.websocketx.extensions.compression.WebSocketClientCompressionHandler;
 import io.netty.handler.codec.http2.Http2ClientUpgradeCodec;
 import io.netty.handler.codec.http2.Http2FrameCodec;
@@ -69,6 +70,7 @@ import io.netty.handler.codec.http2.Http2SettingsFrame;
 import io.netty.handler.codec.http2.Http2StreamChannel;
 import io.netty.handler.codec.http2.Http2StreamChannelBootstrap;
 import io.netty.handler.codec.http2.Http2StreamFrameToHttpObjectCodec;
+import io.netty.handler.logging.LogLevel;
 import io.netty.handler.logging.LoggingHandler;
 import io.netty.handler.proxy.HttpProxyHandler;
 import io.netty.handler.proxy.Socks5ProxyHandler;
@@ -89,11 +91,18 @@ import io.netty.incubator.codec.http3.Http3SettingsFrame;
 import io.netty.incubator.codec.quic.QuicChannel;
 import io.netty.incubator.codec.quic.QuicSslContext;
 import io.netty.incubator.codec.quic.QuicStreamChannel;
+import io.netty.resolver.AddressResolver;
+import io.netty.resolver.AddressResolverGroup;
+import io.netty.resolver.DefaultAddressResolverGroup;
+import io.netty.resolver.DefaultNameResolver;
+import io.netty.resolver.InetSocketAddressResolver;
 import io.netty.resolver.NoopAddressResolverGroup;
+import io.netty.resolver.RoundRobinInetAddressResolver;
 import io.netty.util.ReferenceCountUtil;
 import io.netty.util.ResourceLeakDetector;
 import io.netty.util.ResourceLeakDetectorFactory;
 import io.netty.util.ResourceLeakTracker;
+import io.netty.util.concurrent.EventExecutor;
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.GenericFutureListener;
 import io.netty.util.concurrent.ScheduledFuture;
@@ -134,9 +143,12 @@ public class ConnectionManager {
     private final Logger log;
     private final Map<DefaultHttpClient.RequestKey, Pool> pools = new ConcurrentHashMap<>();
     private final ClientSslBuilder nettyClientSslBuilder;
+
     private EventLoopGroup group;
     private final boolean shutdownGroup;
 
+    private final AddressResolverGroup<?> resolverGroup;
+
     private final AtomicBoolean running = new AtomicBoolean(false);
     private final ThreadFactory threadFactory;
     private final ChannelFactory<? extends Channel> socketChannelFactory;
@@ -160,6 +172,7 @@ public class ConnectionManager {
         this.log = from.log;
         this.group = from.group;
         this.shutdownGroup = from.shutdownGroup;
+        this.resolverGroup = from.resolverGroup;
         this.threadFactory = from.threadFactory;
         this.socketChannelFactory = from.socketChannelFactory;
         this.udpChannelFactory = from.udpChannelFactory;
@@ -184,7 +197,8 @@ public class ConnectionManager {
         ChannelFactory<? extends Channel> udpChannelFactory,
         ClientSslBuilder nettyClientSslBuilder,
         NettyClientCustomizer clientCustomizer,
-        String informationalServiceId) {
+        String informationalServiceId,
+        @Nullable AddressResolverGroup<?> resolverGroup) {
 
         if (httpVersion == null) {
             httpVersion = HttpVersionSelection.forClientConfiguration(configuration);
@@ -208,6 +222,7 @@ public class ConnectionManager {
             shutdownGroup = true;
         }
 
+        this.resolverGroup = resolverGroup == null ? getResolver(configuration.getDnsResolutionMode()) : resolverGroup;
 
         refresh();
     }
@@ -352,6 +367,21 @@ public class ConnectionManager {
                 bootstrap.option(ChannelOption.valueOf(channelOption), v);
             }
         }
+
+        bootstrap.resolver(resolverGroup);
+    }
+
+    static @NonNull AddressResolverGroup<? extends SocketAddress> getResolver(HttpClientConfiguration.@NonNull DnsResolutionMode mode) {
+        return switch (mode) {
+            case DEFAULT -> DefaultAddressResolverGroup.INSTANCE;
+            case NOOP -> NoopAddressResolverGroup.INSTANCE;
+            case ROUND_ROBIN -> new AddressResolverGroup<InetSocketAddress>() {
+                @Override
+                protected AddressResolver<InetSocketAddress> newResolver(EventExecutor executor) {
+                    return new InetSocketAddressResolver(executor, new RoundRobinInetAddressResolver(executor, new DefaultNameResolver(executor)));
+                }
+            };
+        };
     }
 
     /**
@@ -383,6 +413,7 @@ public class ConnectionManager {
             }
             ReferenceCountUtil.release(sslContext);
             ReferenceCountUtil.release(websocketSslContext);
+            resolverGroup.close();
             sslContext = null;
             websocketSslContext = null;
         }
@@ -588,8 +619,8 @@ public class ConnectionManager {
         Http2FrameCodecBuilder builder = Http2FrameCodecBuilder.forClient();
         configuration.getLogLevel().ifPresent(logLevel -> {
             try {
-                final io.netty.handler.logging.LogLevel nettyLevel =
-                    io.netty.handler.logging.LogLevel.valueOf(logLevel.name());
+                final LogLevel nettyLevel =
+                    LogLevel.valueOf(logLevel.name());
                 builder.frameLogger(new Http2FrameLogger(nettyLevel, DefaultHttpClient.class));
             } catch (IllegalArgumentException e) {
                 throw decorate(new HttpClientException("Unsupported log level: " + logLevel));
@@ -623,8 +654,8 @@ public class ConnectionManager {
     private void addLogHandler(Channel ch) {
         configuration.getLogLevel().ifPresent(logLevel -> {
             try {
-                final io.netty.handler.logging.LogLevel nettyLevel =
-                    io.netty.handler.logging.LogLevel.valueOf(logLevel.name());
+                final LogLevel nettyLevel =
+                    LogLevel.valueOf(logLevel.name());
                 ch.pipeline().addLast(new LoggingHandler(DefaultHttpClient.class, nettyLevel));
             } catch (IllegalArgumentException e) {
                 throw decorate(new HttpClientException("Unsupported log level: " + logLevel));
@@ -820,7 +851,7 @@ public class ConnectionManager {
                 @Override
                 public void channelActive(@NonNull ChannelHandlerContext ctx) throws Exception {
                     DefaultFullHttpRequest upgradeRequest =
-                        new DefaultFullHttpRequest(io.netty.handler.codec.http.HttpVersion.HTTP_1_1, HttpMethod.GET, "/", Unpooled.EMPTY_BUFFER);
+                        new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "/", Unpooled.EMPTY_BUFFER);
 
                     // Set HOST header as the remote peer may require it.
                     upgradeRequest.headers().set(HttpHeaderNames.HOST, pool.requestKey.getHost() + ':' + pool.requestKey.getPort());
@@ -991,7 +1022,7 @@ public class ConnectionManager {
 
     /**
      * This class represents one pool, and matches to exactly one
-     * {@link io.micronaut.http.client.netty.DefaultHttpClient.RequestKey} (i.e. host, port and
+     * {@link DefaultHttpClient.RequestKey} (i.e. host, port and
      * protocol are the same for one pool).
      * <p>
      * The superclass {@link PoolResizer} handles pool size management, this class just implements
diff --git a/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java b/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java
index 26904438a8..03f5914edf 100644
--- a/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java
+++ b/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java
@@ -163,6 +163,7 @@ import io.netty.handler.codec.http.websocketx.WebSocketClientHandshakerFactory;
 import io.netty.handler.codec.http.websocketx.WebSocketVersion;
 import io.netty.handler.flow.FlowControlHandler;
 import io.netty.handler.stream.ChunkedWriteHandler;
+import io.netty.resolver.AddressResolverGroup;
 import io.netty.util.CharsetUtil;
 import io.netty.util.ReferenceCountUtil;
 import io.netty.util.concurrent.DefaultThreadFactory;
@@ -304,7 +305,8 @@ public class DefaultHttpClient implements
             NioDatagramChannel::new,
             CompositeNettyClientCustomizer.EMPTY,
             null,
-            conversionService);
+            conversionService,
+            null);
     }
 
     /**
@@ -327,6 +329,7 @@ public class DefaultHttpClient implements
      * @param clientCustomizer                The pipeline customizer
      * @param informationalServiceId          Optional service ID that will be passed to exceptions created by this client
      * @param conversionService               The conversion service
+     * @param resolverGroup                   Optional predefined resolver group
      */
     public DefaultHttpClient(@Nullable LoadBalancer loadBalancer,
                              @Nullable HttpVersionSelection explicitHttpVersion,
@@ -345,7 +348,8 @@ public class DefaultHttpClient implements
                              @NonNull ChannelFactory<? extends DatagramChannel> udpChannelFactory,
                              NettyClientCustomizer clientCustomizer,
                              @Nullable String informationalServiceId,
-                             ConversionService conversionService
+                             ConversionService conversionService,
+                             @Nullable AddressResolverGroup<?> resolverGroup
     ) {
         ArgumentUtils.requireNonNull("nettyClientSslBuilder", nettyClientSslBuilder);
         ArgumentUtils.requireNonNull("codecRegistry", codecRegistry);
@@ -392,7 +396,8 @@ public class DefaultHttpClient implements
             udpChannelFactory,
             nettyClientSslBuilder,
             clientCustomizer,
-            informationalServiceId);
+            informationalServiceId,
+            resolverGroup);
     }
 
     /**
diff --git a/http-client/src/main/java/io/micronaut/http/client/netty/DefaultNettyHttpClientRegistry.java b/http-client/src/main/java/io/micronaut/http/client/netty/DefaultNettyHttpClientRegistry.java
index 2baa54516a..01c16159d5 100644
--- a/http-client/src/main/java/io/micronaut/http/client/netty/DefaultNettyHttpClientRegistry.java
+++ b/http-client/src/main/java/io/micronaut/http/client/netty/DefaultNettyHttpClientRegistry.java
@@ -80,6 +80,7 @@ import io.netty.channel.ChannelFactory;
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.socket.DatagramChannel;
 import io.netty.channel.socket.SocketChannel;
+import io.netty.resolver.AddressResolverGroup;
 import jakarta.annotation.PreDestroy;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -439,6 +440,8 @@ class DefaultNettyHttpClientRegistry implements AutoCloseable,
 
         EventLoopGroup eventLoopGroup = resolveEventLoopGroup(configuration, beanContext);
         ConversionService conversionService = beanContext.getBean(ConversionService.class);
+        String addressResolverGroupName = configuration.getAddressResolverGroupName();
+        AddressResolverGroup<?> resolverGroup = addressResolverGroupName == null ? null : beanContext.getBean(AddressResolverGroup.class, Qualifiers.byName(addressResolverGroupName));
         return new DefaultHttpClient(
                 loadBalancer,
                 httpVersion,
@@ -462,7 +465,8 @@ class DefaultNettyHttpClientRegistry implements AutoCloseable,
                 resolveSocketChannelFactory(NettyChannelType.DATAGRAM_SOCKET, DatagramChannel.class, configuration, beanContext),
                 clientCustomizer,
                 clientId,
-                conversionService
+                conversionService,
+                resolverGroup
         );
     }
 
