diff --git a/config/accepted-api-changes.json b/config/accepted-api-changes.json
index 0fd4433535..4cd097e327 100644
--- a/config/accepted-api-changes.json
+++ b/config/accepted-api-changes.json
@@ -348,5 +348,20 @@
     "type": "io.micronaut.core.graal.AutomaticFeatureUtils",
     "member": "Constructor io.micronaut.core.graal.AutomaticFeatureUtils()",
     "reason": "Was deprecated"
+  },
+  {
+    "type": "io.micronaut.ast.groovy.TypeElementVisitorTransform$ElementVisitor$_visitNativeProperty_lambda1",
+    "member": "Constructor io.micronaut.ast.groovy.TypeElementVisitorTransform$ElementVisitor$_visitNativeProperty_lambda1(java.lang.Object,java.lang.Object,groovy.lang.Reference)",
+    "reason": "Under Java 21 the constructor is absent"
+  },
+  {
+    "type": "io.micronaut.ast.groovy.TypeElementVisitorTransform$ElementVisitor$_visitNativeProperty_lambda2",
+    "member": "Constructor io.micronaut.ast.groovy.TypeElementVisitorTransform$ElementVisitor$_visitNativeProperty_lambda2(java.lang.Object,java.lang.Object,groovy.lang.Reference)",
+    "reason": "Under Java 21 the constructor is absent"
+  },
+  {
+    "type": "io.micronaut.ast.groovy.TypeElementVisitorTransform$ElementVisitor$_visitNativeProperty_lambda3",
+    "member": "Constructor io.micronaut.ast.groovy.TypeElementVisitorTransform$ElementVisitor$_visitNativeProperty_lambda3(java.lang.Object,java.lang.Object,groovy.lang.Reference)",
+    "reason": "Under Java 21 the constructor is absent"
   }
 ]
diff --git a/context-propagation/build.gradle b/context-propagation/build.gradle
index c939757f14..fb10fb800f 100644
--- a/context-propagation/build.gradle
+++ b/context-propagation/build.gradle
@@ -1,7 +1,7 @@
 plugins {
     id "io.micronaut.build.internal.convention-library"
     id "org.jetbrains.kotlin.jvm"
-    id "org.jetbrains.kotlin.kapt"
+    id("com.google.devtools.ksp")
 }
 
 dependencies {
@@ -58,9 +58,7 @@ dependencies {
 
 // Kotlin
 dependencies {
-    kapt project(':inject-java')
-    kaptTest project(':inject-java')
-
+    kspTest projects.injectKotlin
     compileOnly libs.managed.kotlin.stdlib.jdk8
     compileOnly libs.managed.kotlinx.coroutines.core
 
diff --git a/gradle.properties b/gradle.properties
index d0917d431e..85351e92fe 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -57,16 +57,3 @@ org.gradle.parallel=true
 org.gradle.jvmargs=-Xmx1g
 systemProp.predictiveTestSelection=false
 predictiveTestSelection=false
-
-# No matter which Java toolchain we use, the Kotlin Daemon is always invoked by the current JDK.
-# Therefor to fix Kapt errors when running tests under Java 21, we need to open up some modules for the Kotlin Daemon.
-kotlin.daemon.jvmargs=--add-opens=jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED\
- --add-opens=jdk.compiler/com.sun.tools.javac.code=ALL-UNNAMED \
- --add-opens=jdk.compiler/com.sun.tools.javac.comp=ALL-UNNAMED \
- --add-opens=jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED \
- --add-opens=jdk.compiler/com.sun.tools.javac.jvm=ALL-UNNAMED \
- --add-opens=jdk.compiler/com.sun.tools.javac.main=ALL-UNNAMED \
- --add-opens=jdk.compiler/com.sun.tools.javac.parser=ALL-UNNAMED \
- --add-opens=jdk.compiler/com.sun.tools.javac.processing=ALL-UNNAMED \
- --add-opens=jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED \
- --add-opens=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/threading/ThreadSelectionSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/threading/ThreadSelectionSpec.groovy
index 83a7b38eec..3607ad5409 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/threading/ThreadSelectionSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/threading/ThreadSelectionSpec.groovy
@@ -29,19 +29,16 @@ import reactor.core.publisher.Flux
 import reactor.core.publisher.FluxSink
 import reactor.core.publisher.Mono
 import spock.lang.Specification
+import spock.lang.Unroll
 
 import java.util.concurrent.ExecutorService
 
 class ThreadSelectionSpec extends Specification {
 
     static final String IO = "io-executor-thread-"
-    static final String VIRTUAL = "virtual-executor"
     static final String LOOP = "default-nioEventLoopGroup"
 
-    private String jdkSwitch(String java17, String other) {
-        Runtime.version().feature() == 17 ? java17 : other
-    }
-
+    @Unroll
     void "test thread selection strategy #strategy"() {
         given:
         EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, ['micronaut.server.thread-selection': strategy])
@@ -57,13 +54,13 @@ class ThreadSelectionSpec extends Specification {
         embeddedServer.close()
 
         where:
-        strategy                 | blocking               | nonBlocking            | scheduleBlocking
-        ThreadSelection.AUTO     | jdkSwitch(IO, VIRTUAL) | LOOP                   | IO
-        ThreadSelection.BLOCKING | jdkSwitch(IO, VIRTUAL) | jdkSwitch(IO, VIRTUAL) | IO
-        ThreadSelection.IO       | IO                     | IO                     | IO
-        ThreadSelection.MANUAL   | LOOP                   | LOOP                   | IO
+        strategy               | blocking | nonBlocking | scheduleBlocking
+        ThreadSelection.AUTO   | IO       | LOOP        | IO
+        ThreadSelection.IO     | IO       | IO          | IO
+        ThreadSelection.MANUAL | LOOP     | LOOP        | IO
     }
 
+    @Unroll
     void "test thread selection strategy for reactive types #strategy"() {
         given:
         EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, ['micronaut.server.thread-selection': strategy])
@@ -80,14 +77,13 @@ class ThreadSelectionSpec extends Specification {
         embeddedServer.close()
 
         where:
-        strategy                 | reactive               | blockingReactive       | scheduleSse | scheduleReactive
-        ThreadSelection.AUTO     | LOOP                   | jdkSwitch(IO, VIRTUAL) | IO          | IO
-        ThreadSelection.BLOCKING | jdkSwitch(IO, VIRTUAL) | jdkSwitch(IO, VIRTUAL) | IO          | IO
-        ThreadSelection.IO       | IO                     | IO                     | IO          | IO
-        ThreadSelection.MANUAL   | LOOP                   | LOOP                   | IO          | IO
+        strategy               |  reactive | blockingReactive | scheduleSse | scheduleReactive
+        ThreadSelection.AUTO   |  LOOP     | IO               | IO          | IO
+        ThreadSelection.IO     |  IO       | IO               | IO          | IO
+        ThreadSelection.MANUAL |  LOOP     | LOOP             | IO          | IO
     }
 
-    void "test thread selection for exception handlers #strategy"() {
+    void "test thread selection for exception handlers"() {
         given:
         EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, ['micronaut.server.thread-selection': strategy])
         ThreadSelectionClient client = embeddedServer.applicationContext.getBean(ThreadSelectionClient)
@@ -106,14 +102,13 @@ class ThreadSelectionSpec extends Specification {
         embeddedServer.close()
 
         where:
-        strategy                 | controller                              | handler                              | scheduledHandler
-        ThreadSelection.AUTO     | "controller: ${jdkSwitch(IO, VIRTUAL)}" | "handler: ${jdkSwitch(IO, VIRTUAL)}" | "handler: $IO"
-        ThreadSelection.BLOCKING | "controller: ${jdkSwitch(IO, VIRTUAL)}" | "handler: ${jdkSwitch(IO, VIRTUAL)}" | "handler: $IO"
-        ThreadSelection.IO       | "controller: $IO"                       | "handler: $IO"                       | "handler: $IO"
-        ThreadSelection.MANUAL   | "controller: $LOOP"                     | "handler: $LOOP"                     | "handler: $IO"
+        strategy               |  controller          | handler          | scheduledHandler
+        ThreadSelection.AUTO   |  "controller: $IO"   | "handler: $IO"   | "handler: $IO"
+        ThreadSelection.IO     |  "controller: $IO"   | "handler: $IO"   | "handler: $IO"
+        ThreadSelection.MANUAL |  "controller: $LOOP" | "handler: $LOOP" | "handler: $IO"
     }
 
-    void "test thread selection for error route #strategy"() {
+    void "test thread selection for error route"() {
         given:
         EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, ['micronaut.server.thread-selection': strategy])
         ThreadSelectionClient client = embeddedServer.applicationContext.getBean(ThreadSelectionClient)
@@ -129,11 +124,10 @@ class ThreadSelectionSpec extends Specification {
         embeddedServer.close()
 
         where:
-        strategy                 | controller                              | handler
-        ThreadSelection.AUTO     | "controller: ${jdkSwitch(IO, VIRTUAL)}" | "handler: ${jdkSwitch(IO, VIRTUAL)}"
-        ThreadSelection.BLOCKING | "controller: ${jdkSwitch(IO, VIRTUAL)}" | "handler: ${jdkSwitch(IO, VIRTUAL)}"
-        ThreadSelection.IO       | "controller: $IO"                       | "handler: $IO"
-        ThreadSelection.MANUAL   | "controller: $LOOP"                     | "handler: $LOOP"
+        strategy               |  controller          | handler
+        ThreadSelection.AUTO   |  "controller: $IO"   | "handler: $IO"
+        ThreadSelection.IO     |  "controller: $IO"   | "handler: $IO"
+        ThreadSelection.MANUAL |  "controller: $LOOP" | "handler: $LOOP"
     }
 
     void "test injecting an executor service does not inject the Netty event loop"() {
@@ -238,10 +232,10 @@ class ThreadSelectionSpec extends Specification {
         @ExecuteOn(TaskExecutors.IO)
         @Get(uri = "/scheduleSse", produces = MediaType.TEXT_EVENT_STREAM)
         Flux<Event<String>> scheduleSse() {
-            return Flux.<Event<String>> create(emitter -> {
-                emitter.next(Event.of("thread: ${Thread.currentThread().name}".toString()))
-                emitter.complete()
-            }, FluxSink.OverflowStrategy.BUFFER)
+            return Flux.<Event<String>>create(emitter -> {
+                        emitter.next( Event.of("thread: ${Thread.currentThread().name}".toString()))
+                        emitter.complete()
+                    }, FluxSink.OverflowStrategy.BUFFER)
         }
 
         @Get("/exception")
@@ -271,8 +265,8 @@ class ThreadSelectionSpec extends Specification {
         @Override
         Publisher<MutableHttpResponse<?>> doFilter(HttpRequest<?> request, ServerFilterChain chain) {
             return Flux.create(emitter -> {
-                emitter.next("Good")
-                emitter.complete()
+                    emitter.next("Good")
+                    emitter.complete()
             }, FluxSink.OverflowStrategy.LATEST).switchMap({ String it ->
                 return chain.proceed(request)
             })
diff --git a/inject-java/src/test/groovy/io/micronaut/inject/requires/RequiresSpec.groovy b/inject-java/src/test/groovy/io/micronaut/inject/requires/RequiresSpec.groovy
index 32956cbb26..3e7897a1e8 100644
--- a/inject-java/src/test/groovy/io/micronaut/inject/requires/RequiresSpec.groovy
+++ b/inject-java/src/test/groovy/io/micronaut/inject/requires/RequiresSpec.groovy
@@ -53,7 +53,7 @@ class MyBean {
         def lines = e.message.readLines().collect { it.trim() }
         lines[0] == 'No bean of type [test.MyBean] exists. The following matching beans are disabled by bean requirements:'
         lines[1] == '* Bean of type [test.MyBean] is disabled because:'
-        lines[2] == "- Java major version [${Runtime.version().feature()}] must be at least 800"
+        lines[2] == '- Java major version [17] must be at least 800'
 
         cleanup:
         context.close()
diff --git a/runtime/src/test/groovy/io/micronaut/runtime/executor/ExecutorServiceConfigSpec.groovy b/runtime/src/test/groovy/io/micronaut/runtime/executor/ExecutorServiceConfigSpec.groovy
index da064c7d9f..e967b88d44 100644
--- a/runtime/src/test/groovy/io/micronaut/runtime/executor/ExecutorServiceConfigSpec.groovy
+++ b/runtime/src/test/groovy/io/micronaut/runtime/executor/ExecutorServiceConfigSpec.groovy
@@ -1,3 +1,18 @@
+/*
+ * Copyright 2017-2019 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package io.micronaut.runtime.executor
 
 import io.micronaut.context.ApplicationContext
@@ -8,12 +23,12 @@ import io.micronaut.scheduling.executor.ExecutorConfiguration
 import io.micronaut.scheduling.executor.UserExecutorConfiguration
 import io.micronaut.scheduling.instrument.InstrumentedExecutor
 import spock.lang.Specification
+import spock.lang.Unroll
 
 import java.util.concurrent.ExecutorService
 import java.util.concurrent.ForkJoinPool
 import java.util.concurrent.ScheduledExecutorService
 import java.util.concurrent.ThreadPoolExecutor
-
 /**
  * @author Graeme Rocher
  * @since 1.0
@@ -21,6 +36,7 @@ import java.util.concurrent.ThreadPoolExecutor
 class ExecutorServiceConfigSpec extends Specification {
     static final int expectedExecutorCount = LoomSupport.isSupported() ? 6 : 5
 
+    @Unroll
     void "test configure custom executor with invalidate cache: #invalidateCache"() {
         given:
         ApplicationContext ctx = ApplicationContext.run(
@@ -33,7 +49,7 @@ class ExecutorServiceConfigSpec extends Specification {
         def configs = ctx.getBeansOfType(ExecutorConfiguration)
 
         then:
-        configs.name ==~ ['one', 'two', 'io', 'scheduled'] + (Runtime.version().feature() == 17 ? [] : ['virtual'])
+        configs.size() == 4
 
         when:
         Collection<ExecutorService> executorServices = ctx.getBeansOfType(ExecutorService.class)
@@ -90,6 +106,7 @@ class ExecutorServiceConfigSpec extends Specification {
     }
 
 
+    @Unroll
     void "test configure custom executor - distinct initialization order with invalidate cache: #invalidateCache"() {
         given:
         ApplicationContext ctx = ApplicationContext.run(
@@ -135,7 +152,7 @@ class ExecutorServiceConfigSpec extends Specification {
 
         then:
         executorServices.size() == expectedExecutorCount
-        moreConfigs.name ==~ ['one', 'two', 'io', 'scheduled'] + (Runtime.version().feature() == 17 ? [] : ['virtual'])
+        moreConfigs.size() == 4
         configs.size() == 2
 
         when:
@@ -158,6 +175,7 @@ class ExecutorServiceConfigSpec extends Specification {
         false           | "test"
     }
 
+    @Unroll
     void "test configure existing IO executor - distinct initialization order with invalidate cache: #invalidateCache"() {
         given:
         ApplicationContext ctx = ApplicationContext.run(
@@ -187,7 +205,7 @@ class ExecutorServiceConfigSpec extends Specification {
 
         then:
         executorServices.size() == expectedExecutorCount - 1
-        moreConfigs.name ==~ ['two', 'io', 'scheduled'] + (Runtime.version().feature() == 17 ? [] : ['virtual'])
+        moreConfigs.size() == 3
         configs.size() == 2
 
         where:
diff --git a/settings.gradle b/settings.gradle
index a5a1560a49..1afccacda4 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -6,7 +6,7 @@ pluginManagement {
 }
 
 plugins {
-    id 'io.micronaut.build.shared.settings' version '6.6.0'
+    id 'io.micronaut.build.shared.settings' version '6.5.7'
 }
 enableFeaturePreview("TYPESAFE_PROJECT_ACCESSORS")
 
@@ -68,7 +68,9 @@ include "test-suite-javax-inject"
 include "test-suite-jakarta-inject-bean-import"
 include "test-suite-http-server-tck-jdk"
 include "test-suite-http-server-tck-netty"
-include "test-suite-kotlin"
+if (JavaVersion.current() < JavaVersion.VERSION_21) {
+    include "test-suite-kotlin"
+}
 include "test-suite-kotlin-ksp"
 include "test-suite-groovy"
 include "test-suite-groovy"
