diff --git a/core-processor/src/main/java/io/micronaut/inject/utils/NativeElementsHelper.java b/core-processor/src/main/java/io/micronaut/inject/utils/NativeElementsHelper.java
index abba4b3718..40c82d6fb7 100644
--- a/core-processor/src/main/java/io/micronaut/inject/utils/NativeElementsHelper.java
+++ b/core-processor/src/main/java/io/micronaut/inject/utils/NativeElementsHelper.java
@@ -44,6 +44,14 @@ public abstract class NativeElementsHelper<C, M> {
     private final Set<Object> processedClasses = new HashSet<>();
     private final Map<MethodCacheKey, Collection<M>> overridesCache = new HashMap<>();
 
+    /**
+     * @param nativeClassType The native class type to cleanup
+     */
+    public void cleanupForClass(Object nativeClassType) {
+        processedClasses.remove(nativeClassType);
+        overridesCache.entrySet().removeIf(e -> e.getKey().classKey.equals(nativeClassType));
+    }
+
     /**
      * Check if one method overrides another.
      *
diff --git a/core-processor/src/main/java/io/micronaut/inject/visitor/DefaultTypeElementQuery.java b/core-processor/src/main/java/io/micronaut/inject/visitor/DefaultTypeElementQuery.java
index 901e94f096..d7f8a1cf39 100644
--- a/core-processor/src/main/java/io/micronaut/inject/visitor/DefaultTypeElementQuery.java
+++ b/core-processor/src/main/java/io/micronaut/inject/visitor/DefaultTypeElementQuery.java
@@ -24,7 +24,7 @@ import io.micronaut.core.annotation.Internal;
  * @param includesMethods           Include methods
  * @param includesFields            Include fields
  * @param includesEnumConstants     Include enum constants
- * @param skipsUnresolvedInterfaces Skips unresolved interfaces
+ * @param visitsUnresolvedInterfaces Visits unresolved interfaces
  * @author Denis Stepanov
  * @since 1.9
  */
@@ -33,62 +33,62 @@ record DefaultTypeElementQuery(boolean includesConstructors,
                                boolean includesMethods,
                                boolean includesFields,
                                boolean includesEnumConstants,
-                               boolean skipsUnresolvedInterfaces) implements TypeElementQuery {
+                               boolean visitsUnresolvedInterfaces) implements TypeElementQuery {
 
-    static DefaultTypeElementQuery DEFAULT = new DefaultTypeElementQuery(true, true, true, true, false);
+    static final DefaultTypeElementQuery DEFAULT = new DefaultTypeElementQuery(true, true, true, true, false);
 
     @Override
     public TypeElementQuery includeMethods() {
-        return new DefaultTypeElementQuery(includesConstructors, true, includesFields, includesEnumConstants, skipsUnresolvedInterfaces);
+        return new DefaultTypeElementQuery(includesConstructors, true, includesFields, includesEnumConstants, visitsUnresolvedInterfaces);
     }
 
     @Override
     public TypeElementQuery excludeMethods() {
-        return new DefaultTypeElementQuery(includesConstructors, false, includesFields, includesEnumConstants, skipsUnresolvedInterfaces);
+        return new DefaultTypeElementQuery(includesConstructors, false, includesFields, includesEnumConstants, visitsUnresolvedInterfaces);
     }
 
     @Override
     public TypeElementQuery includeConstructors() {
-        return new DefaultTypeElementQuery(true, includesMethods, includesFields, includesEnumConstants, skipsUnresolvedInterfaces);
+        return new DefaultTypeElementQuery(true, includesMethods, includesFields, includesEnumConstants, visitsUnresolvedInterfaces);
     }
 
     @Override
     public TypeElementQuery excludeConstructors() {
-        return new DefaultTypeElementQuery(false, includesMethods, includesFields, includesEnumConstants, skipsUnresolvedInterfaces);
+        return new DefaultTypeElementQuery(false, includesMethods, includesFields, includesEnumConstants, visitsUnresolvedInterfaces);
     }
 
     @Override
     public TypeElementQuery includeFields() {
-        return new DefaultTypeElementQuery(includesConstructors, includesMethods, true, includesEnumConstants, skipsUnresolvedInterfaces);
+        return new DefaultTypeElementQuery(includesConstructors, includesMethods, true, includesEnumConstants, visitsUnresolvedInterfaces);
     }
 
     @Override
     public TypeElementQuery excludeFields() {
-        return new DefaultTypeElementQuery(includesConstructors, includesMethods, false, includesEnumConstants, skipsUnresolvedInterfaces);
+        return new DefaultTypeElementQuery(includesConstructors, includesMethods, false, includesEnumConstants, visitsUnresolvedInterfaces);
     }
 
     @Override
     public TypeElementQuery includeEnumConstants() {
-        return new DefaultTypeElementQuery(includesConstructors, includesMethods, includesFields, true, skipsUnresolvedInterfaces);
+        return new DefaultTypeElementQuery(includesConstructors, includesMethods, includesFields, true, visitsUnresolvedInterfaces);
     }
 
     @Override
     public TypeElementQuery excludeEnumConstants() {
-        return new DefaultTypeElementQuery(includesConstructors, includesMethods, includesFields, false, skipsUnresolvedInterfaces);
+        return new DefaultTypeElementQuery(includesConstructors, includesMethods, includesFields, false, visitsUnresolvedInterfaces);
     }
 
     @Override
     public TypeElementQuery includeAll() {
-        return new DefaultTypeElementQuery(true, true, true, true, skipsUnresolvedInterfaces);
+        return new DefaultTypeElementQuery(true, true, true, true, visitsUnresolvedInterfaces);
     }
 
     @Override
     public TypeElementQuery excludeAll() {
-        return new DefaultTypeElementQuery(false, false, false, false, skipsUnresolvedInterfaces);
+        return new DefaultTypeElementQuery(false, false, false, false, visitsUnresolvedInterfaces);
     }
 
     @Override
-    public TypeElementQuery skipUnresolvedInterfaces() {
+    public TypeElementQuery visitUnresolvedInterfaces() {
         return new DefaultTypeElementQuery(includesConstructors, includesMethods, includesFields, includesEnumConstants, true);
     }
 }
diff --git a/core-processor/src/main/java/io/micronaut/inject/visitor/TypeElementQuery.java b/core-processor/src/main/java/io/micronaut/inject/visitor/TypeElementQuery.java
index b517398754..937818b283 100644
--- a/core-processor/src/main/java/io/micronaut/inject/visitor/TypeElementQuery.java
+++ b/core-processor/src/main/java/io/micronaut/inject/visitor/TypeElementQuery.java
@@ -89,11 +89,11 @@ public interface TypeElementQuery {
     TypeElementQuery excludeFields();
 
     /**
-     * Skip unresolved interfaces.
+     * If the unresolved interfaces should be visited.
      *
      * @return this query
      */
-    TypeElementQuery skipUnresolvedInterfaces();
+    TypeElementQuery visitUnresolvedInterfaces();
 
     /**
      * Include the enum constants.
@@ -144,7 +144,7 @@ public interface TypeElementQuery {
     boolean includesEnumConstants();
 
     /**
-     * @return Skips unresolved interfaces
+     * @return Visits unresolved interfaces
      */
-    boolean skipsUnresolvedInterfaces();
+    boolean visitsUnresolvedInterfaces();
 }
diff --git a/inject-java/src/main/java/io/micronaut/annotation/processing/TypeElementVisitorProcessor.java b/inject-java/src/main/java/io/micronaut/annotation/processing/TypeElementVisitorProcessor.java
index d59e7658b7..b21e68ec6e 100644
--- a/inject-java/src/main/java/io/micronaut/annotation/processing/TypeElementVisitorProcessor.java
+++ b/inject-java/src/main/java/io/micronaut/annotation/processing/TypeElementVisitorProcessor.java
@@ -246,6 +246,7 @@ public class TypeElementVisitorProcessor extends AbstractInjectAnnotationProcess
 
             for (Object nativeType : postponedTypes.values()) {
                 AbstractAnnotationMetadataBuilder.clearMutated(nativeType);
+                javaVisitorContext.getNativeElementsHelper().cleanupForClass(nativeType);
                 if (nativeType instanceof Element element) {
                     AbstractAnnotationMetadataBuilder.CachedAnnotationMetadata cachedAnnotationMetadata = javaVisitorContext.getAnnotationMetadataBuilder().lookupOrBuildForType(element);
                     cachedAnnotationMetadata.markCleared();
@@ -282,16 +283,9 @@ public class TypeElementVisitorProcessor extends AbstractInjectAnnotationProcess
                             }
                             error(originatingElement.element(), e.getMessage());
                         } catch (PostponeToNextRoundException e) {
-                            postponedTypes.put(javaClassElement.getCanonicalName(), e.getErrorElement());
+                            postponeElement(javaClassElement, e.getErrorElement(), e);
                         } catch (ElementPostponedToNextRoundException e) {
-                            Object nativeType = e.getOriginatingElement().getNativeType();
-                            if (nativeType instanceof JavaNativeElement jne) {
-                                Element element = jne.element();
-                                postponedTypes.put(javaClassElement.getCanonicalName(), element);
-                            } else {
-                                // should never happen.
-                                throw e;
-                            }
+                            postponeElement(javaClassElement, e.getOriginatingElement(), e);
                         }
                     }
                 }
@@ -328,11 +322,30 @@ public class TypeElementVisitorProcessor extends AbstractInjectAnnotationProcess
         return false;
     }
 
+    private <T extends Throwable> void postponeElement(JavaClassElement javaClassElement, Object originalElement, T e) throws T {
+        Element postponedElement;
+        if (originalElement instanceof Element element) {
+            postponedElement = element;
+        } else if (originalElement instanceof io.micronaut.inject.ast.Element element) {
+            Object nativeType = element.getNativeType();
+            if (nativeType instanceof JavaNativeElement jne) {
+                postponedElement = jne.element();
+            } else {
+                // should never happen.
+                throw e;
+            }
+        } else {
+            // should never happen.
+            throw e;
+        }
+        postponedTypes.put(javaClassElement.getCanonicalName(), postponedElement);
+    }
+
     private void visitClass(LoadedVisitor visitor, JavaClassElement classElement) {
         TypeElementQuery query = visitor.getVisitor().query();
 
         try {
-            javaVisitorContext.setSkipUnresolvedInterfaces(query.skipsUnresolvedInterfaces());
+            javaVisitorContext.setVisitUnresolvedInterfaces(query.visitsUnresolvedInterfaces());
 
             visitor.getVisitor().visitClass(classElement, javaVisitorContext);
 
@@ -371,7 +384,7 @@ public class TypeElementVisitorProcessor extends AbstractInjectAnnotationProcess
                 }
             }
         } finally {
-            javaVisitorContext.setSkipUnresolvedInterfaces(false);
+            javaVisitorContext.setVisitUnresolvedInterfaces(false);
         }
     }
 
diff --git a/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaClassElement.java b/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaClassElement.java
index 20e3b83e80..c759ea6bba 100644
--- a/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaClassElement.java
+++ b/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaClassElement.java
@@ -299,7 +299,7 @@ public class JavaClassElement extends AbstractJavaElement implements ArrayableCl
     @Override
     public Collection<ClassElement> getInterfaces() {
         if (resolvedInterfaces == null) {
-            if (visitorContext.isSkipUnresolvedInterfaces()) {
+            if (!visitorContext.isVisitUnresolvedInterfaces()) {
                 resolvedInterfaces = classElement.getInterfaces().stream()
                     .filter(this::onlyAvailable)
                     .map(mirror -> newClassElement(mirror, getTypeArguments())).toList();
@@ -309,7 +309,7 @@ public class JavaClassElement extends AbstractJavaElement implements ArrayableCl
                     .map(mirror -> newClassElement(mirror, getTypeArguments())).toList();
                 hasErrorousInterface = false;
             }
-        } else if (hasErrorousInterface && !visitorContext.isSkipUnresolvedInterfaces()) {
+        } else if (hasErrorousInterface && visitorContext.isVisitUnresolvedInterfaces()) {
             resolvedInterfaces = classElement.getInterfaces().stream()
                 .map(mirror -> newClassElement(mirror, getTypeArguments())).toList();
             hasErrorousInterface = false;
diff --git a/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaVisitorContext.java b/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaVisitorContext.java
index 8e2d373ca1..3e55a58d85 100644
--- a/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaVisitorContext.java
+++ b/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaVisitorContext.java
@@ -103,7 +103,7 @@ public final class JavaVisitorContext implements VisitorContext, BeanElementVisi
     private final JavaNativeElementsHelper nativeElementsHelper;
     private final Filer filer;
     private final Set<String> postponedTypes;
-    private boolean skipUnresolvedInterfaces;
+    private boolean visitUnresolvedInterfaces;
 
     /**
      * The default constructor.
@@ -221,19 +221,19 @@ public final class JavaVisitorContext implements VisitorContext, BeanElementVisi
     }
 
     /**
-     * @return True if the unresolved interfaces should be skipped
+     * @return True if the unresolved interfaces should be visited
      * @since 4.9
      */
-    public boolean isSkipUnresolvedInterfaces() {
-        return skipUnresolvedInterfaces;
+    public boolean isVisitUnresolvedInterfaces() {
+        return visitUnresolvedInterfaces;
     }
 
     /**
-     * @param skipUnresolvedInterfaces True to skip unresolved interfaces
+     * @param visitUnresolvedInterfaces True to visit unresolved interfaces
      * @since 4.9
      */
-    public void setSkipUnresolvedInterfaces(boolean skipUnresolvedInterfaces) {
-        this.skipUnresolvedInterfaces = skipUnresolvedInterfaces;
+    public void setVisitUnresolvedInterfaces(boolean visitUnresolvedInterfaces) {
+        this.visitUnresolvedInterfaces = visitUnresolvedInterfaces;
     }
 
     @NonNull
