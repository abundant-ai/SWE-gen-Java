diff --git a/docs/src/main/asciidoc/security-authentication-mechanisms.adoc b/docs/src/main/asciidoc/security-authentication-mechanisms.adoc
index c6aa25b5d96..8adf472ab19 100644
--- a/docs/src/main/asciidoc/security-authentication-mechanisms.adoc
+++ b/docs/src/main/asciidoc/security-authentication-mechanisms.adoc
@@ -986,15 +986,10 @@ quarkus.http.auth.permission.bearer.auth-mechanism=bearer
 quarkus.http.auth.permission.custom.paths=/hello/custom <3>
 quarkus.http.auth.permission.custom.policy=authenticated
 quarkus.http.auth.permission.custom.auth-mechanism=custom
-
-quarkus.http.auth.permission.basic-bearer.paths=/hello/basic-bearer <4>
-quarkus.http.auth.permission.basic-bearer.policy=authenticated
-quarkus.http.auth.permission.basic-bearer.auth-mechanism=basic,bearer
 ----
 <1> The REST endpoint `/hello/basic` can only ever be accessed by using the <<basic-auth>>.
 <2> The REST endpoint `/hello/bearer` can only ever be accessed by using the xref:security-oidc-bearer-token-authentication.adoc[OIDC bearer token authentication mechanism].
 <3> The REST endpoint `/hello/custom` can only ever be accessed by using a custom `HttpAuthenticationMechanism` with a `custom` authentication scheme.
-<4> The REST endpoint `/hello/basic-bearer` can be accessed either by using the xref:security-oidc-bearer-token-authentication.adoc[OIDC bearer token authentication mechanism], or by using the <<basic-auth>>.
 
 [IMPORTANT]
 ====
@@ -1002,36 +997,6 @@ Ensure that the value of the `auth-mechanism` property matches the authenticatio
 For example, for the `quarkus.http.auth.permission.custom.auth-mechanism=custom` expression to be effective, a custom `HttpAuthenticationMechanism` implementation must set its authentication scheme to `custom` in its `HttpAuthenticationMechanism#getCredentialTransport` method implementation.
 ====
 
-==== Use HTTP Security Policy inclusive path-based authentication
-
-When an <<inclusive-authentication, inclusive authentication>> is enabled in a `strict` mode, every selected authentication mechanism must provide the `SecurityIdentity`.
-For example:
-
-[source,properties]
-----
-quarkus.http.auth.inclusive=true
-
-quarkus.http.auth.permission.basic-bearer.paths=/hello/basic-bearer
-quarkus.http.auth.permission.basic-bearer.policy=authenticated
-quarkus.http.auth.permission.basic-bearer.auth-mechanism=basic,bearer   <1>
-----
-<1> The REST endpoint `/hello/basic-bearer` can be accessed only if both the xref:security-oidc-bearer-token-authentication.adoc[OIDC bearer token authentication mechanism] and the <<basic-auth>> have successfully provided `SecurityIdentity`.
-
-When an <<inclusive-authentication, inclusive authentication>> is enabled in a `lax` mode, every selected authentication mechanism will have a chance to provide its own `SecurityIdentity`, with at least one of the mechanisms expected to produce `SecurityIdentity`.
-Consider the following example:
-
-[source,properties]
-----
-quarkus.http.auth.inclusive=true
-quarkus.http.auth.inclusive-mode=lax
-
-quarkus.http.auth.permission.basic-bearer.paths=/hello/basic-bearer
-quarkus.http.auth.permission.basic-bearer.policy=authenticated
-quarkus.http.auth.permission.basic-bearer.auth-mechanism=basic,bearer   <1>
-----
-<1> The REST endpoint `/hello/basic-bearer` uses both the xref:security-oidc-bearer-token-authentication.adoc[OIDC bearer token authentication mechanism] and the <<basic-auth>>.
-Access is granted if at least one of them successfully provides `SecurityIdentity`.
-
 [[use-annotations-for-path-based-auth]]
 ==== Use annotations to enable path-based authentication for Jakarta REST endpoints
 
@@ -1130,8 +1095,8 @@ NOTE: For consistency with various Jakarta EE specifications, it is recommended
 
 ==== Use inclusive authentication to enable path-based authentication
 
-By default, Quarkus only supports <<use-annotations-for-path-based-auth>> for one authentication mechanism selected with annotation per REST endpoint.
-If more than one authentication mechanism must be used for the <<path-based-authentication>>, you can write a custom `HttpAuthenticationMechanism` as documented in the xref:security-customization.adoc#dealing-with-more-than-one-http-auth-mechanisms[Dealing with more than one HttpAuthenticationMechanism] section of the Security Tips and Tricks guide.
+By default, Quarkus only supports <<path-based-authentication>> for one authentication mechanism per path.
+If more than one authentication mechanism must be used for the path-based authentication, you can write a custom `HttpAuthenticationMechanism` as documented in the xref:security-customization.adoc#dealing-with-more-than-one-http-auth-mechanisms[Dealing with more than one HttpAuthenticationMechanism] section of the Security Tips and Tricks guide.
 Another option is to enable <<inclusive-authentication>> in the lax mode and write a custom `HttpSecurityPolicy` or `PermissionChecker` that verifies that all registered HTTP authentication mechanisms created their mechanism-specific `SecurityIdentity`.
 
 .Enable inclusive authentication in the lax mode
diff --git a/extensions/vertx-http/deployment/src/test/java/io/quarkus/vertx/http/security/CombinedFormBasicAuthGlobalInclusiveTest.java b/extensions/vertx-http/deployment/src/test/java/io/quarkus/vertx/http/security/CombinedFormBasicAuthGlobalInclusiveTest.java
deleted file mode 100644
index 62b7e0c2f6a..00000000000
--- a/extensions/vertx-http/deployment/src/test/java/io/quarkus/vertx/http/security/CombinedFormBasicAuthGlobalInclusiveTest.java
+++ /dev/null
@@ -1,154 +0,0 @@
-package io.quarkus.vertx.http.security;
-
-import static org.hamcrest.Matchers.equalTo;
-
-import jakarta.enterprise.context.ApplicationScoped;
-
-import org.jboss.shrinkwrap.api.asset.StringAsset;
-import org.junit.jupiter.api.BeforeAll;
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.RegisterExtension;
-
-import io.quarkus.security.identity.IdentityProviderManager;
-import io.quarkus.security.identity.SecurityIdentity;
-import io.quarkus.security.runtime.QuarkusPrincipal;
-import io.quarkus.security.runtime.QuarkusSecurityIdentity;
-import io.quarkus.security.test.utils.TestIdentityController;
-import io.quarkus.security.test.utils.TestIdentityProvider;
-import io.quarkus.test.QuarkusUnitTest;
-import io.quarkus.vertx.http.runtime.security.ChallengeData;
-import io.quarkus.vertx.http.runtime.security.HttpAuthenticationMechanism;
-import io.quarkus.vertx.http.runtime.security.HttpCredentialTransport;
-import io.restassured.RestAssured;
-import io.restassured.filter.cookie.CookieFilter;
-import io.smallrye.mutiny.Uni;
-import io.vertx.ext.web.RoutingContext;
-
-class CombinedFormBasicAuthGlobalInclusiveTest {
-
-    @RegisterExtension
-    static final QuarkusUnitTest test = new QuarkusUnitTest().withApplicationRoot(jar -> jar
-            .addClasses(TestIdentityProvider.class, TestTrustedIdentityProvider.class, TestIdentityController.class,
-                    PathHandler.class, CustomMechanism.class)
-            .addAsResource(new StringAsset("""
-                    quarkus.http.auth.inclusive=true
-                    quarkus.http.auth.basic=true
-                    quarkus.http.auth.realm=TestRealm
-                    quarkus.http.auth.form.enabled=true
-                    quarkus.http.auth.form.login-page=
-                    quarkus.http.auth.form.error-page=
-                    quarkus.http.auth.form.landing-page=
-                    quarkus.http.auth.policy.r1.roles-allowed=admin
-                    quarkus.http.auth.permission.roles1.paths=/admin
-                    quarkus.http.auth.permission.roles1.policy=r1
-                    quarkus.http.auth.permission.roles1.auth-mechanism=form,basic
-                    """), "application.properties"));
-
-    @BeforeAll
-    static void setup() {
-        TestIdentityController.resetRoles()
-                .add("admin", "admin", "admin");
-    }
-
-    @Test
-    void testOtherMechanismNotAllowed() {
-        // tests that:
-        // - this path requires form and basic
-        // - inclusive auth selected form and basic, so the custom is not required for /admin path
-        RestAssured
-                .given()
-                .header("use-custom-auth", "true")
-                .redirects().follow(false)
-                .when()
-                .get("/admin")
-                .then()
-                .statusCode(401);
-    }
-
-    @Test
-    void testFormBasedAuthOnlyFails() {
-        CookieFilter cookies = new CookieFilter();
-
-        RestAssured
-                .given()
-                .filter(cookies)
-                .redirects().follow(false)
-                .when()
-                .formParam("j_username", "admin")
-                .formParam("j_password", "admin")
-                .post("/j_security_check")
-                .then()
-                .statusCode(200);
-
-        RestAssured
-                .given()
-                .filter(cookies)
-                .redirects().follow(false)
-                .when()
-                .get("/admin")
-                .then()
-                .statusCode(401);
-    }
-
-    @Test
-    void testBasicAuthOnlyFails() {
-        RestAssured
-                .given()
-                .auth().preemptive().basic("admin", "admin")
-                .redirects().follow(false)
-                .when()
-                .get("/admin")
-                .then()
-                .statusCode(401);
-    }
-
-    @Test
-    public void testBasicAndFormAuthTogetherSucceeds() {
-        CookieFilter cookies = new CookieFilter();
-        RestAssured
-                .given()
-                .filter(cookies)
-                .redirects().follow(false)
-                .when()
-                .formParam("j_username", "admin")
-                .formParam("j_password", "admin")
-                .post("/j_security_check")
-                .then()
-                .statusCode(200);
-
-        RestAssured
-                .given()
-                .filter(cookies)
-                .auth().preemptive().basic("admin", "admin")
-                .when()
-                .get("/admin")
-                .then()
-                .statusCode(200)
-                .body(equalTo("admin:/admin"));
-    }
-
-    @ApplicationScoped
-    static class CustomMechanism implements HttpAuthenticationMechanism {
-
-        @Override
-        public Uni<SecurityIdentity> authenticate(RoutingContext context, IdentityProviderManager identityProviderManager) {
-            if (context.request().headers().contains("use-custom-auth")) {
-                return Uni.createFrom().item(QuarkusSecurityIdentity.builder()
-                        .addRole("admin")
-                        .setPrincipal(new QuarkusPrincipal("custom"))
-                        .build());
-            }
-            return Uni.createFrom().nullItem();
-        }
-
-        @Override
-        public Uni<ChallengeData> getChallenge(RoutingContext context) {
-            return Uni.createFrom().nullItem();
-        }
-
-        @Override
-        public Uni<HttpCredentialTransport> getCredentialTransport(RoutingContext context) {
-            return Uni.createFrom().item(new HttpCredentialTransport(HttpCredentialTransport.Type.POST, "ignored", "custom"));
-        }
-    }
-}
diff --git a/extensions/vertx-http/deployment/src/test/java/io/quarkus/vertx/http/security/FluentApiAuthenticationMechanismSelectionTest.java b/extensions/vertx-http/deployment/src/test/java/io/quarkus/vertx/http/security/FluentApiAuthenticationMechanismSelectionTest.java
index 39373d235f1..ba3e33ddcd3 100644
--- a/extensions/vertx-http/deployment/src/test/java/io/quarkus/vertx/http/security/FluentApiAuthenticationMechanismSelectionTest.java
+++ b/extensions/vertx-http/deployment/src/test/java/io/quarkus/vertx/http/security/FluentApiAuthenticationMechanismSelectionTest.java
@@ -24,8 +24,6 @@
 import io.quarkus.security.identity.IdentityProviderManager;
 import io.quarkus.security.identity.SecurityIdentity;
 import io.quarkus.security.identity.request.AuthenticationRequest;
-import io.quarkus.security.runtime.QuarkusPrincipal;
-import io.quarkus.security.runtime.QuarkusSecurityIdentity;
 import io.quarkus.security.test.utils.TestIdentityController;
 import io.quarkus.security.test.utils.TestIdentityProvider;
 import io.quarkus.test.QuarkusUnitTest;
@@ -59,7 +57,6 @@ public class FluentApiAuthenticationMechanismSelectionTest {
                     quarkus.http.ssl.certificate.key-store-password=secret
                     quarkus.http.ssl.certificate.trust-store-file=server-truststore.p12
                     quarkus.http.ssl.certificate.trust-store-password=secret
-                    quarkus.http.auth.form.login-page=
                     """), "application.properties")
             .addAsResource(new File("target/certs/mtls-test-keystore.p12"), "server-keystore.p12")
             .addAsResource(new File("target/certs/mtls-test-server-truststore.p12"), "server-truststore.p12"));
@@ -67,12 +64,6 @@ public class FluentApiAuthenticationMechanismSelectionTest {
     @TestHTTPResource(value = "/mtls", tls = true)
     URL url;
 
-    @TestHTTPResource(value = "/mtls-basic", tls = true)
-    URL mTlsBasicUrl;
-
-    @TestHTTPResource(value = "/mtls-basic-form", tls = true)
-    URL mTlsBasicFormUrl;
-
     @BeforeAll
     public static void setup() {
         TestIdentityController.resetRoles()
@@ -121,7 +112,8 @@ public void testForm() {
                 .get("/form/admin")
                 .then()
                 .assertThat()
-                .statusCode(401);
+                .statusCode(302)
+                .header("location", containsString("/login.html"));
 
         // basic authentication & POST -> access is going to be denied as there are permissions with POST method
         RestAssured
@@ -181,83 +173,6 @@ public void testMutualTlsMechanism() {
         }
     }
 
-    @Test
-    void testCombiningBasicAndMutualTls() {
-        // anonymous user
-        RestAssured.given().get("/mtls-basic").then().statusCode(401);
-
-        // other mechanism, that must not be allowed for this path
-        RestAssured.given().header("custom-auth", "ignored").get("/mtls-basic").then().statusCode(401);
-
-        // only basic auth
-        RestAssured
-                .given()
-                .auth().preemptive().basic("admin", "admin")
-                .when()
-                .get("/mtls-basic")
-                .then()
-                .statusCode(200)
-                .body(equalTo("admin:/mtls-basic"));
-
-        // only mTLS
-        RestAssured.given()
-                .keyStore("target/certs/mtls-test-client-keystore.p12", "secret")
-                .trustStore("target/certs/mtls-test-client-truststore.p12", "secret")
-                .get(mTlsBasicUrl).then().statusCode(200).body(is("CN=localhost:/mtls-basic"));
-
-        // both basic and mTLS auth
-        RestAssured.given()
-                .keyStore("target/certs/mtls-test-client-keystore.p12", "secret")
-                .trustStore("target/certs/mtls-test-client-truststore.p12", "secret")
-                .auth().preemptive().basic("admin", "admin")
-                .get(mTlsBasicUrl).then().statusCode(200).body(is("admin:/mtls-basic"));
-    }
-
-    @Test
-    void testCombiningBasicAndMutualTlsAndForm() {
-        // anonymous user
-        RestAssured.given().redirects().follow(false).get("/mtls-basic-form").then().statusCode(401);
-
-        // other mechanism, that must not be allowed for this path
-        RestAssured.given().redirects().follow(false).header("custom-auth", "ignored").get("/mtls-basic-form").then()
-                .statusCode(401);
-
-        // only basic auth
-        RestAssured
-                .given()
-                .auth().preemptive().basic("admin", "admin")
-                .when()
-                .get("/mtls-basic-form")
-                .then()
-                .statusCode(200)
-                .body(equalTo("admin:/mtls-basic-form"));
-
-        // only mTLS
-        RestAssured.given()
-                .keyStore("target/certs/mtls-test-client-keystore.p12", "secret")
-                .trustStore("target/certs/mtls-test-client-truststore.p12", "secret")
-                .get(mTlsBasicFormUrl).then().statusCode(200).body(is("CN=localhost:/mtls-basic-form"));
-
-        // only form
-        CookieFilter adminCookies = new CookieFilter();
-        loginUsingFormAuth(adminCookies, "admin");
-        RestAssured
-                .given()
-                .filter(adminCookies)
-                .get("/mtls-basic-form")
-                .then()
-                .statusCode(200)
-                .body(equalTo("admin:/mtls-basic-form"));
-
-        // all three - basic, form and mTLS auth
-        RestAssured.given()
-                .keyStore("target/certs/mtls-test-client-keystore.p12", "secret")
-                .trustStore("target/certs/mtls-test-client-truststore.p12", "secret")
-                .filter(adminCookies)
-                .auth().preemptive().basic("admin", "admin")
-                .get(mTlsBasicFormUrl).then().statusCode(200).body(is("admin:/mtls-basic-form"));
-    }
-
     private static void basicAuthTest(String s, String operand) {
         RestAssured
                 .given()
@@ -307,8 +222,7 @@ void configure(@Observes HttpSecurity httpSecurity) {
             httpSecurity
                     .mechanism(new CustomSchemeAuthenticationMechanism())
                     .basic()
-                    .mTLS(MTLS.builder().authentication(ClientAuth.REQUEST).rolesMapping("localhost", "admin").priority(1005)
-                            .build())
+                    .mTLS(ClientAuth.REQUEST)
                     .get("/form/admin").form().authorization()
                     .policy(identity -> "admin".equals(identity.getPrincipal().getName()))
                     .put("/form/admin").basic().authorization()
@@ -318,8 +232,6 @@ void configure(@Observes HttpSecurity httpSecurity) {
                     .path("/custom-instance/admin").authenticatedWith("custom-scheme").authorization()
                     .policy((identity, event) -> identity.hasRole("admin")
                             && event.normalizedPath().endsWith("/custom-instance/admin"))
-                    .path("/mtls-basic").authenticatedWith(Set.of("basic", "x509")).roles("admin")
-                    .path("/mtls-basic-form").authenticatedWith(Set.of("form", "basic", "x509")).roles("admin")
                     .path("/mtls").mTLS();
         }
 
@@ -351,12 +263,6 @@ public static abstract class AbstractCustomAuthenticationMechanism implements Ht
 
         @Override
         public Uni<SecurityIdentity> authenticate(RoutingContext context, IdentityProviderManager identityProviderManager) {
-            if (context.request().headers().get("custom-auth") != null) {
-                return Uni.createFrom().item(QuarkusSecurityIdentity.builder()
-                        .setPrincipal(new QuarkusPrincipal("Olga"))
-                        .addRole("admin")
-                        .build());
-            }
             return delegate.authenticate(context, identityProviderManager);
         }
 
diff --git a/extensions/vertx-http/deployment/src/test/java/io/quarkus/vertx/http/security/FluentApiInclusiveAuthenticationMechanismSelectionTest.java b/extensions/vertx-http/deployment/src/test/java/io/quarkus/vertx/http/security/FluentApiInclusiveAuthenticationMechanismSelectionTest.java
deleted file mode 100644
index c3fb819fd68..00000000000
--- a/extensions/vertx-http/deployment/src/test/java/io/quarkus/vertx/http/security/FluentApiInclusiveAuthenticationMechanismSelectionTest.java
+++ /dev/null
@@ -1,234 +0,0 @@
-package io.quarkus.vertx.http.security;
-
-import static io.restassured.matcher.RestAssuredMatchers.detailedCookie;
-import static org.hamcrest.Matchers.containsString;
-import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.is;
-import static org.hamcrest.Matchers.notNullValue;
-
-import java.io.File;
-import java.net.URL;
-import java.util.Set;
-
-import jakarta.enterprise.event.Observes;
-
-import org.jboss.shrinkwrap.api.ShrinkWrap;
-import org.jboss.shrinkwrap.api.asset.StringAsset;
-import org.jboss.shrinkwrap.api.spec.JavaArchive;
-import org.junit.jupiter.api.BeforeAll;
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.RegisterExtension;
-
-import io.quarkus.security.StringPermission;
-import io.quarkus.security.identity.IdentityProviderManager;
-import io.quarkus.security.identity.SecurityIdentity;
-import io.quarkus.security.identity.request.AuthenticationRequest;
-import io.quarkus.security.runtime.QuarkusPrincipal;
-import io.quarkus.security.runtime.QuarkusSecurityIdentity;
-import io.quarkus.security.test.utils.TestIdentityController;
-import io.quarkus.security.test.utils.TestIdentityProvider;
-import io.quarkus.test.QuarkusUnitTest;
-import io.quarkus.test.common.http.TestHTTPResource;
-import io.quarkus.vertx.http.runtime.security.BasicAuthenticationMechanism;
-import io.quarkus.vertx.http.runtime.security.ChallengeData;
-import io.quarkus.vertx.http.runtime.security.HttpAuthenticationMechanism;
-import io.quarkus.vertx.http.runtime.security.HttpCredentialTransport;
-import io.quarkus.vertx.http.runtime.security.HttpSecurityPolicy;
-import io.restassured.RestAssured;
-import io.restassured.filter.cookie.CookieFilter;
-import io.smallrye.certs.Format;
-import io.smallrye.certs.junit5.Certificate;
-import io.smallrye.certs.junit5.Certificates;
-import io.smallrye.mutiny.Uni;
-import io.vertx.core.http.ClientAuth;
-import io.vertx.ext.web.RoutingContext;
-
-@Certificates(baseDir = "target/certs", certificates = @Certificate(name = "mtls-test", password = "secret", formats = Format.PKCS12, client = true))
-class FluentApiInclusiveAuthenticationMechanismSelectionTest {
-
-    @RegisterExtension
-    static final QuarkusUnitTest test = new QuarkusUnitTest().setArchiveProducer(() -> ShrinkWrap
-            .create(JavaArchive.class)
-            .addClasses(AuthMechanismConfig.class, TestIdentityController.class, TestIdentityProvider.class,
-                    PathHandler.class, TestTrustedIdentityProvider.class, CustomHttpSecurityPolicy.class,
-                    CustomSchemeAuthenticationMechanism.class, AbstractCustomAuthenticationMechanism.class)
-            .addAsResource(new StringAsset("""
-                    quarkus.http.auth.form.enabled=true
-                    quarkus.http.ssl.certificate.key-store-file=server-keystore.p12
-                    quarkus.http.ssl.certificate.key-store-password=secret
-                    quarkus.http.ssl.certificate.trust-store-file=server-truststore.p12
-                    quarkus.http.ssl.certificate.trust-store-password=secret
-                    quarkus.http.auth.form.login-page=
-                    quarkus.http.auth.inclusive=true
-                    """), "application.properties")
-            .addAsResource(new File("target/certs/mtls-test-keystore.p12"), "server-keystore.p12")
-            .addAsResource(new File("target/certs/mtls-test-server-truststore.p12"), "server-truststore.p12"));
-
-    @TestHTTPResource(value = "/mtls-basic-inclusive", tls = true)
-    URL mTlsBasicInclusiveUrl;
-
-    @TestHTTPResource(value = "/mtls-basic-form-inclusive", tls = true)
-    URL mTlsBasicFormInclusiveUrl;
-
-    @BeforeAll
-    static void setup() {
-        TestIdentityController.resetRoles()
-                .add("admin", "admin", new StringPermission("openid"), new StringPermission("email"),
-                        new StringPermission("profile"));
-    }
-
-    @Test
-    void testCombiningBasicAndMutualTls_inclusiveAuthentication() {
-        // anonymous user
-        RestAssured.given().get("/mtls-basic-inclusive").then().statusCode(401);
-
-        // other mechanism, that must not be allowed for this path
-        RestAssured.given().header("custom-auth", "ignored").get("/mtls-basic-inclusive").then().statusCode(401);
-
-        // only basic auth - fail as we require both basic and mTLS
-        RestAssured
-                .given()
-                .auth().preemptive().basic("admin", "admin")
-                .when()
-                .get("/mtls-basic-inclusive")
-                .then()
-                .statusCode(401);
-
-        // only mTLS - fail as we require both basic and mTLS
-        RestAssured.given()
-                .keyStore("target/certs/mtls-test-client-keystore.p12", "secret")
-                .trustStore("target/certs/mtls-test-client-truststore.p12", "secret")
-                .get(mTlsBasicInclusiveUrl).then().statusCode(401);
-
-        // both basic and mTLS auth
-        RestAssured.given()
-                .keyStore("target/certs/mtls-test-client-keystore.p12", "secret")
-                .trustStore("target/certs/mtls-test-client-truststore.p12", "secret")
-                .auth().preemptive().basic("admin", "admin")
-                .get(mTlsBasicInclusiveUrl).then().statusCode(200).body(is("CN=localhost:/mtls-basic-inclusive"));
-    }
-
-    @Test
-    void testCombiningBasicAndMutualTlsAndForm_inclusiveAuthentication() {
-        // anonymous user
-        RestAssured.given().redirects().follow(false).get("/mtls-basic-form-inclusive").then().statusCode(401);
-
-        // other mechanism, that must not be allowed for this path
-        RestAssured.given().redirects().follow(false).header("custom-auth", "ignored").get("/mtls-basic-form-inclusive").then()
-                .statusCode(401);
-
-        // only basic auth - fail as we require all three - basic, form and mTLS
-        RestAssured
-                .given()
-                .auth().preemptive().basic("admin", "admin")
-                .when()
-                .get("/mtls-basic-form-inclusive")
-                .then()
-                .statusCode(401);
-
-        // only mTLS - fail as we require all three - basic, form and mTLS
-        RestAssured.given()
-                .keyStore("target/certs/mtls-test-client-keystore.p12", "secret")
-                .trustStore("target/certs/mtls-test-client-truststore.p12", "secret")
-                .get(mTlsBasicFormInclusiveUrl)
-                .then()
-                .statusCode(401);
-
-        // only form - fail as we require all three - basic, form and mTLS
-        CookieFilter adminCookies = new CookieFilter();
-        loginUsingFormAuth(adminCookies, "admin");
-        RestAssured
-                .given()
-                .filter(adminCookies)
-                .get("/mtls-basic-form-inclusive")
-                .then()
-                .statusCode(401);
-
-        // all three - basic, form and mTLS auth
-        RestAssured.given()
-                .keyStore("target/certs/mtls-test-client-keystore.p12", "secret")
-                .trustStore("target/certs/mtls-test-client-truststore.p12", "secret")
-                .filter(adminCookies)
-                .auth().preemptive().basic("admin", "admin")
-                .get(mTlsBasicFormInclusiveUrl)
-                .then()
-                .statusCode(200)
-                .body(is("CN=localhost:/mtls-basic-form-inclusive"));
-    }
-
-    private static void loginUsingFormAuth(CookieFilter adminCookies, String user) {
-        RestAssured
-                .given()
-                .filter(adminCookies)
-                .redirects().follow(false)
-                .when()
-                .formParam("j_username", user)
-                .formParam("j_password", user)
-                .post("/j_security_check")
-                .then()
-                .assertThat()
-                .statusCode(302)
-                .header("location", containsString("/index.html"))
-                .cookie("quarkus-credential",
-                        detailedCookie().value(notNullValue()).path(equalTo("/")));
-    }
-
-    static class AuthMechanismConfig {
-
-        void configure(@Observes HttpSecurity httpSecurity) {
-            httpSecurity
-                    .mechanism(new CustomSchemeAuthenticationMechanism())
-                    .basic()
-                    .mTLS(MTLS.builder().authentication(ClientAuth.REQUEST).rolesMapping("localhost", "admin").build())
-                    .path("/mtls-basic-inclusive").authenticatedWith(Set.of("basic", "x509")).roles("admin")
-                    .path("/mtls-basic-form-inclusive").authenticatedWith(Set.of("form", "basic", "x509")).roles("admin");
-        }
-
-    }
-
-    static final class CustomHttpSecurityPolicy implements HttpSecurityPolicy {
-        @Override
-        public Uni<CheckResult> checkPermission(RoutingContext request, Uni<SecurityIdentity> identityUni,
-                AuthorizationRequestContext requestContext) {
-            return identityUni.onItemOrFailure().transform((identity, throwable) -> {
-                if (throwable == null && identity.hasRole("admin")) {
-                    return CheckResult.PERMIT;
-                }
-                return CheckResult.DENY;
-            });
-        }
-    }
-
-    static class CustomSchemeAuthenticationMechanism extends AbstractCustomAuthenticationMechanism {
-        @Override
-        public Uni<HttpCredentialTransport> getCredentialTransport(RoutingContext context) {
-            return Uni.createFrom()
-                    .item(new HttpCredentialTransport(HttpCredentialTransport.Type.AUTHORIZATION, "custom-scheme"));
-        }
-    }
-
-    static abstract class AbstractCustomAuthenticationMechanism implements HttpAuthenticationMechanism {
-        private final HttpAuthenticationMechanism delegate = new BasicAuthenticationMechanism(null, false);
-
-        @Override
-        public Uni<SecurityIdentity> authenticate(RoutingContext context, IdentityProviderManager identityProviderManager) {
-            if (context.request().headers().get("custom-auth") != null) {
-                return Uni.createFrom().item(QuarkusSecurityIdentity.builder()
-                        .setPrincipal(new QuarkusPrincipal("Olga"))
-                        .addRole("admin")
-                        .build());
-            }
-            return delegate.authenticate(context, identityProviderManager);
-        }
-
-        @Override
-        public Uni<ChallengeData> getChallenge(RoutingContext context) {
-            return delegate.getChallenge(context);
-        }
-
-        @Override
-        public Set<Class<? extends AuthenticationRequest>> getCredentialTypes() {
-            return delegate.getCredentialTypes();
-        }
-    }
-}
diff --git a/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/PolicyMappingConfig.java b/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/PolicyMappingConfig.java
index 6e56c8fffe8..6c9a3aaf0db 100644
--- a/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/PolicyMappingConfig.java
+++ b/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/PolicyMappingConfig.java
@@ -2,10 +2,7 @@
 
 import java.util.List;
 import java.util.Optional;
-import java.util.Set;
 
-import io.quarkus.runtime.configuration.TrimmedStringConverter;
-import io.smallrye.config.WithConverter;
 import io.smallrye.config.WithDefault;
 
 public interface PolicyMappingConfig {
@@ -51,13 +48,11 @@ public interface PolicyMappingConfig {
     Optional<List<String>> paths();
 
     /**
-     * One or more path specific authentication mechanisms separated by comma.
-     * Every listed value needs to match {@link io.quarkus.vertx.http.runtime.security.HttpCredentialTransport}
-     * authentication scheme such as 'basic', 'bearer', 'form', etc.
-     * By default, only one of the matching authentication mechanisms will produce a `SecurityIdentity`,
-     * and all matching authentication mechanisms will attempt to authenticate when an inclusive authentication is enabled.
+     * Path specific authentication mechanism which must be used to authenticate a user.
+     * It needs to match {@link io.quarkus.vertx.http.runtime.security.HttpCredentialTransport} authentication scheme
+     * such as 'basic', 'bearer', 'form', etc.
      */
-    Optional<Set<@WithConverter(TrimmedStringConverter.class) String>> authMechanism();
+    Optional<String> authMechanism();
 
     /**
      * Indicates that this policy always applies to the matched paths in addition to the policy with a winning path.
diff --git a/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/AbstractPathMatchingHttpSecurityPolicy.java b/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/AbstractPathMatchingHttpSecurityPolicy.java
index 1a90d9a7307..46e215c072d 100644
--- a/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/AbstractPathMatchingHttpSecurityPolicy.java
+++ b/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/AbstractPathMatchingHttpSecurityPolicy.java
@@ -21,7 +21,7 @@
 import io.quarkus.security.identity.SecurityIdentity;
 import io.quarkus.vertx.http.runtime.PolicyConfig;
 import io.quarkus.vertx.http.runtime.PolicyMappingConfig;
-import io.quarkus.vertx.http.runtime.security.HttpSecurityConfiguration.AuthenticationMechanisms;
+import io.quarkus.vertx.http.runtime.security.HttpSecurityConfiguration.AuthenticationMechanism;
 import io.quarkus.vertx.http.runtime.security.HttpSecurityPolicy.AuthorizationRequestContext;
 import io.quarkus.vertx.http.runtime.security.HttpSecurityPolicy.CheckResult;
 import io.quarkus.vertx.http.runtime.security.ImmutablePathMatcher.PathMatch;
@@ -70,16 +70,29 @@ public class AbstractPathMatchingHttpSecurityPolicy {
         this.pathMatcher = builder.build();
     }
 
-    AuthenticationMechanisms getAuthMechanisms(RoutingContext routingContext) {
+    AuthenticationMechanism getAuthMechanism(RoutingContext routingContext) {
         if (sharedPermissionsPathMatchers != null) {
             for (ImmutablePathMatcher<List<HttpMatcher>> matcher : sharedPermissionsPathMatchers) {
-                AuthenticationMechanisms authMechanisms = getAuthMechanisms(routingContext, matcher);
-                if (authMechanisms != null) {
-                    return authMechanisms;
+                AuthenticationMechanism authMechanism = getAuthMechanism(routingContext, matcher);
+                if (authMechanism != null) {
+                    return authMechanism;
                 }
             }
         }
-        return getAuthMechanisms(routingContext, pathMatcher);
+        return getAuthMechanism(routingContext, pathMatcher);
+    }
+
+    /**
+     * @deprecated This method is internal by nature, if you have a good use case, please report it
+     *             so that we can document the use case and test it.
+     */
+    @Deprecated(forRemoval = true, since = "3.25")
+    public String getAuthMechanismName(RoutingContext routingContext) {
+        AuthenticationMechanism authenticationMechanism = getAuthMechanism(routingContext);
+        if (authenticationMechanism != null) {
+            return authenticationMechanism.name();
+        }
+        return null;
     }
 
     public boolean hasNoPermissions() {
@@ -160,11 +173,11 @@ public Uni<? extends CheckResult> apply(CheckResult checkResult) {
                 });
     }
 
-    private static AuthenticationMechanisms getAuthMechanisms(RoutingContext routingContext,
+    private static AuthenticationMechanism getAuthMechanism(RoutingContext routingContext,
             ImmutablePathMatcher<List<HttpMatcher>> pathMatcher) {
         for (HttpMatcher i : findHttpMatchers(routingContext, pathMatcher)) {
-            if (i.authMechanisms != null) {
-                return i.authMechanisms;
+            if (i.authMechanism != null) {
+                return i.authMechanism;
             }
         }
         return null;
@@ -185,7 +198,7 @@ private static void addPermissionToPathMatcher(Map<String, HttpSecurityPolicy> p
         }
 
         for (String path : httpPermission.getPaths()) {
-            HttpMatcher m = new HttpMatcher(httpPermission.getAuthMechanisms(), httpPermission.getMethods(), policy);
+            HttpMatcher m = new HttpMatcher(httpPermission.getAuthMechanism(), httpPermission.getMethods(), policy);
             List<HttpMatcher> perms = new ArrayList<>();
             perms.add(m);
             builder.addPath(path, perms);
@@ -416,7 +429,7 @@ static ConfigurationException duplicateNamedPoliciesNotAllowedEx(HttpSecurityPol
                 + policy1.name() + "' is allowed, but found: " + policyClassName1 + " and " + policyClassName2);
     }
 
-    record HttpMatcher(AuthenticationMechanisms authMechanisms, Set<String> methods, HttpSecurityPolicy checker) {
+    record HttpMatcher(AuthenticationMechanism authMechanism, Set<String> methods, HttpSecurityPolicy checker) {
         private static final HttpMatcher DENY = new HttpMatcher(null, Set.of(), DenySecurityPolicy.INSTANCE);
     }
 }
diff --git a/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/HttpAuthenticator.java b/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/HttpAuthenticator.java
index e44b191ee41..b8f72da1576 100644
--- a/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/HttpAuthenticator.java
+++ b/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/HttpAuthenticator.java
@@ -2,7 +2,6 @@
 
 import static io.quarkus.security.spi.runtime.SecurityEventHelper.AUTHENTICATION_FAILURE;
 import static io.quarkus.security.spi.runtime.SecurityEventHelper.AUTHENTICATION_SUCCESS;
-import static io.quarkus.vertx.http.runtime.security.HttpSecurityConfiguration.AuthenticationMechanisms.normalizeMechanismName;
 import static io.quarkus.vertx.http.runtime.security.HttpSecurityRecorder.DefaultAuthFailureHandler.DEV_MODE_AUTHENTICATION_FAILURE_BODY;
 import static io.quarkus.vertx.http.runtime.security.HttpSecurityUtils.SECURITY_IDENTITIES_ATTRIBUTE;
 import static io.quarkus.vertx.http.runtime.security.HttpSecurityUtils.getSecurityIdentities;
@@ -10,12 +9,8 @@
 import static io.quarkus.vertx.http.runtime.security.RoutingContextAwareSecurityIdentity.addRoutingCtxToIdentityIfMissing;
 import static java.lang.Boolean.TRUE;
 
-import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
-import java.util.HashSet;
-import java.util.LinkedList;
-import java.util.List;
 import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
@@ -43,7 +38,8 @@
 import io.quarkus.security.spi.runtime.SecurityEventHelper;
 import io.quarkus.vertx.http.runtime.AuthRuntimeConfig;
 import io.quarkus.vertx.http.runtime.VertxHttpConfig;
-import io.quarkus.vertx.http.runtime.security.HttpSecurityConfiguration.AuthenticationMechanisms;
+import io.quarkus.vertx.http.runtime.security.HttpSecurityConfiguration.AuthenticationMechanism;
+import io.quarkus.vertx.http.runtime.security.annotation.BasicAuthentication;
 import io.smallrye.mutiny.Uni;
 import io.vertx.ext.web.RoutingContext;
 
@@ -72,14 +68,9 @@ public final class HttpAuthenticator {
     public static final String BASIC_AUTH_ANNOTATION_DETECTED = "io.quarkus.security.http.basic-authentication-annotation-detected";
     private static final Logger LOG = Logger.getLogger(HttpAuthenticator.class);
     /**
-     * Added to a {@link RoutingContext} as selected authentication mechanisms of type {@link AuthenticationMechanisms}.
+     * Added to a {@link RoutingContext} as selected authentication mechanism.
      */
-    private static final String SELECTED_AUTH_MECHANISMS = HttpAuthenticator.class.getName() + "#selected-auth-mechanisms";
-    /**
-     * Added to a {@link RoutingContext} as selected {@link HttpAuthenticationMechanism} instances.
-     */
-    private static final String SELECTED_AUTH_MECHANISM_INSTANCES = HttpAuthenticator.class.getName()
-            + "#selected-auth-mechanism-instances";
+    private static final String AUTH_MECHANISM = HttpAuthenticator.class.getName() + "#auth-mechanism";
     /**
      * Added to a {@link RoutingContext} when {@link this#attemptAuthentication(RoutingContext)} is invoked.
      */
@@ -88,7 +79,7 @@ public final class HttpAuthenticator {
     private final IdentityProviderManager identityProviderManager;
     private final HttpAuthenticationMechanism[] mechanisms;
     private final SecurityEventHelper<AuthenticationSuccessEvent, AuthenticationFailureEvent> securityEventHelper;
-    private final boolean globalInclusiveAuth;
+    private final boolean inclusiveAuth;
     private final boolean strictInclusiveMode;
 
     HttpAuthenticator(IdentityProviderManager identityProviderManager, Event<AuthenticationFailureEvent> authFailureEvent,
@@ -98,9 +89,9 @@ public final class HttpAuthenticator {
         this.securityEventHelper = new SecurityEventHelper<>(authSuccessEvent, authFailureEvent, AUTHENTICATION_SUCCESS,
                 AUTHENTICATION_FAILURE, beanManager, securityEventsEnabled);
         this.identityProviderManager = identityProviderManager;
-        this.globalInclusiveAuth = httpConfig.auth().inclusive();
+        this.inclusiveAuth = httpConfig.auth().inclusive();
         this.strictInclusiveMode = httpConfig.auth().inclusiveMode() == AuthRuntimeConfig.InclusiveMode.STRICT;
-        this.mechanisms = HttpSecurityConfiguration.get().getMechanisms(providers, globalInclusiveAuth);
+        this.mechanisms = HttpSecurityConfiguration.get().getMechanisms(providers, inclusiveAuth);
     }
 
     public IdentityProviderManager getIdentityProviderManager() {
@@ -124,29 +115,50 @@ public Uni<SecurityIdentity> attemptAuthentication(RoutingContext routingContext
             rememberAuthAttempted(routingContext);
         }
 
-        // determine whether user selected path specific mechanisms via HTTP Security policy or annotation
-        final AuthenticationMechanisms pathSpecificMechanisms;
-        if (selectAuthMechanismWithAnnotation && areAuthMechanismsSelected(routingContext)) {
-            pathSpecificMechanisms = getSelectedAuthMechanisms(routingContext);
+        // determine whether user selected path specific mechanism via HTTP Security policy or annotation
+        final AuthenticationMechanism pathSpecificMechanism;
+        if (selectAuthMechanismWithAnnotation && isAuthMechanismSelected(routingContext)) {
+            pathSpecificMechanism = getAuthMechanism(routingContext);
         } else {
             AbstractPathMatchingHttpSecurityPolicy pathMatchingPolicy = routingContext
                     .get(AbstractPathMatchingHttpSecurityPolicy.class.getName());
-            pathSpecificMechanisms = pathMatchingPolicy != null ? pathMatchingPolicy.getAuthMechanisms(routingContext) : null;
+            pathSpecificMechanism = pathMatchingPolicy != null ? pathMatchingPolicy.getAuthMechanism(routingContext) : null;
         }
 
         // authenticate
         Uni<SecurityIdentity> result;
-        if (pathSpecificMechanisms == null) {
-            result = createAndValidateSecurityIdentity(routingContext, mechanisms, identityProviderManager, globalInclusiveAuth,
-                    strictInclusiveMode, mechanisms.length);
+        if (pathSpecificMechanism == null) {
+            result = createSecurityIdentity(routingContext, 0);
         } else {
-            result = findBestCandidateMechanisms(routingContext, 0, new HashSet<>(pathSpecificMechanisms.names()),
-                    new LinkedList<>()).onItem().ifNotNull()
-                    .transformToUni(new Function<HttpAuthenticationMechanism[], Uni<? extends SecurityIdentity>>() {
+            result = findBestCandidateMechanism(routingContext, pathSpecificMechanism).onItem().ifNotNull()
+                    .transformToUni(new Function<HttpAuthenticationMechanism, Uni<? extends SecurityIdentity>>() {
                         @Override
-                        public Uni<SecurityIdentity> apply(HttpAuthenticationMechanism[] candidates) {
-                            return createAndValidateSecurityIdentity(routingContext, candidates, identityProviderManager,
-                                    globalInclusiveAuth, strictInclusiveMode, pathSpecificMechanisms.names().size());
+                        public Uni<SecurityIdentity> apply(HttpAuthenticationMechanism mech) {
+                            return mech.authenticate(routingContext, identityProviderManager);
+                        }
+                    });
+        }
+
+        if (inclusiveAuth && strictInclusiveMode && pathSpecificMechanism == null) {
+            // inclusive authentication in the strict mode requires that all registered mechanisms created identity
+            // if at least one of them created it (AKA: if identity is not null, null results in anonymous identity)
+            // inclusive authentication is not applied when path-specific mechanism has been selected (because there
+            // user said use 'xyz' mechanism, not all the mechanisms)
+            result = result.onItem().ifNotNull()
+                    .transformToUni(new Function<SecurityIdentity, Uni<? extends SecurityIdentity>>() {
+                        @Override
+                        public Uni<? extends SecurityIdentity> apply(SecurityIdentity identity) {
+                            Map<String, SecurityIdentity> identities = HttpSecurityUtils.getSecurityIdentities(routingContext);
+                            if (identities == null || identities.size() != mechanisms.length) {
+                                return Uni.createFrom().failure(new AuthenticationFailedException(
+                                        """
+                                                There is '%d' HTTP authentication mechanisms, however only '%d' authentication mechanisms
+                                                created identity: %s
+                                                """
+                                                .formatted(identities == null ? 0 : identities.size(), mechanisms.length,
+                                                        identities == null ? "" : identities.keySet())));
+                            }
+                            return Uni.createFrom().item(identity);
                         }
                     });
         }
@@ -178,37 +190,7 @@ public void accept(SecurityIdentity securityIdentity) {
         return result;
     }
 
-    private static Uni<SecurityIdentity> createAndValidateSecurityIdentity(RoutingContext routingContext,
-            HttpAuthenticationMechanism[] mechanisms, IdentityProviderManager identityProviderManager, boolean inclusiveAuth,
-            boolean strictInclusiveMode, int expectedIdentitiesCount) {
-        if (inclusiveAuth && strictInclusiveMode) {
-            // inclusive authentication in the strict mode requires that all selected mechanisms created identity
-            // if at least one of them created it (AKA: if identity is not null, null results in anonymous identity)
-            return createSecurityIdentity(routingContext, 0, mechanisms, identityProviderManager, true)
-                    .onItem().ifNotNull()
-                    .transformToUni(new Function<SecurityIdentity, Uni<? extends SecurityIdentity>>() {
-                        @Override
-                        public Uni<? extends SecurityIdentity> apply(SecurityIdentity identity) {
-                            Map<String, SecurityIdentity> identities = HttpSecurityUtils.getSecurityIdentities(routingContext);
-                            if (identities == null || identities.size() != expectedIdentitiesCount) {
-                                return Uni.createFrom().failure(new AuthenticationFailedException(
-                                        """
-                                                There is '%d' selected HTTP authentication mechanisms, however only '%d'
-                                                authentication mechanisms created identity: %s
-                                                """
-                                                .formatted(expectedIdentitiesCount, identities == null ? 0 : identities.size(),
-                                                        identities == null ? "" : identities.keySet())));
-                            }
-                            return Uni.createFrom().item(identity);
-                        }
-                    });
-        } else {
-            return createSecurityIdentity(routingContext, 0, mechanisms, identityProviderManager, inclusiveAuth);
-        }
-    }
-
-    private static Uni<SecurityIdentity> createSecurityIdentity(RoutingContext routingContext, int i,
-            HttpAuthenticationMechanism[] mechanisms, IdentityProviderManager identityProviderManager, boolean inclusiveAuth) {
+    private Uni<SecurityIdentity> createSecurityIdentity(RoutingContext routingContext, int i) {
         if (i == mechanisms.length) {
             return Uni.createFrom().nullItem();
         }
@@ -218,19 +200,14 @@ private static Uni<SecurityIdentity> createSecurityIdentity(RoutingContext routi
                     public Uni<SecurityIdentity> apply(SecurityIdentity identity) {
                         if (identity != null) {
                             if (inclusiveAuth) {
-                                return authenticateWithAllMechanisms(identity, i, routingContext, mechanisms,
-                                        identityProviderManager);
+                                return authenticateWithAllMechanisms(identity, i, routingContext);
                             }
-                            if (selectAuthMechanismWithAnnotation && !areAuthMechanismsSelected(routingContext)) {
-                                // this is done so that we can recognize if authentication happened before
-                                // the mechanism was selected with the annotation, however, the authentication happened
-                                // using the correct mechanism, therefore it is not illegal state (we can be lenient)
-                                return rememberSelectedAuthMechScheme(mechanisms[i], routingContext).replaceWith(identity);
+                            if (selectAuthMechanismWithAnnotation && !isAuthMechanismSelected(routingContext)) {
+                                return rememberAuthMechScheme(mechanisms[i], routingContext).replaceWith(identity);
                             }
                             return Uni.createFrom().item(identity);
                         }
-                        return createSecurityIdentity(routingContext, i + 1, mechanisms, identityProviderManager,
-                                inclusiveAuth);
+                        return createSecurityIdentity(routingContext, i + 1);
                     }
                 });
     }
@@ -245,20 +222,30 @@ public Uni<Boolean> sendChallenge(RoutingContext routingContext) {
         if (!routingContext.request().isEnded()) {
             routingContext.request().resume();
         }
+        Uni<Boolean> result = null;
 
-        HttpAuthenticationMechanism[] challengeMechanisms = getChallengeMechanisms(routingContext);
-        Uni<Boolean> result = challengeMechanisms[0].sendChallenge(routingContext);
-        for (int i = 1; i < challengeMechanisms.length; ++i) {
-            HttpAuthenticationMechanism mech = challengeMechanisms[i];
-            result = result.onItem().transformToUni(new Function<Boolean, Uni<? extends Boolean>>() {
-                @Override
-                public Uni<? extends Boolean> apply(Boolean authDone) {
-                    if (Boolean.TRUE.equals(authDone)) {
-                        return Uni.createFrom().item(true);
+        // we only require auth mechanism to put itself into routing context when there is more than one mechanism registered
+        if (mechanisms.length > 1) {
+            HttpAuthenticationMechanism matchingMech = routingContext.get(HttpAuthenticationMechanism.class.getName());
+            if (matchingMech != null) {
+                result = matchingMech.sendChallenge(routingContext);
+            }
+        }
+
+        if (result == null) {
+            result = mechanisms[0].sendChallenge(routingContext);
+            for (int i = 1; i < mechanisms.length; ++i) {
+                HttpAuthenticationMechanism mech = mechanisms[i];
+                result = result.onItem().transformToUni(new Function<Boolean, Uni<? extends Boolean>>() {
+                    @Override
+                    public Uni<? extends Boolean> apply(Boolean authDone) {
+                        if (authDone) {
+                            return Uni.createFrom().item(authDone);
+                        }
+                        return mech.sendChallenge(routingContext);
                     }
-                    return mech.sendChallenge(routingContext);
-                }
-            });
+                });
+            }
         }
         return result.onItem().transformToUni(new Function<Boolean, Uni<? extends Boolean>>() {
             @Override
@@ -279,10 +266,16 @@ public Uni<? extends Boolean> apply(Boolean authDone) {
     }
 
     public Uni<ChallengeData> getChallenge(RoutingContext routingContext) {
-        HttpAuthenticationMechanism[] challengeMechanisms = getChallengeMechanisms(routingContext);
-        Uni<ChallengeData> result = challengeMechanisms[0].getChallenge(routingContext);
-        for (int i = 1; i < challengeMechanisms.length; ++i) {
-            HttpAuthenticationMechanism mech = challengeMechanisms[i];
+        // we only require auth mechanism to put itself into routing context when there is more than one mechanism registered
+        if (mechanisms.length > 1) {
+            HttpAuthenticationMechanism matchingMech = routingContext.get(HttpAuthenticationMechanism.class.getName());
+            if (matchingMech != null) {
+                return matchingMech.getChallenge(routingContext);
+            }
+        }
+        Uni<ChallengeData> result = mechanisms[0].getChallenge(routingContext);
+        for (int i = 1; i < mechanisms.length; ++i) {
+            HttpAuthenticationMechanism mech = mechanisms[i];
             result = result.onItem().transformToUni(new Function<ChallengeData, Uni<? extends ChallengeData>>() {
                 @Override
                 public Uni<? extends ChallengeData> apply(ChallengeData data) {
@@ -297,39 +290,8 @@ public Uni<? extends ChallengeData> apply(ChallengeData data) {
         return result;
     }
 
-    private HttpAuthenticationMechanism[] getChallengeMechanisms(RoutingContext routingContext) {
-        HttpAuthenticationMechanism[] challengeMechanisms;
-
-        // this is mechanism that added itself to the RoutingContext last in one of following situations:
-        // - it started to authenticate using this HTTP authenticator and authentication failed or redirect is needed
-        // - some mechanisms can be used directly without this HttpAuthenticator instance
-        //   like when user calls form-based mechanism's post location
-        // - someone can invoke challenge even if authentication succeeded, but we don't expect that to happen
-        HttpAuthenticationMechanism directlyUsedAuthenticationMechanism = routingContext
-                .get(HttpAuthenticationMechanism.class.getName());
-
-        if (directlyUsedAuthenticationMechanism != null) {
-
-            challengeMechanisms = new HttpAuthenticationMechanism[] { directlyUsedAuthenticationMechanism };
-        } else {
-            // either no authentication mechanism provided a SecurityIdentity, or some custom mechanism
-            // provided it, but did not add itself into the RoutingContext
-
-            // path-specific mechanisms
-            challengeMechanisms = getSelectedAuthMechanismInstances(routingContext);
-
-            if (challengeMechanisms == null) {
-                // if no path-specific mechanism was selected, we use all the authentication mechanisms
-                challengeMechanisms = mechanisms;
-            }
-        }
-
-        return challengeMechanisms;
-    }
-
-    private static Uni<SecurityIdentity> authenticateWithAllMechanisms(SecurityIdentity identity, int i,
-            RoutingContext routingContext, HttpAuthenticationMechanism[] mechanisms,
-            IdentityProviderManager identityProviderManager) {
+    private Uni<SecurityIdentity> authenticateWithAllMechanisms(SecurityIdentity identity, int i,
+            RoutingContext routingContext) {
         return mechanisms[i].getCredentialTransport(routingContext)
                 .onItem().transformToUni(new Function<HttpCredentialTransport, Uni<? extends SecurityIdentity>>() {
                     @Override
@@ -342,7 +304,6 @@ public Uni<SecurityIdentity> apply(HttpCredentialTransport httpCredentialTranspo
                             return Uni.createFrom().failure(new AuthenticationFailedException());
                         }
                         var authMechanism = httpCredentialTransport.getAuthenticationScheme();
-                        rememberSelectedAuthMechanism(routingContext, authMechanism);
 
                         // add current identity to the RoutingContext
                         var authMechToIdentity = getSecurityIdentities(routingContext);
@@ -355,49 +316,53 @@ public Uni<SecurityIdentity> apply(HttpCredentialTransport httpCredentialTranspo
 
                         // authenticate with remaining mechanisms
                         if (isFirstIdentity) {
-                            return createSecurityIdentity(routingContext, i + 1, mechanisms, identityProviderManager, true)
+                            return createSecurityIdentity(routingContext, i + 1)
                                     .replaceWith(addRoutingCtxToIdentityIfMissing(identity, routingContext));
                         } else {
-                            return createSecurityIdentity(routingContext, i + 1, mechanisms, identityProviderManager, true);
+                            return createSecurityIdentity(routingContext, i + 1);
                         }
                     }
                 });
     }
 
-    private Uni<HttpAuthenticationMechanism[]> findBestCandidateMechanisms(RoutingContext routingContext, int i,
-            Set<String> mechanismsToFind, List<HttpAuthenticationMechanism> foundSelectedMechanisms) {
+    private Uni<HttpAuthenticationMechanism> findBestCandidateMechanism(RoutingContext routingContext,
+            AuthenticationMechanism pathSpecificMechanism) {
+        if (pathSpecificMechanism.instance() != null) {
+            rememberAuthMechanism(routingContext, pathSpecificMechanism);
+            return Uni.createFrom().item(pathSpecificMechanism.instance());
+        }
+        return findBestCandidateMechanism(routingContext, pathSpecificMechanism.name(), 0);
+    }
+
+    private Uni<HttpAuthenticationMechanism> findBestCandidateMechanism(RoutingContext routingContext,
+            String pathSpecificMechanism, int i) {
         if (i == mechanisms.length) {
-            if (foundSelectedMechanisms.isEmpty()) {
-                return Uni.createFrom().nullItem();
-            }
-            return Uni.createFrom().item(foundSelectedMechanisms.toArray(HttpAuthenticationMechanism[]::new));
+            return Uni.createFrom().nullItem();
         }
-        return getPathSpecificMechanism(i, routingContext, mechanismsToFind).flatMap(
-                new Function<HttpAuthenticationMechanism, Uni<? extends HttpAuthenticationMechanism[]>>() {
+        return getPathSpecificMechanism(i, routingContext, pathSpecificMechanism).onItem().transformToUni(
+                new Function<HttpAuthenticationMechanism, Uni<? extends HttpAuthenticationMechanism>>() {
                     @Override
-                    public Uni<? extends HttpAuthenticationMechanism[]> apply(HttpAuthenticationMechanism mech) {
+                    public Uni<? extends HttpAuthenticationMechanism> apply(HttpAuthenticationMechanism mech) {
                         if (mech != null) {
-                            foundSelectedMechanisms.add(mech);
-                            if (mechanismsToFind.isEmpty()) {
-                                return Uni.createFrom()
-                                        .item(foundSelectedMechanisms.toArray(HttpAuthenticationMechanism[]::new));
+                            if (selectAuthMechanismWithAnnotation && !isAuthMechanismSelected(routingContext)) {
+                                return rememberAuthMechScheme(mech, routingContext).replaceWith(mech);
                             }
+                            return Uni.createFrom().item(mech);
                         }
-                        return findBestCandidateMechanisms(routingContext, i + 1, mechanismsToFind, foundSelectedMechanisms);
+                        return findBestCandidateMechanism(routingContext, pathSpecificMechanism, i + 1);
                     }
                 });
     }
 
     private Uni<HttpAuthenticationMechanism> getPathSpecificMechanism(int index, RoutingContext routingContext,
-            Set<String> mechanismsToFind) {
+            String pathSpecificMechanism) {
         return mechanisms[index].getCredentialTransport(routingContext).onItem()
                 .transform(new Function<HttpCredentialTransport, HttpAuthenticationMechanism>() {
                     @Override
                     public HttpAuthenticationMechanism apply(HttpCredentialTransport t) {
-                        if (t != null && mechanismsToFind.contains(normalizeMechanismName(t.getAuthenticationScheme()))) {
-                            addSelectedAuthMechanismInstance(mechanisms[index], routingContext);
-                            rememberSelectedAuthMechanism(routingContext, t.getAuthenticationScheme());
-                            mechanismsToFind.remove(t.getAuthenticationScheme());
+                        if (t != null && t.getAuthenticationScheme().equalsIgnoreCase(pathSpecificMechanism)) {
+                            routingContext.put(HttpAuthenticationMechanism.class.getName(), mechanisms[index]);
+                            rememberAuthMechanism(routingContext, t.getAuthenticationScheme());
                             return mechanisms[index];
                         }
                         return null;
@@ -410,55 +375,45 @@ static void selectAuthMechanismWithAnnotation() {
     }
 
     static void selectAuthMechanism(RoutingContext routingContext, String authMechanism) {
-        if (authenticationAlreadyAttempted(routingContext, authMechanism)) {
-            AuthenticationMechanisms authenticationMechanisms = getSelectedAuthMechanisms(routingContext);
-            final String previousMechanisms;
-            if (authenticationMechanisms != null) {
-                previousMechanisms = authenticationMechanisms.names().toString();
+        if (requestAlreadyAuthenticated(routingContext, authMechanism)) {
+            AuthenticationMechanism authenticationMechanism = getAuthMechanism(routingContext);
+            final String previousMechanism;
+            if (authenticationMechanism != null) {
+                if (authenticationMechanism.name() != null) {
+                    previousMechanism = authenticationMechanism.name();
+                } else {
+                    previousMechanism = ClientProxy.unwrap(authenticationMechanism.instance()).getClass().getName();
+                }
             } else {
-                previousMechanisms = "";
+                previousMechanism = null;
             }
             throw new AuthenticationFailedException("""
                     The '%1$s' authentication mechanism is required to authenticate the request but it was already
-                    authenticated with the '%2$s' authentication mechanisms.
-                    It can happen if the '%1$s' is selected with an annotation but '%2$s' are activated by
-                    the HTTP security policy which is enforced before the JAX-RS chain is run. In such cases, please
-                    set the 'quarkus.http.auth.permission."permissions".applies-to=JAXRS' to all HTTP security policies
+                    authenticated with the '%2$s' authentication mechanism. It can happen if the '%1$s' is selected with
+                    an annotation but '%2$s' is activated by the HTTP security policy which is enforced before
+                    the JAX-RS chain is run. In such cases, please set the
+                    'quarkus.http.auth.permission."permissions".applies-to=JAXRS' to all HTTP security policies
                     which secure the same REST endpoints as the ones secured by the '%1$s' authentication mechanism
                     selected with the annotation.
-                    """.formatted(authMechanism, previousMechanisms));
+                    """.formatted(authMechanism, previousMechanism));
         }
-        rememberSelectedAuthMechanism(routingContext, authMechanism);
+        rememberAuthMechanism(routingContext, authMechanism);
     }
 
     private static void rememberAuthAttempted(RoutingContext routingContext) {
         routingContext.put(ATTEMPT_AUTH_INVOKED, TRUE);
     }
 
-    private static boolean areAuthMechanismsSelected(RoutingContext routingContext) {
-        return getSelectedAuthMechanisms(routingContext) != null;
+    private static boolean isAuthMechanismSelected(RoutingContext routingContext) {
+        return getAuthMechanism(routingContext) != null;
     }
 
-    private static boolean authenticationAlreadyAttempted(RoutingContext event, String newAuthMechanism) {
-        return event.get(ATTEMPT_AUTH_INVOKED) == TRUE
-                && authenticationAttemptedWithDifferentRequirements(newAuthMechanism, event);
+    private static boolean requestAlreadyAuthenticated(RoutingContext event, String newAuthMechanism) {
+        return event.get(ATTEMPT_AUTH_INVOKED) == TRUE && authenticatedWithDifferentAuthMechanism(newAuthMechanism, event);
     }
 
-    private static boolean authenticationAttemptedWithDifferentRequirements(String newAuthMechanism, RoutingContext event) {
-        // this is configured used for the previous attempt, we require that this is identical to what is selected
-        // by the annotation
-        AuthenticationMechanisms selectedAuthenticationMechanisms = getSelectedAuthMechanisms(event);
-
-        if (selectedAuthenticationMechanisms != null) {
-            // for now, users can only select one mechanism with the annotation, hence, the previous
-            // authentication attempt must be identical in every way
-            if (selectedAuthenticationMechanisms.names().size() == 1
-                    && selectedAuthenticationMechanisms.names().contains(normalizeMechanismName(newAuthMechanism))) {
-                return false;
-            }
-        }
-
-        return true;
+    private static boolean authenticatedWithDifferentAuthMechanism(String newAuthMechanism, RoutingContext event) {
+        return !newAuthMechanism.equalsIgnoreCase(getAuthMechanismScheme(event));
     }
 
     /**
@@ -466,62 +421,40 @@ private static boolean authenticationAttemptedWithDifferentRequirements(String n
      * in case that someone tries to change the mechanism after the authentication. This way, we can be permissive
      * when the selected mechanism is same as the one already used.
      */
-    private static Uni<HttpCredentialTransport> rememberSelectedAuthMechScheme(HttpAuthenticationMechanism mech,
-            RoutingContext event) {
+    private static Uni<HttpCredentialTransport> rememberAuthMechScheme(HttpAuthenticationMechanism mech, RoutingContext event) {
         return mech.getCredentialTransport(event)
                 .onItem().ifNotNull().invoke(new Consumer<HttpCredentialTransport>() {
                     @Override
                     public void accept(HttpCredentialTransport t) {
                         if (t.getAuthenticationScheme() != null) {
-                            rememberSelectedAuthMechanism(event, t.getAuthenticationScheme());
+                            rememberAuthMechanism(event, t.getAuthenticationScheme());
                         }
                     }
                 });
     }
 
-    private static void rememberSelectedAuthMechanism(RoutingContext event, String newAuthMechanism) {
-        AuthenticationMechanisms currentMechanisms = getSelectedAuthMechanisms(event);
-        if (currentMechanisms == null) {
-            event.put(SELECTED_AUTH_MECHANISMS, new AuthenticationMechanisms(newAuthMechanism));
-        } else {
-            event.put(SELECTED_AUTH_MECHANISMS, currentMechanisms.with(newAuthMechanism));
-        }
+    private static void rememberAuthMechanism(RoutingContext event, AuthenticationMechanism newAuthMechanism) {
+        event.put(AUTH_MECHANISM, newAuthMechanism);
+        event.put(HttpAuthenticationMechanism.class.getName(), newAuthMechanism.instance());
     }
 
-    private static AuthenticationMechanisms getSelectedAuthMechanisms(RoutingContext event) {
-        return event.get(SELECTED_AUTH_MECHANISMS);
+    private static void rememberAuthMechanism(RoutingContext event, String newAuthMechanism) {
+        event.put(AUTH_MECHANISM, new AuthenticationMechanism(newAuthMechanism, null));
     }
 
-    private static HttpAuthenticationMechanism[] getSelectedAuthMechanismInstances(RoutingContext event) {
-        return getMechanismsFromContext(event, SELECTED_AUTH_MECHANISM_INSTANCES);
-    }
-
-    private static void addSelectedAuthMechanismInstance(HttpAuthenticationMechanism httpAuthenticationMechanism,
-            RoutingContext routingContext) {
-        addMechanismToRoutingContext(httpAuthenticationMechanism, routingContext, SELECTED_AUTH_MECHANISM_INSTANCES);
-    }
-
-    private static void addMechanismToRoutingContext(HttpAuthenticationMechanism httpAuthenticationMechanism,
-            RoutingContext routingContext, String selectedAuthMechanismInstances) {
-        List<HttpAuthenticationMechanism> mechanisms = routingContext.get(selectedAuthMechanismInstances);
-        if (mechanisms == null) {
-            mechanisms = new ArrayList<>();
-            routingContext.put(selectedAuthMechanismInstances, mechanisms);
-        }
-        if (!mechanisms.contains(httpAuthenticationMechanism)) {
-            mechanisms.add(httpAuthenticationMechanism);
-        }
+    private static AuthenticationMechanism getAuthMechanism(RoutingContext event) {
+        return event.get(AUTH_MECHANISM);
     }
 
-    private static HttpAuthenticationMechanism[] getMechanismsFromContext(RoutingContext event, String mechanismsKey) {
-        List<HttpAuthenticationMechanism> selectedInstances = event.get(mechanismsKey);
-        if (selectedInstances == null || selectedInstances.isEmpty()) {
-            return null;
+    private static String getAuthMechanismScheme(RoutingContext event) {
+        AuthenticationMechanism authenticationMechanism = getAuthMechanism(event);
+        if (authenticationMechanism != null) {
+            return authenticationMechanism.name();
         }
-        return selectedInstances.toArray(HttpAuthenticationMechanism[]::new);
+        return null;
     }
 
-    static final class NoAuthenticationMechanism implements HttpAuthenticationMechanism {
+    static class NoAuthenticationMechanism implements HttpAuthenticationMechanism {
 
         @Override
         public Uni<SecurityIdentity> authenticate(RoutingContext context,
diff --git a/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/HttpSecurityConfiguration.java b/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/HttpSecurityConfiguration.java
index aa6e95a1fff..75e80c6e091 100644
--- a/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/HttpSecurityConfiguration.java
+++ b/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/HttpSecurityConfiguration.java
@@ -5,17 +5,12 @@
 import static io.quarkus.vertx.http.runtime.security.HttpAuthenticator.TEST_IF_BASIC_AUTH_IMPLICITLY_REQUIRED;
 
 import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
 import java.util.Comparator;
-import java.util.HashSet;
 import java.util.List;
-import java.util.Locale;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Optional;
 import java.util.Set;
-import java.util.stream.Collectors;
 
 import jakarta.enterprise.event.Event;
 import jakarta.enterprise.inject.Instance;
@@ -80,41 +75,7 @@ private HttpSecurityConfiguration(RolesMapping rolesMapping, List<HttpPermission
     record Policy(String name, HttpSecurityPolicy instance) {
     }
 
-    record AuthenticationMechanisms(Set<String> names) {
-
-        AuthenticationMechanisms(String... names) {
-            this(normalizeNames(names));
-        }
-
-        AuthenticationMechanisms with(String newName) {
-            var newNames = new HashSet<>(names);
-            newNames.add(normalizeMechanismName(newName));
-            return new AuthenticationMechanisms(Collections.unmodifiableSet(newNames));
-        }
-
-        /**
-         * Unlike the default constructor, this factory method normalizes given mechanism names.
-         *
-         * @param names authentication mechanism names
-         * @return new AuthenticationMechanisms
-         */
-        static AuthenticationMechanisms from(Set<String> names) {
-            return new AuthenticationMechanisms(names.stream().map(AuthenticationMechanisms::normalizeMechanismName)
-                    .collect(Collectors.toUnmodifiableSet()));
-        }
-
-        static String normalizeMechanismName(String mechanismName) {
-            if (mechanismName == null) {
-                return "";
-            }
-            return mechanismName.toLowerCase(Locale.ROOT);
-        }
-
-        private static Set<String> normalizeNames(String[] names) {
-            return names.length == 1 ? Set.of(normalizeMechanismName(names[0]))
-                    : Arrays.stream(names).map(AuthenticationMechanisms::normalizeMechanismName)
-                            .collect(Collectors.toUnmodifiableSet());
-        }
+    record AuthenticationMechanism(String name, HttpAuthenticationMechanism instance) {
     }
 
     interface HttpPermissionCarrier {
@@ -127,7 +88,7 @@ interface HttpPermissionCarrier {
 
         Set<String> getMethods();
 
-        AuthenticationMechanisms getAuthMechanisms();
+        AuthenticationMechanism getAuthMechanism();
 
         Policy getPolicy();
 
@@ -343,11 +304,11 @@ public Set<String> getMethods() {
             }
 
             @Override
-            public AuthenticationMechanisms getAuthMechanisms() {
+            public AuthenticationMechanism getAuthMechanism() {
                 if (mapping.authMechanism().isPresent()) {
-                    var mechanisms = mapping.authMechanism().get();
-                    if (!mechanisms.isEmpty()) {
-                        return AuthenticationMechanisms.from(mechanisms);
+                    String authMech = mapping.authMechanism().get();
+                    if (!authMech.isEmpty()) {
+                        return new AuthenticationMechanism(authMech, null);
                     }
                 }
                 return null;
@@ -438,8 +399,8 @@ private boolean isBasicAuthNotRequired() {
             return false;
         }
         for (var permission : httpPermissions) {
-            if (permission.getAuthMechanisms() != null
-                    && permission.getAuthMechanisms().names().contains(BasicAuthentication.AUTH_MECHANISM_SCHEME)) {
+            if (permission.getAuthMechanism() != null
+                    && BasicAuthentication.AUTH_MECHANISM_SCHEME.equals(permission.getAuthMechanism().name())) {
                 return false;
             }
         }
diff --git a/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/HttpSecurityImpl.java b/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/HttpSecurityImpl.java
index b8c2dd6e02a..4c1953e4eb9 100644
--- a/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/HttpSecurityImpl.java
+++ b/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/HttpSecurityImpl.java
@@ -372,7 +372,7 @@ private final class HttpPermissionImpl implements HttpPermission, HttpPermission
         private boolean shared;
         private boolean applyToJaxRs;
         private String[] methods;
-        private HttpSecurityConfiguration.AuthenticationMechanisms authMechanism;
+        private HttpSecurityConfiguration.AuthenticationMechanism authMechanism;
         private AuthorizationPolicy authorizationPolicy;
 
         private HttpPermissionImpl(String[] paths) {
@@ -453,18 +453,7 @@ public HttpPermission authenticatedWith(String mechanism) {
             if (mechanism == null || mechanism.isBlank()) {
                 throw new IllegalArgumentException("Authentication mechanism must not be null or blank");
             }
-            this.authMechanism = new HttpSecurityConfiguration.AuthenticationMechanisms(mechanism);
-            return this;
-        }
-
-        @Override
-        public HttpPermission authenticatedWith(Set<String> schemes) {
-            validateAuthenticationNotSetYet();
-            requireAuthenticationByDefault();
-            if (schemes == null || schemes.isEmpty()) {
-                throw new IllegalArgumentException("Authentication mechanism must not be null or emptz");
-            }
-            this.authMechanism = HttpSecurityConfiguration.AuthenticationMechanisms.from(schemes);
+            this.authMechanism = new HttpSecurityConfiguration.AuthenticationMechanism(mechanism, null);
             return this;
         }
 
@@ -532,7 +521,7 @@ public Set<String> getMethods() {
         }
 
         @Override
-        public HttpSecurityConfiguration.AuthenticationMechanisms getAuthMechanisms() {
+        public HttpSecurityConfiguration.AuthenticationMechanism getAuthMechanism() {
             return authMechanism;
         }
 
diff --git a/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/JaxRsPathMatchingHttpSecurityPolicy.java b/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/JaxRsPathMatchingHttpSecurityPolicy.java
index 1e647b1906b..0566ba36577 100644
--- a/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/JaxRsPathMatchingHttpSecurityPolicy.java
+++ b/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/JaxRsPathMatchingHttpSecurityPolicy.java
@@ -8,7 +8,6 @@
 
 import jakarta.enterprise.inject.Instance;
 
-import io.quarkus.runtime.configuration.ConfigurationException;
 import io.quarkus.security.identity.SecurityIdentity;
 import io.quarkus.security.spi.runtime.BlockingSecurityExecutor;
 import io.quarkus.security.spi.runtime.MethodDescription;
@@ -73,18 +72,6 @@ public class JaxRsPathMatchingHttpSecurityPolicy {
             }
             policyNameToPolicy = Map.copyOf(annotationPoliciesOnly);
         }
-        for (var httpPermission : HttpSecurityConfiguration.get().httpPermissions()) {
-            if (httpPermission.shouldApplyToJaxRs() && httpPermission.getAuthMechanisms() != null) {
-                // HTTP authentication mechanism is selected by HTTP authenticator that
-                // uses the AbstractPathMatchingHttpSecurityPolicy in the RoutingContext
-                // we cannot support this without bigger refactoring and the whole point of JAX-RS policy was to support
-                // the authentication annotations like @BasicAuthentication, so it doesn't make sense to support it
-                throw new ConfigurationException("""
-                        HttpSecurityPolicy that applies to JAXRS can be effective only after an authentication process
-                        has completed, therefore this policy can not be used to select '%s' authentication mechanism
-                        """.formatted(httpPermission.getAuthMechanisms().names()));
-            }
-        }
     }
 
     /**
diff --git a/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/security/HttpSecurity.java b/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/security/HttpSecurity.java
index e095f765f88..fc1c2688696 100644
--- a/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/security/HttpSecurity.java
+++ b/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/security/HttpSecurity.java
@@ -287,17 +287,10 @@ interface HttpPermission {
         /**
          * HTTP request must be authenticated using a mechanism
          * with matching {@link HttpCredentialTransport#getAuthenticationScheme()}.
+         * Please note that annotation-based mechanism selection has higher priority during the mechanism selection.
          */
         HttpPermission authenticatedWith(String scheme);
 
-        /**
-         * HTTP request must be authenticated using mechanisms with matching
-         * {@link HttpCredentialTransport#getAuthenticationScheme()}. By default, only one of the matching authentication
-         * mechanisms will produce a {@link SecurityIdentity}, and all matching authentication mechanisms will attempt
-         * to authenticate when an inclusive authentication is enabled.
-         */
-        HttpPermission authenticatedWith(Set<String> schemes);
-
         /**
          * Indicates that this policy always applies to the matched paths in addition to the policy with a winning path.
          * Programmatic analogy to the 'quarkus.http.auth.permission."permissions".shared' configuration property.
