diff --git a/docs/src/main/asciidoc/security-authentication-mechanisms.adoc b/docs/src/main/asciidoc/security-authentication-mechanisms.adoc
index 8adf472ab19..c6aa25b5d96 100644
--- a/docs/src/main/asciidoc/security-authentication-mechanisms.adoc
+++ b/docs/src/main/asciidoc/security-authentication-mechanisms.adoc
@@ -986,10 +986,15 @@ quarkus.http.auth.permission.bearer.auth-mechanism=bearer
 quarkus.http.auth.permission.custom.paths=/hello/custom <3>
 quarkus.http.auth.permission.custom.policy=authenticated
 quarkus.http.auth.permission.custom.auth-mechanism=custom
+
+quarkus.http.auth.permission.basic-bearer.paths=/hello/basic-bearer <4>
+quarkus.http.auth.permission.basic-bearer.policy=authenticated
+quarkus.http.auth.permission.basic-bearer.auth-mechanism=basic,bearer
 ----
 <1> The REST endpoint `/hello/basic` can only ever be accessed by using the <<basic-auth>>.
 <2> The REST endpoint `/hello/bearer` can only ever be accessed by using the xref:security-oidc-bearer-token-authentication.adoc[OIDC bearer token authentication mechanism].
 <3> The REST endpoint `/hello/custom` can only ever be accessed by using a custom `HttpAuthenticationMechanism` with a `custom` authentication scheme.
+<4> The REST endpoint `/hello/basic-bearer` can be accessed either by using the xref:security-oidc-bearer-token-authentication.adoc[OIDC bearer token authentication mechanism], or by using the <<basic-auth>>.
 
 [IMPORTANT]
 ====
@@ -997,6 +1002,36 @@ Ensure that the value of the `auth-mechanism` property matches the authenticatio
 For example, for the `quarkus.http.auth.permission.custom.auth-mechanism=custom` expression to be effective, a custom `HttpAuthenticationMechanism` implementation must set its authentication scheme to `custom` in its `HttpAuthenticationMechanism#getCredentialTransport` method implementation.
 ====
 
+==== Use HTTP Security Policy inclusive path-based authentication
+
+When an <<inclusive-authentication, inclusive authentication>> is enabled in a `strict` mode, every selected authentication mechanism must provide the `SecurityIdentity`.
+For example:
+
+[source,properties]
+----
+quarkus.http.auth.inclusive=true
+
+quarkus.http.auth.permission.basic-bearer.paths=/hello/basic-bearer
+quarkus.http.auth.permission.basic-bearer.policy=authenticated
+quarkus.http.auth.permission.basic-bearer.auth-mechanism=basic,bearer   <1>
+----
+<1> The REST endpoint `/hello/basic-bearer` can be accessed only if both the xref:security-oidc-bearer-token-authentication.adoc[OIDC bearer token authentication mechanism] and the <<basic-auth>> have successfully provided `SecurityIdentity`.
+
+When an <<inclusive-authentication, inclusive authentication>> is enabled in a `lax` mode, every selected authentication mechanism will have a chance to provide its own `SecurityIdentity`, with at least one of the mechanisms expected to produce `SecurityIdentity`.
+Consider the following example:
+
+[source,properties]
+----
+quarkus.http.auth.inclusive=true
+quarkus.http.auth.inclusive-mode=lax
+
+quarkus.http.auth.permission.basic-bearer.paths=/hello/basic-bearer
+quarkus.http.auth.permission.basic-bearer.policy=authenticated
+quarkus.http.auth.permission.basic-bearer.auth-mechanism=basic,bearer   <1>
+----
+<1> The REST endpoint `/hello/basic-bearer` uses both the xref:security-oidc-bearer-token-authentication.adoc[OIDC bearer token authentication mechanism] and the <<basic-auth>>.
+Access is granted if at least one of them successfully provides `SecurityIdentity`.
+
 [[use-annotations-for-path-based-auth]]
 ==== Use annotations to enable path-based authentication for Jakarta REST endpoints
 
@@ -1095,8 +1130,8 @@ NOTE: For consistency with various Jakarta EE specifications, it is recommended
 
 ==== Use inclusive authentication to enable path-based authentication
 
-By default, Quarkus only supports <<path-based-authentication>> for one authentication mechanism per path.
-If more than one authentication mechanism must be used for the path-based authentication, you can write a custom `HttpAuthenticationMechanism` as documented in the xref:security-customization.adoc#dealing-with-more-than-one-http-auth-mechanisms[Dealing with more than one HttpAuthenticationMechanism] section of the Security Tips and Tricks guide.
+By default, Quarkus only supports <<use-annotations-for-path-based-auth>> for one authentication mechanism selected with annotation per REST endpoint.
+If more than one authentication mechanism must be used for the <<path-based-authentication>>, you can write a custom `HttpAuthenticationMechanism` as documented in the xref:security-customization.adoc#dealing-with-more-than-one-http-auth-mechanisms[Dealing with more than one HttpAuthenticationMechanism] section of the Security Tips and Tricks guide.
 Another option is to enable <<inclusive-authentication>> in the lax mode and write a custom `HttpSecurityPolicy` or `PermissionChecker` that verifies that all registered HTTP authentication mechanisms created their mechanism-specific `SecurityIdentity`.
 
 .Enable inclusive authentication in the lax mode
diff --git a/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/PolicyMappingConfig.java b/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/PolicyMappingConfig.java
index 6c9a3aaf0db..6e56c8fffe8 100644
--- a/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/PolicyMappingConfig.java
+++ b/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/PolicyMappingConfig.java
@@ -2,7 +2,10 @@
 
 import java.util.List;
 import java.util.Optional;
+import java.util.Set;
 
+import io.quarkus.runtime.configuration.TrimmedStringConverter;
+import io.smallrye.config.WithConverter;
 import io.smallrye.config.WithDefault;
 
 public interface PolicyMappingConfig {
@@ -48,11 +51,13 @@ public interface PolicyMappingConfig {
     Optional<List<String>> paths();
 
     /**
-     * Path specific authentication mechanism which must be used to authenticate a user.
-     * It needs to match {@link io.quarkus.vertx.http.runtime.security.HttpCredentialTransport} authentication scheme
-     * such as 'basic', 'bearer', 'form', etc.
+     * One or more path specific authentication mechanisms separated by comma.
+     * Every listed value needs to match {@link io.quarkus.vertx.http.runtime.security.HttpCredentialTransport}
+     * authentication scheme such as 'basic', 'bearer', 'form', etc.
+     * By default, only one of the matching authentication mechanisms will produce a `SecurityIdentity`,
+     * and all matching authentication mechanisms will attempt to authenticate when an inclusive authentication is enabled.
      */
-    Optional<String> authMechanism();
+    Optional<Set<@WithConverter(TrimmedStringConverter.class) String>> authMechanism();
 
     /**
      * Indicates that this policy always applies to the matched paths in addition to the policy with a winning path.
diff --git a/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/AbstractPathMatchingHttpSecurityPolicy.java b/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/AbstractPathMatchingHttpSecurityPolicy.java
index 46e215c072d..1a90d9a7307 100644
--- a/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/AbstractPathMatchingHttpSecurityPolicy.java
+++ b/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/AbstractPathMatchingHttpSecurityPolicy.java
@@ -21,7 +21,7 @@
 import io.quarkus.security.identity.SecurityIdentity;
 import io.quarkus.vertx.http.runtime.PolicyConfig;
 import io.quarkus.vertx.http.runtime.PolicyMappingConfig;
-import io.quarkus.vertx.http.runtime.security.HttpSecurityConfiguration.AuthenticationMechanism;
+import io.quarkus.vertx.http.runtime.security.HttpSecurityConfiguration.AuthenticationMechanisms;
 import io.quarkus.vertx.http.runtime.security.HttpSecurityPolicy.AuthorizationRequestContext;
 import io.quarkus.vertx.http.runtime.security.HttpSecurityPolicy.CheckResult;
 import io.quarkus.vertx.http.runtime.security.ImmutablePathMatcher.PathMatch;
@@ -70,29 +70,16 @@ public class AbstractPathMatchingHttpSecurityPolicy {
         this.pathMatcher = builder.build();
     }
 
-    AuthenticationMechanism getAuthMechanism(RoutingContext routingContext) {
+    AuthenticationMechanisms getAuthMechanisms(RoutingContext routingContext) {
         if (sharedPermissionsPathMatchers != null) {
             for (ImmutablePathMatcher<List<HttpMatcher>> matcher : sharedPermissionsPathMatchers) {
-                AuthenticationMechanism authMechanism = getAuthMechanism(routingContext, matcher);
-                if (authMechanism != null) {
-                    return authMechanism;
+                AuthenticationMechanisms authMechanisms = getAuthMechanisms(routingContext, matcher);
+                if (authMechanisms != null) {
+                    return authMechanisms;
                 }
             }
         }
-        return getAuthMechanism(routingContext, pathMatcher);
-    }
-
-    /**
-     * @deprecated This method is internal by nature, if you have a good use case, please report it
-     *             so that we can document the use case and test it.
-     */
-    @Deprecated(forRemoval = true, since = "3.25")
-    public String getAuthMechanismName(RoutingContext routingContext) {
-        AuthenticationMechanism authenticationMechanism = getAuthMechanism(routingContext);
-        if (authenticationMechanism != null) {
-            return authenticationMechanism.name();
-        }
-        return null;
+        return getAuthMechanisms(routingContext, pathMatcher);
     }
 
     public boolean hasNoPermissions() {
@@ -173,11 +160,11 @@ public Uni<? extends CheckResult> apply(CheckResult checkResult) {
                 });
     }
 
-    private static AuthenticationMechanism getAuthMechanism(RoutingContext routingContext,
+    private static AuthenticationMechanisms getAuthMechanisms(RoutingContext routingContext,
             ImmutablePathMatcher<List<HttpMatcher>> pathMatcher) {
         for (HttpMatcher i : findHttpMatchers(routingContext, pathMatcher)) {
-            if (i.authMechanism != null) {
-                return i.authMechanism;
+            if (i.authMechanisms != null) {
+                return i.authMechanisms;
             }
         }
         return null;
@@ -198,7 +185,7 @@ private static void addPermissionToPathMatcher(Map<String, HttpSecurityPolicy> p
         }
 
         for (String path : httpPermission.getPaths()) {
-            HttpMatcher m = new HttpMatcher(httpPermission.getAuthMechanism(), httpPermission.getMethods(), policy);
+            HttpMatcher m = new HttpMatcher(httpPermission.getAuthMechanisms(), httpPermission.getMethods(), policy);
             List<HttpMatcher> perms = new ArrayList<>();
             perms.add(m);
             builder.addPath(path, perms);
@@ -429,7 +416,7 @@ static ConfigurationException duplicateNamedPoliciesNotAllowedEx(HttpSecurityPol
                 + policy1.name() + "' is allowed, but found: " + policyClassName1 + " and " + policyClassName2);
     }
 
-    record HttpMatcher(AuthenticationMechanism authMechanism, Set<String> methods, HttpSecurityPolicy checker) {
+    record HttpMatcher(AuthenticationMechanisms authMechanisms, Set<String> methods, HttpSecurityPolicy checker) {
         private static final HttpMatcher DENY = new HttpMatcher(null, Set.of(), DenySecurityPolicy.INSTANCE);
     }
 }
diff --git a/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/HttpAuthenticator.java b/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/HttpAuthenticator.java
index b8f72da1576..e44b191ee41 100644
--- a/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/HttpAuthenticator.java
+++ b/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/HttpAuthenticator.java
@@ -2,6 +2,7 @@
 
 import static io.quarkus.security.spi.runtime.SecurityEventHelper.AUTHENTICATION_FAILURE;
 import static io.quarkus.security.spi.runtime.SecurityEventHelper.AUTHENTICATION_SUCCESS;
+import static io.quarkus.vertx.http.runtime.security.HttpSecurityConfiguration.AuthenticationMechanisms.normalizeMechanismName;
 import static io.quarkus.vertx.http.runtime.security.HttpSecurityRecorder.DefaultAuthFailureHandler.DEV_MODE_AUTHENTICATION_FAILURE_BODY;
 import static io.quarkus.vertx.http.runtime.security.HttpSecurityUtils.SECURITY_IDENTITIES_ATTRIBUTE;
 import static io.quarkus.vertx.http.runtime.security.HttpSecurityUtils.getSecurityIdentities;
@@ -9,8 +10,12 @@
 import static io.quarkus.vertx.http.runtime.security.RoutingContextAwareSecurityIdentity.addRoutingCtxToIdentityIfMissing;
 import static java.lang.Boolean.TRUE;
 
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
+import java.util.HashSet;
+import java.util.LinkedList;
+import java.util.List;
 import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
@@ -38,8 +43,7 @@
 import io.quarkus.security.spi.runtime.SecurityEventHelper;
 import io.quarkus.vertx.http.runtime.AuthRuntimeConfig;
 import io.quarkus.vertx.http.runtime.VertxHttpConfig;
-import io.quarkus.vertx.http.runtime.security.HttpSecurityConfiguration.AuthenticationMechanism;
-import io.quarkus.vertx.http.runtime.security.annotation.BasicAuthentication;
+import io.quarkus.vertx.http.runtime.security.HttpSecurityConfiguration.AuthenticationMechanisms;
 import io.smallrye.mutiny.Uni;
 import io.vertx.ext.web.RoutingContext;
 
@@ -68,9 +72,14 @@ public final class HttpAuthenticator {
     public static final String BASIC_AUTH_ANNOTATION_DETECTED = "io.quarkus.security.http.basic-authentication-annotation-detected";
     private static final Logger LOG = Logger.getLogger(HttpAuthenticator.class);
     /**
-     * Added to a {@link RoutingContext} as selected authentication mechanism.
+     * Added to a {@link RoutingContext} as selected authentication mechanisms of type {@link AuthenticationMechanisms}.
      */
-    private static final String AUTH_MECHANISM = HttpAuthenticator.class.getName() + "#auth-mechanism";
+    private static final String SELECTED_AUTH_MECHANISMS = HttpAuthenticator.class.getName() + "#selected-auth-mechanisms";
+    /**
+     * Added to a {@link RoutingContext} as selected {@link HttpAuthenticationMechanism} instances.
+     */
+    private static final String SELECTED_AUTH_MECHANISM_INSTANCES = HttpAuthenticator.class.getName()
+            + "#selected-auth-mechanism-instances";
     /**
      * Added to a {@link RoutingContext} when {@link this#attemptAuthentication(RoutingContext)} is invoked.
      */
@@ -79,7 +88,7 @@ public final class HttpAuthenticator {
     private final IdentityProviderManager identityProviderManager;
     private final HttpAuthenticationMechanism[] mechanisms;
     private final SecurityEventHelper<AuthenticationSuccessEvent, AuthenticationFailureEvent> securityEventHelper;
-    private final boolean inclusiveAuth;
+    private final boolean globalInclusiveAuth;
     private final boolean strictInclusiveMode;
 
     HttpAuthenticator(IdentityProviderManager identityProviderManager, Event<AuthenticationFailureEvent> authFailureEvent,
@@ -89,9 +98,9 @@ public final class HttpAuthenticator {
         this.securityEventHelper = new SecurityEventHelper<>(authSuccessEvent, authFailureEvent, AUTHENTICATION_SUCCESS,
                 AUTHENTICATION_FAILURE, beanManager, securityEventsEnabled);
         this.identityProviderManager = identityProviderManager;
-        this.inclusiveAuth = httpConfig.auth().inclusive();
+        this.globalInclusiveAuth = httpConfig.auth().inclusive();
         this.strictInclusiveMode = httpConfig.auth().inclusiveMode() == AuthRuntimeConfig.InclusiveMode.STRICT;
-        this.mechanisms = HttpSecurityConfiguration.get().getMechanisms(providers, inclusiveAuth);
+        this.mechanisms = HttpSecurityConfiguration.get().getMechanisms(providers, globalInclusiveAuth);
     }
 
     public IdentityProviderManager getIdentityProviderManager() {
@@ -115,50 +124,29 @@ public Uni<SecurityIdentity> attemptAuthentication(RoutingContext routingContext
             rememberAuthAttempted(routingContext);
         }
 
-        // determine whether user selected path specific mechanism via HTTP Security policy or annotation
-        final AuthenticationMechanism pathSpecificMechanism;
-        if (selectAuthMechanismWithAnnotation && isAuthMechanismSelected(routingContext)) {
-            pathSpecificMechanism = getAuthMechanism(routingContext);
+        // determine whether user selected path specific mechanisms via HTTP Security policy or annotation
+        final AuthenticationMechanisms pathSpecificMechanisms;
+        if (selectAuthMechanismWithAnnotation && areAuthMechanismsSelected(routingContext)) {
+            pathSpecificMechanisms = getSelectedAuthMechanisms(routingContext);
         } else {
             AbstractPathMatchingHttpSecurityPolicy pathMatchingPolicy = routingContext
                     .get(AbstractPathMatchingHttpSecurityPolicy.class.getName());
-            pathSpecificMechanism = pathMatchingPolicy != null ? pathMatchingPolicy.getAuthMechanism(routingContext) : null;
+            pathSpecificMechanisms = pathMatchingPolicy != null ? pathMatchingPolicy.getAuthMechanisms(routingContext) : null;
         }
 
         // authenticate
         Uni<SecurityIdentity> result;
-        if (pathSpecificMechanism == null) {
-            result = createSecurityIdentity(routingContext, 0);
+        if (pathSpecificMechanisms == null) {
+            result = createAndValidateSecurityIdentity(routingContext, mechanisms, identityProviderManager, globalInclusiveAuth,
+                    strictInclusiveMode, mechanisms.length);
         } else {
-            result = findBestCandidateMechanism(routingContext, pathSpecificMechanism).onItem().ifNotNull()
-                    .transformToUni(new Function<HttpAuthenticationMechanism, Uni<? extends SecurityIdentity>>() {
+            result = findBestCandidateMechanisms(routingContext, 0, new HashSet<>(pathSpecificMechanisms.names()),
+                    new LinkedList<>()).onItem().ifNotNull()
+                    .transformToUni(new Function<HttpAuthenticationMechanism[], Uni<? extends SecurityIdentity>>() {
                         @Override
-                        public Uni<SecurityIdentity> apply(HttpAuthenticationMechanism mech) {
-                            return mech.authenticate(routingContext, identityProviderManager);
-                        }
-                    });
-        }
-
-        if (inclusiveAuth && strictInclusiveMode && pathSpecificMechanism == null) {
-            // inclusive authentication in the strict mode requires that all registered mechanisms created identity
-            // if at least one of them created it (AKA: if identity is not null, null results in anonymous identity)
-            // inclusive authentication is not applied when path-specific mechanism has been selected (because there
-            // user said use 'xyz' mechanism, not all the mechanisms)
-            result = result.onItem().ifNotNull()
-                    .transformToUni(new Function<SecurityIdentity, Uni<? extends SecurityIdentity>>() {
-                        @Override
-                        public Uni<? extends SecurityIdentity> apply(SecurityIdentity identity) {
-                            Map<String, SecurityIdentity> identities = HttpSecurityUtils.getSecurityIdentities(routingContext);
-                            if (identities == null || identities.size() != mechanisms.length) {
-                                return Uni.createFrom().failure(new AuthenticationFailedException(
-                                        """
-                                                There is '%d' HTTP authentication mechanisms, however only '%d' authentication mechanisms
-                                                created identity: %s
-                                                """
-                                                .formatted(identities == null ? 0 : identities.size(), mechanisms.length,
-                                                        identities == null ? "" : identities.keySet())));
-                            }
-                            return Uni.createFrom().item(identity);
+                        public Uni<SecurityIdentity> apply(HttpAuthenticationMechanism[] candidates) {
+                            return createAndValidateSecurityIdentity(routingContext, candidates, identityProviderManager,
+                                    globalInclusiveAuth, strictInclusiveMode, pathSpecificMechanisms.names().size());
                         }
                     });
         }
@@ -190,7 +178,37 @@ public void accept(SecurityIdentity securityIdentity) {
         return result;
     }
 
-    private Uni<SecurityIdentity> createSecurityIdentity(RoutingContext routingContext, int i) {
+    private static Uni<SecurityIdentity> createAndValidateSecurityIdentity(RoutingContext routingContext,
+            HttpAuthenticationMechanism[] mechanisms, IdentityProviderManager identityProviderManager, boolean inclusiveAuth,
+            boolean strictInclusiveMode, int expectedIdentitiesCount) {
+        if (inclusiveAuth && strictInclusiveMode) {
+            // inclusive authentication in the strict mode requires that all selected mechanisms created identity
+            // if at least one of them created it (AKA: if identity is not null, null results in anonymous identity)
+            return createSecurityIdentity(routingContext, 0, mechanisms, identityProviderManager, true)
+                    .onItem().ifNotNull()
+                    .transformToUni(new Function<SecurityIdentity, Uni<? extends SecurityIdentity>>() {
+                        @Override
+                        public Uni<? extends SecurityIdentity> apply(SecurityIdentity identity) {
+                            Map<String, SecurityIdentity> identities = HttpSecurityUtils.getSecurityIdentities(routingContext);
+                            if (identities == null || identities.size() != expectedIdentitiesCount) {
+                                return Uni.createFrom().failure(new AuthenticationFailedException(
+                                        """
+                                                There is '%d' selected HTTP authentication mechanisms, however only '%d'
+                                                authentication mechanisms created identity: %s
+                                                """
+                                                .formatted(expectedIdentitiesCount, identities == null ? 0 : identities.size(),
+                                                        identities == null ? "" : identities.keySet())));
+                            }
+                            return Uni.createFrom().item(identity);
+                        }
+                    });
+        } else {
+            return createSecurityIdentity(routingContext, 0, mechanisms, identityProviderManager, inclusiveAuth);
+        }
+    }
+
+    private static Uni<SecurityIdentity> createSecurityIdentity(RoutingContext routingContext, int i,
+            HttpAuthenticationMechanism[] mechanisms, IdentityProviderManager identityProviderManager, boolean inclusiveAuth) {
         if (i == mechanisms.length) {
             return Uni.createFrom().nullItem();
         }
@@ -200,14 +218,19 @@ private Uni<SecurityIdentity> createSecurityIdentity(RoutingContext routingConte
                     public Uni<SecurityIdentity> apply(SecurityIdentity identity) {
                         if (identity != null) {
                             if (inclusiveAuth) {
-                                return authenticateWithAllMechanisms(identity, i, routingContext);
+                                return authenticateWithAllMechanisms(identity, i, routingContext, mechanisms,
+                                        identityProviderManager);
                             }
-                            if (selectAuthMechanismWithAnnotation && !isAuthMechanismSelected(routingContext)) {
-                                return rememberAuthMechScheme(mechanisms[i], routingContext).replaceWith(identity);
+                            if (selectAuthMechanismWithAnnotation && !areAuthMechanismsSelected(routingContext)) {
+                                // this is done so that we can recognize if authentication happened before
+                                // the mechanism was selected with the annotation, however, the authentication happened
+                                // using the correct mechanism, therefore it is not illegal state (we can be lenient)
+                                return rememberSelectedAuthMechScheme(mechanisms[i], routingContext).replaceWith(identity);
                             }
                             return Uni.createFrom().item(identity);
                         }
-                        return createSecurityIdentity(routingContext, i + 1);
+                        return createSecurityIdentity(routingContext, i + 1, mechanisms, identityProviderManager,
+                                inclusiveAuth);
                     }
                 });
     }
@@ -222,30 +245,20 @@ public Uni<Boolean> sendChallenge(RoutingContext routingContext) {
         if (!routingContext.request().isEnded()) {
             routingContext.request().resume();
         }
-        Uni<Boolean> result = null;
 
-        // we only require auth mechanism to put itself into routing context when there is more than one mechanism registered
-        if (mechanisms.length > 1) {
-            HttpAuthenticationMechanism matchingMech = routingContext.get(HttpAuthenticationMechanism.class.getName());
-            if (matchingMech != null) {
-                result = matchingMech.sendChallenge(routingContext);
-            }
-        }
-
-        if (result == null) {
-            result = mechanisms[0].sendChallenge(routingContext);
-            for (int i = 1; i < mechanisms.length; ++i) {
-                HttpAuthenticationMechanism mech = mechanisms[i];
-                result = result.onItem().transformToUni(new Function<Boolean, Uni<? extends Boolean>>() {
-                    @Override
-                    public Uni<? extends Boolean> apply(Boolean authDone) {
-                        if (authDone) {
-                            return Uni.createFrom().item(authDone);
-                        }
-                        return mech.sendChallenge(routingContext);
+        HttpAuthenticationMechanism[] challengeMechanisms = getChallengeMechanisms(routingContext);
+        Uni<Boolean> result = challengeMechanisms[0].sendChallenge(routingContext);
+        for (int i = 1; i < challengeMechanisms.length; ++i) {
+            HttpAuthenticationMechanism mech = challengeMechanisms[i];
+            result = result.onItem().transformToUni(new Function<Boolean, Uni<? extends Boolean>>() {
+                @Override
+                public Uni<? extends Boolean> apply(Boolean authDone) {
+                    if (Boolean.TRUE.equals(authDone)) {
+                        return Uni.createFrom().item(true);
                     }
-                });
-            }
+                    return mech.sendChallenge(routingContext);
+                }
+            });
         }
         return result.onItem().transformToUni(new Function<Boolean, Uni<? extends Boolean>>() {
             @Override
@@ -266,16 +279,10 @@ public Uni<? extends Boolean> apply(Boolean authDone) {
     }
 
     public Uni<ChallengeData> getChallenge(RoutingContext routingContext) {
-        // we only require auth mechanism to put itself into routing context when there is more than one mechanism registered
-        if (mechanisms.length > 1) {
-            HttpAuthenticationMechanism matchingMech = routingContext.get(HttpAuthenticationMechanism.class.getName());
-            if (matchingMech != null) {
-                return matchingMech.getChallenge(routingContext);
-            }
-        }
-        Uni<ChallengeData> result = mechanisms[0].getChallenge(routingContext);
-        for (int i = 1; i < mechanisms.length; ++i) {
-            HttpAuthenticationMechanism mech = mechanisms[i];
+        HttpAuthenticationMechanism[] challengeMechanisms = getChallengeMechanisms(routingContext);
+        Uni<ChallengeData> result = challengeMechanisms[0].getChallenge(routingContext);
+        for (int i = 1; i < challengeMechanisms.length; ++i) {
+            HttpAuthenticationMechanism mech = challengeMechanisms[i];
             result = result.onItem().transformToUni(new Function<ChallengeData, Uni<? extends ChallengeData>>() {
                 @Override
                 public Uni<? extends ChallengeData> apply(ChallengeData data) {
@@ -290,8 +297,39 @@ public Uni<? extends ChallengeData> apply(ChallengeData data) {
         return result;
     }
 
-    private Uni<SecurityIdentity> authenticateWithAllMechanisms(SecurityIdentity identity, int i,
-            RoutingContext routingContext) {
+    private HttpAuthenticationMechanism[] getChallengeMechanisms(RoutingContext routingContext) {
+        HttpAuthenticationMechanism[] challengeMechanisms;
+
+        // this is mechanism that added itself to the RoutingContext last in one of following situations:
+        // - it started to authenticate using this HTTP authenticator and authentication failed or redirect is needed
+        // - some mechanisms can be used directly without this HttpAuthenticator instance
+        //   like when user calls form-based mechanism's post location
+        // - someone can invoke challenge even if authentication succeeded, but we don't expect that to happen
+        HttpAuthenticationMechanism directlyUsedAuthenticationMechanism = routingContext
+                .get(HttpAuthenticationMechanism.class.getName());
+
+        if (directlyUsedAuthenticationMechanism != null) {
+
+            challengeMechanisms = new HttpAuthenticationMechanism[] { directlyUsedAuthenticationMechanism };
+        } else {
+            // either no authentication mechanism provided a SecurityIdentity, or some custom mechanism
+            // provided it, but did not add itself into the RoutingContext
+
+            // path-specific mechanisms
+            challengeMechanisms = getSelectedAuthMechanismInstances(routingContext);
+
+            if (challengeMechanisms == null) {
+                // if no path-specific mechanism was selected, we use all the authentication mechanisms
+                challengeMechanisms = mechanisms;
+            }
+        }
+
+        return challengeMechanisms;
+    }
+
+    private static Uni<SecurityIdentity> authenticateWithAllMechanisms(SecurityIdentity identity, int i,
+            RoutingContext routingContext, HttpAuthenticationMechanism[] mechanisms,
+            IdentityProviderManager identityProviderManager) {
         return mechanisms[i].getCredentialTransport(routingContext)
                 .onItem().transformToUni(new Function<HttpCredentialTransport, Uni<? extends SecurityIdentity>>() {
                     @Override
@@ -304,6 +342,7 @@ public Uni<SecurityIdentity> apply(HttpCredentialTransport httpCredentialTranspo
                             return Uni.createFrom().failure(new AuthenticationFailedException());
                         }
                         var authMechanism = httpCredentialTransport.getAuthenticationScheme();
+                        rememberSelectedAuthMechanism(routingContext, authMechanism);
 
                         // add current identity to the RoutingContext
                         var authMechToIdentity = getSecurityIdentities(routingContext);
@@ -316,53 +355,49 @@ public Uni<SecurityIdentity> apply(HttpCredentialTransport httpCredentialTranspo
 
                         // authenticate with remaining mechanisms
                         if (isFirstIdentity) {
-                            return createSecurityIdentity(routingContext, i + 1)
+                            return createSecurityIdentity(routingContext, i + 1, mechanisms, identityProviderManager, true)
                                     .replaceWith(addRoutingCtxToIdentityIfMissing(identity, routingContext));
                         } else {
-                            return createSecurityIdentity(routingContext, i + 1);
+                            return createSecurityIdentity(routingContext, i + 1, mechanisms, identityProviderManager, true);
                         }
                     }
                 });
     }
 
-    private Uni<HttpAuthenticationMechanism> findBestCandidateMechanism(RoutingContext routingContext,
-            AuthenticationMechanism pathSpecificMechanism) {
-        if (pathSpecificMechanism.instance() != null) {
-            rememberAuthMechanism(routingContext, pathSpecificMechanism);
-            return Uni.createFrom().item(pathSpecificMechanism.instance());
-        }
-        return findBestCandidateMechanism(routingContext, pathSpecificMechanism.name(), 0);
-    }
-
-    private Uni<HttpAuthenticationMechanism> findBestCandidateMechanism(RoutingContext routingContext,
-            String pathSpecificMechanism, int i) {
+    private Uni<HttpAuthenticationMechanism[]> findBestCandidateMechanisms(RoutingContext routingContext, int i,
+            Set<String> mechanismsToFind, List<HttpAuthenticationMechanism> foundSelectedMechanisms) {
         if (i == mechanisms.length) {
-            return Uni.createFrom().nullItem();
+            if (foundSelectedMechanisms.isEmpty()) {
+                return Uni.createFrom().nullItem();
+            }
+            return Uni.createFrom().item(foundSelectedMechanisms.toArray(HttpAuthenticationMechanism[]::new));
         }
-        return getPathSpecificMechanism(i, routingContext, pathSpecificMechanism).onItem().transformToUni(
-                new Function<HttpAuthenticationMechanism, Uni<? extends HttpAuthenticationMechanism>>() {
+        return getPathSpecificMechanism(i, routingContext, mechanismsToFind).flatMap(
+                new Function<HttpAuthenticationMechanism, Uni<? extends HttpAuthenticationMechanism[]>>() {
                     @Override
-                    public Uni<? extends HttpAuthenticationMechanism> apply(HttpAuthenticationMechanism mech) {
+                    public Uni<? extends HttpAuthenticationMechanism[]> apply(HttpAuthenticationMechanism mech) {
                         if (mech != null) {
-                            if (selectAuthMechanismWithAnnotation && !isAuthMechanismSelected(routingContext)) {
-                                return rememberAuthMechScheme(mech, routingContext).replaceWith(mech);
+                            foundSelectedMechanisms.add(mech);
+                            if (mechanismsToFind.isEmpty()) {
+                                return Uni.createFrom()
+                                        .item(foundSelectedMechanisms.toArray(HttpAuthenticationMechanism[]::new));
                             }
-                            return Uni.createFrom().item(mech);
                         }
-                        return findBestCandidateMechanism(routingContext, pathSpecificMechanism, i + 1);
+                        return findBestCandidateMechanisms(routingContext, i + 1, mechanismsToFind, foundSelectedMechanisms);
                     }
                 });
     }
 
     private Uni<HttpAuthenticationMechanism> getPathSpecificMechanism(int index, RoutingContext routingContext,
-            String pathSpecificMechanism) {
+            Set<String> mechanismsToFind) {
         return mechanisms[index].getCredentialTransport(routingContext).onItem()
                 .transform(new Function<HttpCredentialTransport, HttpAuthenticationMechanism>() {
                     @Override
                     public HttpAuthenticationMechanism apply(HttpCredentialTransport t) {
-                        if (t != null && t.getAuthenticationScheme().equalsIgnoreCase(pathSpecificMechanism)) {
-                            routingContext.put(HttpAuthenticationMechanism.class.getName(), mechanisms[index]);
-                            rememberAuthMechanism(routingContext, t.getAuthenticationScheme());
+                        if (t != null && mechanismsToFind.contains(normalizeMechanismName(t.getAuthenticationScheme()))) {
+                            addSelectedAuthMechanismInstance(mechanisms[index], routingContext);
+                            rememberSelectedAuthMechanism(routingContext, t.getAuthenticationScheme());
+                            mechanismsToFind.remove(t.getAuthenticationScheme());
                             return mechanisms[index];
                         }
                         return null;
@@ -375,45 +410,55 @@ static void selectAuthMechanismWithAnnotation() {
     }
 
     static void selectAuthMechanism(RoutingContext routingContext, String authMechanism) {
-        if (requestAlreadyAuthenticated(routingContext, authMechanism)) {
-            AuthenticationMechanism authenticationMechanism = getAuthMechanism(routingContext);
-            final String previousMechanism;
-            if (authenticationMechanism != null) {
-                if (authenticationMechanism.name() != null) {
-                    previousMechanism = authenticationMechanism.name();
-                } else {
-                    previousMechanism = ClientProxy.unwrap(authenticationMechanism.instance()).getClass().getName();
-                }
+        if (authenticationAlreadyAttempted(routingContext, authMechanism)) {
+            AuthenticationMechanisms authenticationMechanisms = getSelectedAuthMechanisms(routingContext);
+            final String previousMechanisms;
+            if (authenticationMechanisms != null) {
+                previousMechanisms = authenticationMechanisms.names().toString();
             } else {
-                previousMechanism = null;
+                previousMechanisms = "";
             }
             throw new AuthenticationFailedException("""
                     The '%1$s' authentication mechanism is required to authenticate the request but it was already
-                    authenticated with the '%2$s' authentication mechanism. It can happen if the '%1$s' is selected with
-                    an annotation but '%2$s' is activated by the HTTP security policy which is enforced before
-                    the JAX-RS chain is run. In such cases, please set the
-                    'quarkus.http.auth.permission."permissions".applies-to=JAXRS' to all HTTP security policies
+                    authenticated with the '%2$s' authentication mechanisms.
+                    It can happen if the '%1$s' is selected with an annotation but '%2$s' are activated by
+                    the HTTP security policy which is enforced before the JAX-RS chain is run. In such cases, please
+                    set the 'quarkus.http.auth.permission."permissions".applies-to=JAXRS' to all HTTP security policies
                     which secure the same REST endpoints as the ones secured by the '%1$s' authentication mechanism
                     selected with the annotation.
-                    """.formatted(authMechanism, previousMechanism));
+                    """.formatted(authMechanism, previousMechanisms));
         }
-        rememberAuthMechanism(routingContext, authMechanism);
+        rememberSelectedAuthMechanism(routingContext, authMechanism);
     }
 
     private static void rememberAuthAttempted(RoutingContext routingContext) {
         routingContext.put(ATTEMPT_AUTH_INVOKED, TRUE);
     }
 
-    private static boolean isAuthMechanismSelected(RoutingContext routingContext) {
-        return getAuthMechanism(routingContext) != null;
+    private static boolean areAuthMechanismsSelected(RoutingContext routingContext) {
+        return getSelectedAuthMechanisms(routingContext) != null;
     }
 
-    private static boolean requestAlreadyAuthenticated(RoutingContext event, String newAuthMechanism) {
-        return event.get(ATTEMPT_AUTH_INVOKED) == TRUE && authenticatedWithDifferentAuthMechanism(newAuthMechanism, event);
+    private static boolean authenticationAlreadyAttempted(RoutingContext event, String newAuthMechanism) {
+        return event.get(ATTEMPT_AUTH_INVOKED) == TRUE
+                && authenticationAttemptedWithDifferentRequirements(newAuthMechanism, event);
     }
 
-    private static boolean authenticatedWithDifferentAuthMechanism(String newAuthMechanism, RoutingContext event) {
-        return !newAuthMechanism.equalsIgnoreCase(getAuthMechanismScheme(event));
+    private static boolean authenticationAttemptedWithDifferentRequirements(String newAuthMechanism, RoutingContext event) {
+        // this is configured used for the previous attempt, we require that this is identical to what is selected
+        // by the annotation
+        AuthenticationMechanisms selectedAuthenticationMechanisms = getSelectedAuthMechanisms(event);
+
+        if (selectedAuthenticationMechanisms != null) {
+            // for now, users can only select one mechanism with the annotation, hence, the previous
+            // authentication attempt must be identical in every way
+            if (selectedAuthenticationMechanisms.names().size() == 1
+                    && selectedAuthenticationMechanisms.names().contains(normalizeMechanismName(newAuthMechanism))) {
+                return false;
+            }
+        }
+
+        return true;
     }
 
     /**
@@ -421,40 +466,62 @@ private static boolean authenticatedWithDifferentAuthMechanism(String newAuthMec
      * in case that someone tries to change the mechanism after the authentication. This way, we can be permissive
      * when the selected mechanism is same as the one already used.
      */
-    private static Uni<HttpCredentialTransport> rememberAuthMechScheme(HttpAuthenticationMechanism mech, RoutingContext event) {
+    private static Uni<HttpCredentialTransport> rememberSelectedAuthMechScheme(HttpAuthenticationMechanism mech,
+            RoutingContext event) {
         return mech.getCredentialTransport(event)
                 .onItem().ifNotNull().invoke(new Consumer<HttpCredentialTransport>() {
                     @Override
                     public void accept(HttpCredentialTransport t) {
                         if (t.getAuthenticationScheme() != null) {
-                            rememberAuthMechanism(event, t.getAuthenticationScheme());
+                            rememberSelectedAuthMechanism(event, t.getAuthenticationScheme());
                         }
                     }
                 });
     }
 
-    private static void rememberAuthMechanism(RoutingContext event, AuthenticationMechanism newAuthMechanism) {
-        event.put(AUTH_MECHANISM, newAuthMechanism);
-        event.put(HttpAuthenticationMechanism.class.getName(), newAuthMechanism.instance());
+    private static void rememberSelectedAuthMechanism(RoutingContext event, String newAuthMechanism) {
+        AuthenticationMechanisms currentMechanisms = getSelectedAuthMechanisms(event);
+        if (currentMechanisms == null) {
+            event.put(SELECTED_AUTH_MECHANISMS, new AuthenticationMechanisms(newAuthMechanism));
+        } else {
+            event.put(SELECTED_AUTH_MECHANISMS, currentMechanisms.with(newAuthMechanism));
+        }
     }
 
-    private static void rememberAuthMechanism(RoutingContext event, String newAuthMechanism) {
-        event.put(AUTH_MECHANISM, new AuthenticationMechanism(newAuthMechanism, null));
+    private static AuthenticationMechanisms getSelectedAuthMechanisms(RoutingContext event) {
+        return event.get(SELECTED_AUTH_MECHANISMS);
     }
 
-    private static AuthenticationMechanism getAuthMechanism(RoutingContext event) {
-        return event.get(AUTH_MECHANISM);
+    private static HttpAuthenticationMechanism[] getSelectedAuthMechanismInstances(RoutingContext event) {
+        return getMechanismsFromContext(event, SELECTED_AUTH_MECHANISM_INSTANCES);
+    }
+
+    private static void addSelectedAuthMechanismInstance(HttpAuthenticationMechanism httpAuthenticationMechanism,
+            RoutingContext routingContext) {
+        addMechanismToRoutingContext(httpAuthenticationMechanism, routingContext, SELECTED_AUTH_MECHANISM_INSTANCES);
+    }
+
+    private static void addMechanismToRoutingContext(HttpAuthenticationMechanism httpAuthenticationMechanism,
+            RoutingContext routingContext, String selectedAuthMechanismInstances) {
+        List<HttpAuthenticationMechanism> mechanisms = routingContext.get(selectedAuthMechanismInstances);
+        if (mechanisms == null) {
+            mechanisms = new ArrayList<>();
+            routingContext.put(selectedAuthMechanismInstances, mechanisms);
+        }
+        if (!mechanisms.contains(httpAuthenticationMechanism)) {
+            mechanisms.add(httpAuthenticationMechanism);
+        }
     }
 
-    private static String getAuthMechanismScheme(RoutingContext event) {
-        AuthenticationMechanism authenticationMechanism = getAuthMechanism(event);
-        if (authenticationMechanism != null) {
-            return authenticationMechanism.name();
+    private static HttpAuthenticationMechanism[] getMechanismsFromContext(RoutingContext event, String mechanismsKey) {
+        List<HttpAuthenticationMechanism> selectedInstances = event.get(mechanismsKey);
+        if (selectedInstances == null || selectedInstances.isEmpty()) {
+            return null;
         }
-        return null;
+        return selectedInstances.toArray(HttpAuthenticationMechanism[]::new);
     }
 
-    static class NoAuthenticationMechanism implements HttpAuthenticationMechanism {
+    static final class NoAuthenticationMechanism implements HttpAuthenticationMechanism {
 
         @Override
         public Uni<SecurityIdentity> authenticate(RoutingContext context,
diff --git a/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/HttpSecurityConfiguration.java b/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/HttpSecurityConfiguration.java
index 75e80c6e091..aa6e95a1fff 100644
--- a/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/HttpSecurityConfiguration.java
+++ b/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/HttpSecurityConfiguration.java
@@ -5,12 +5,17 @@
 import static io.quarkus.vertx.http.runtime.security.HttpAuthenticator.TEST_IF_BASIC_AUTH_IMPLICITLY_REQUIRED;
 
 import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
 import java.util.Comparator;
+import java.util.HashSet;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Optional;
 import java.util.Set;
+import java.util.stream.Collectors;
 
 import jakarta.enterprise.event.Event;
 import jakarta.enterprise.inject.Instance;
@@ -75,7 +80,41 @@ private HttpSecurityConfiguration(RolesMapping rolesMapping, List<HttpPermission
     record Policy(String name, HttpSecurityPolicy instance) {
     }
 
-    record AuthenticationMechanism(String name, HttpAuthenticationMechanism instance) {
+    record AuthenticationMechanisms(Set<String> names) {
+
+        AuthenticationMechanisms(String... names) {
+            this(normalizeNames(names));
+        }
+
+        AuthenticationMechanisms with(String newName) {
+            var newNames = new HashSet<>(names);
+            newNames.add(normalizeMechanismName(newName));
+            return new AuthenticationMechanisms(Collections.unmodifiableSet(newNames));
+        }
+
+        /**
+         * Unlike the default constructor, this factory method normalizes given mechanism names.
+         *
+         * @param names authentication mechanism names
+         * @return new AuthenticationMechanisms
+         */
+        static AuthenticationMechanisms from(Set<String> names) {
+            return new AuthenticationMechanisms(names.stream().map(AuthenticationMechanisms::normalizeMechanismName)
+                    .collect(Collectors.toUnmodifiableSet()));
+        }
+
+        static String normalizeMechanismName(String mechanismName) {
+            if (mechanismName == null) {
+                return "";
+            }
+            return mechanismName.toLowerCase(Locale.ROOT);
+        }
+
+        private static Set<String> normalizeNames(String[] names) {
+            return names.length == 1 ? Set.of(normalizeMechanismName(names[0]))
+                    : Arrays.stream(names).map(AuthenticationMechanisms::normalizeMechanismName)
+                            .collect(Collectors.toUnmodifiableSet());
+        }
     }
 
     interface HttpPermissionCarrier {
@@ -88,7 +127,7 @@ interface HttpPermissionCarrier {
 
         Set<String> getMethods();
 
-        AuthenticationMechanism getAuthMechanism();
+        AuthenticationMechanisms getAuthMechanisms();
 
         Policy getPolicy();
 
@@ -304,11 +343,11 @@ public Set<String> getMethods() {
             }
 
             @Override
-            public AuthenticationMechanism getAuthMechanism() {
+            public AuthenticationMechanisms getAuthMechanisms() {
                 if (mapping.authMechanism().isPresent()) {
-                    String authMech = mapping.authMechanism().get();
-                    if (!authMech.isEmpty()) {
-                        return new AuthenticationMechanism(authMech, null);
+                    var mechanisms = mapping.authMechanism().get();
+                    if (!mechanisms.isEmpty()) {
+                        return AuthenticationMechanisms.from(mechanisms);
                     }
                 }
                 return null;
@@ -399,8 +438,8 @@ private boolean isBasicAuthNotRequired() {
             return false;
         }
         for (var permission : httpPermissions) {
-            if (permission.getAuthMechanism() != null
-                    && BasicAuthentication.AUTH_MECHANISM_SCHEME.equals(permission.getAuthMechanism().name())) {
+            if (permission.getAuthMechanisms() != null
+                    && permission.getAuthMechanisms().names().contains(BasicAuthentication.AUTH_MECHANISM_SCHEME)) {
                 return false;
             }
         }
diff --git a/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/HttpSecurityImpl.java b/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/HttpSecurityImpl.java
index 4c1953e4eb9..b8c2dd6e02a 100644
--- a/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/HttpSecurityImpl.java
+++ b/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/HttpSecurityImpl.java
@@ -372,7 +372,7 @@ private final class HttpPermissionImpl implements HttpPermission, HttpPermission
         private boolean shared;
         private boolean applyToJaxRs;
         private String[] methods;
-        private HttpSecurityConfiguration.AuthenticationMechanism authMechanism;
+        private HttpSecurityConfiguration.AuthenticationMechanisms authMechanism;
         private AuthorizationPolicy authorizationPolicy;
 
         private HttpPermissionImpl(String[] paths) {
@@ -453,7 +453,18 @@ public HttpPermission authenticatedWith(String mechanism) {
             if (mechanism == null || mechanism.isBlank()) {
                 throw new IllegalArgumentException("Authentication mechanism must not be null or blank");
             }
-            this.authMechanism = new HttpSecurityConfiguration.AuthenticationMechanism(mechanism, null);
+            this.authMechanism = new HttpSecurityConfiguration.AuthenticationMechanisms(mechanism);
+            return this;
+        }
+
+        @Override
+        public HttpPermission authenticatedWith(Set<String> schemes) {
+            validateAuthenticationNotSetYet();
+            requireAuthenticationByDefault();
+            if (schemes == null || schemes.isEmpty()) {
+                throw new IllegalArgumentException("Authentication mechanism must not be null or emptz");
+            }
+            this.authMechanism = HttpSecurityConfiguration.AuthenticationMechanisms.from(schemes);
             return this;
         }
 
@@ -521,7 +532,7 @@ public Set<String> getMethods() {
         }
 
         @Override
-        public HttpSecurityConfiguration.AuthenticationMechanism getAuthMechanism() {
+        public HttpSecurityConfiguration.AuthenticationMechanisms getAuthMechanisms() {
             return authMechanism;
         }
 
diff --git a/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/JaxRsPathMatchingHttpSecurityPolicy.java b/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/JaxRsPathMatchingHttpSecurityPolicy.java
index 0566ba36577..1e647b1906b 100644
--- a/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/JaxRsPathMatchingHttpSecurityPolicy.java
+++ b/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/security/JaxRsPathMatchingHttpSecurityPolicy.java
@@ -8,6 +8,7 @@
 
 import jakarta.enterprise.inject.Instance;
 
+import io.quarkus.runtime.configuration.ConfigurationException;
 import io.quarkus.security.identity.SecurityIdentity;
 import io.quarkus.security.spi.runtime.BlockingSecurityExecutor;
 import io.quarkus.security.spi.runtime.MethodDescription;
@@ -72,6 +73,18 @@ public class JaxRsPathMatchingHttpSecurityPolicy {
             }
             policyNameToPolicy = Map.copyOf(annotationPoliciesOnly);
         }
+        for (var httpPermission : HttpSecurityConfiguration.get().httpPermissions()) {
+            if (httpPermission.shouldApplyToJaxRs() && httpPermission.getAuthMechanisms() != null) {
+                // HTTP authentication mechanism is selected by HTTP authenticator that
+                // uses the AbstractPathMatchingHttpSecurityPolicy in the RoutingContext
+                // we cannot support this without bigger refactoring and the whole point of JAX-RS policy was to support
+                // the authentication annotations like @BasicAuthentication, so it doesn't make sense to support it
+                throw new ConfigurationException("""
+                        HttpSecurityPolicy that applies to JAXRS can be effective only after an authentication process
+                        has completed, therefore this policy can not be used to select '%s' authentication mechanism
+                        """.formatted(httpPermission.getAuthMechanisms().names()));
+            }
+        }
     }
 
     /**
diff --git a/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/security/HttpSecurity.java b/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/security/HttpSecurity.java
index fc1c2688696..e095f765f88 100644
--- a/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/security/HttpSecurity.java
+++ b/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/security/HttpSecurity.java
@@ -287,10 +287,17 @@ interface HttpPermission {
         /**
          * HTTP request must be authenticated using a mechanism
          * with matching {@link HttpCredentialTransport#getAuthenticationScheme()}.
-         * Please note that annotation-based mechanism selection has higher priority during the mechanism selection.
          */
         HttpPermission authenticatedWith(String scheme);
 
+        /**
+         * HTTP request must be authenticated using mechanisms with matching
+         * {@link HttpCredentialTransport#getAuthenticationScheme()}. By default, only one of the matching authentication
+         * mechanisms will produce a {@link SecurityIdentity}, and all matching authentication mechanisms will attempt
+         * to authenticate when an inclusive authentication is enabled.
+         */
+        HttpPermission authenticatedWith(Set<String> schemes);
+
         /**
          * Indicates that this policy always applies to the matched paths in addition to the policy with a winning path.
          * Programmatic analogy to the 'quarkus.http.auth.permission."permissions".shared' configuration property.
