diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/Constants.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/Constants.java
index 500f55818..92c6990cb 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/Constants.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/Constants.java
@@ -91,7 +91,7 @@ public final class Constants {
 	 * @see #DEACTIVATE_CONDITIONS_PATTERN_PROPERTY_NAME
 	 * @see org.junit.jupiter.api.extension.ExecutionCondition
 	 */
-	public static final String DEACTIVATE_ALL_CONDITIONS_PATTERN = ClassNamePatternFilterUtils.ALL_PATTERN;
+	public static final String DEACTIVATE_ALL_CONDITIONS_PATTERN = ClassNamePatternFilterUtils.DEACTIVATE_ALL_PATTERN;
 
 	/**
 	 * Property name used to set the default display name generator class name: {@value}
diff --git a/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ClassNamePatternFilterUtils.java b/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ClassNamePatternFilterUtils.java
index f9ec3d257..6c713d8c6 100644
--- a/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ClassNamePatternFilterUtils.java
+++ b/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ClassNamePatternFilterUtils.java
@@ -41,7 +41,7 @@ public class ClassNamePatternFilterUtils {
 		/* no-op */
 	}
 
-	public static final String ALL_PATTERN = "*";
+	public static final String DEACTIVATE_ALL_PATTERN = "*";
 
 	/**
 	 * Create a {@link Predicate} that can be used to exclude (i.e., filter out)
@@ -51,7 +51,7 @@ public class ClassNamePatternFilterUtils {
 	 * @param patterns a comma-separated list of patterns
 	 */
 	public static <T> Predicate<T> excludeMatchingClasses(String patterns) {
-		return matchingClasses(patterns, object -> object.getClass().getName(), FilterType.EXCLUDE);
+		return excludeMatchingClasses(patterns, object -> object.getClass().getName());
 	}
 
 	/**
@@ -61,57 +61,26 @@ public class ClassNamePatternFilterUtils {
 	 * @param patterns a comma-separated list of patterns
 	 */
 	public static Predicate<String> excludeMatchingClassNames(String patterns) {
-		return matchingClasses(patterns, Function.identity(), FilterType.EXCLUDE);
+		return excludeMatchingClasses(patterns, Function.identity());
 	}
 
-	/**
-	 * Create a {@link Predicate} that can be used to include (i.e., filter in)
-	 * objects of type {@code T} whose fully qualified class names match any of
-	 * the supplied patterns.
-	 *
-	 * @param patterns a comma-separated list of patterns
-	 */
-	public static <T> Predicate<T> includeMatchingClasses(String patterns) {
-		return matchingClasses(patterns, object -> object.getClass().getName(), FilterType.INCLUDE);
-	}
-
-	/**
-	 * Create a {@link Predicate} that can be used to include (i.e., filter in)
-	 * fully qualified class names matching any of the supplied patterns.
-	 *
-	 * @param patterns a comma-separated list of patterns
-	 */
-	public static Predicate<String> includeMatchingClassNames(String patterns) {
-		return matchingClasses(patterns, Function.identity(), FilterType.INCLUDE);
-	}
-
-	private enum FilterType {
-		INCLUDE, EXCLUDE
-	}
-
-	private static <T> Predicate<T> matchingClasses(String patterns, Function<T, String> classNameProvider,
-			FilterType type) {
+	private static <T> Predicate<T> excludeMatchingClasses(String patterns, Function<T, String> classNameGetter) {
 		// @formatter:off
 		return Optional.ofNullable(patterns)
 				.filter(StringUtils::isNotBlank)
 				.map(String::trim)
-				.map(trimmedPatterns -> createPredicateFromPatterns(trimmedPatterns, classNameProvider, type))
-				.orElse(type == FilterType.EXCLUDE ? __ -> true : __ -> false);
+				.map(trimmedPatterns -> createPredicateFromPatterns(trimmedPatterns, classNameGetter))
+				.orElse(object -> true);
 		// @formatter:on
 	}
 
-	private static <T> Predicate<T> createPredicateFromPatterns(String patterns, Function<T, String> classNameProvider,
-			FilterType mode) {
-		if (ALL_PATTERN.equals(patterns)) {
-			return __ -> mode == FilterType.INCLUDE;
+	private static <T> Predicate<T> createPredicateFromPatterns(String patterns,
+			Function<T, String> classNameProvider) {
+		if (DEACTIVATE_ALL_PATTERN.equals(patterns)) {
+			return object -> false;
 		}
-
 		List<Pattern> patternList = convertToRegularExpressions(patterns);
-		return object -> {
-			boolean isMatchingAnyPattern = patternList.stream().anyMatch(
-				pattern -> pattern.matcher(classNameProvider.apply(object)).matches());
-			return (mode == FilterType.INCLUDE) == isMatchingAnyPattern;
-		};
+		return object -> patternList.stream().noneMatch(it -> it.matcher(classNameProvider.apply(object)).matches());
 	}
 
 	private static List<Pattern> convertToRegularExpressions(String patterns) {
diff --git a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/LauncherConstants.java b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/LauncherConstants.java
index 3a7aa079a..5cb30bf8e 100644
--- a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/LauncherConstants.java
+++ b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/LauncherConstants.java
@@ -146,7 +146,7 @@ public class LauncherConstants {
 	 * @see #DEACTIVATE_LISTENERS_PATTERN_PROPERTY_NAME
 	 * @see org.junit.platform.launcher.TestExecutionListener
 	 */
-	public static final String DEACTIVATE_ALL_LISTENERS_PATTERN = ClassNamePatternFilterUtils.ALL_PATTERN;
+	public static final String DEACTIVATE_ALL_LISTENERS_PATTERN = ClassNamePatternFilterUtils.DEACTIVATE_ALL_PATTERN;
 
 	/**
 	 * Property name used to enable support for
diff --git a/platform-tests/src/test/java/org/junit/platform/commons/util/ClassNamePatternFilterUtilsTests.java b/platform-tests/src/test/java/org/junit/platform/commons/util/ClassNamePatternFilterUtilsTests.java
index a76f67a31..1d68086db 100644
--- a/platform-tests/src/test/java/org/junit/platform/commons/util/ClassNamePatternFilterUtilsTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/commons/util/ClassNamePatternFilterUtilsTests.java
@@ -169,155 +169,4 @@ class ClassNamePatternFilterUtilsTests {
 				.isEmpty();
 	}
 
-	//@formatter:off
-	@ValueSource(strings = {
-			"org.junit.jupiter.*",
-			"org.junit.platform.*.NonExistentClass",
-			"*.NonExistentClass*",
-			"*NonExistentClass*",
-			"AExecutionConditionClass, BExecutionConditionClass"
-	})
-	//@formatter:on
-	@ParameterizedTest
-	void neverIncludedConditions(String pattern) {
-		List<? extends ExecutionCondition> executionConditions = List.of(new AExecutionConditionClass(),
-			new BExecutionConditionClass());
-		assertThat(executionConditions).filteredOn(ClassNamePatternFilterUtils.includeMatchingClasses(pattern)) //
-				.isEmpty();
-	}
-
-	//@formatter:off
-	@ValueSource(strings = {
-			"org.junit.platform.*",
-			"*.platform.*",
-			"*",
-			"*AExecutionConditionClass, *BExecutionConditionClass",
-			"*ExecutionConditionClass"
-	})
-	//@formatter:on
-	@ParameterizedTest
-	void alwaysIncludedConditions(String pattern) {
-		List<? extends ExecutionCondition> executionConditions = List.of(new AExecutionConditionClass(),
-			new BExecutionConditionClass());
-		assertThat(executionConditions).filteredOn(ClassNamePatternFilterUtils.includeMatchingClasses(pattern)) //
-				.hasSize(2);
-	}
-
-	//@formatter:off
-	@ValueSource(strings = {
-			"org.junit.jupiter.*",
-			"org.junit.platform.*.NonExistentClass",
-			"*.NonExistentClass*",
-			"*NonExistentClass*",
-			"ATestExecutionListenerClass, BTestExecutionListenerClass"
-	})
-	//@formatter:on
-	@ParameterizedTest
-	void neverIncludedListeners(String pattern) {
-		List<? extends TestExecutionListener> executionConditions = List.of(new ATestExecutionListenerClass(),
-			new BTestExecutionListenerClass());
-		assertThat(executionConditions).filteredOn(ClassNamePatternFilterUtils.includeMatchingClasses(pattern)) //
-				.isEmpty();
-	}
-
-	//@formatter:off
-	@ValueSource(strings = {
-			"org.junit.platform.*",
-			"*.platform.*",
-			"*",
-			"*ATestExecutionListenerClass, *BTestExecutionListenerClass",
-			"*TestExecutionListenerClass"
-	})
-	//@formatter:on
-	@ParameterizedTest
-	void alwaysIncludedListeners(String pattern) {
-		List<? extends TestExecutionListener> executionConditions = List.of(new ATestExecutionListenerClass(),
-			new BTestExecutionListenerClass());
-		assertThat(executionConditions).filteredOn(ClassNamePatternFilterUtils.includeMatchingClasses(pattern)) //
-				.hasSize(2);
-	}
-
-	//@formatter:off
-	@ValueSource(strings = {
-			"org.junit.jupiter.*",
-			"org.junit.platform.*.NonExistentClass",
-			"*.NonExistentClass*",
-			"*NonExistentClass*",
-			"AVanillaEmpty, BVanillaEmpty"
-	})
-	//@formatter:on
-	@ParameterizedTest
-	void neverIncludedClass(String pattern) {
-		var executionConditions = List.of(new AVanillaEmpty(), new BVanillaEmpty());
-		assertThat(executionConditions).filteredOn(ClassNamePatternFilterUtils.includeMatchingClasses(pattern)) //
-				.isEmpty();
-	}
-
-	//@formatter:off
-	@ValueSource(strings = {
-			"org.junit.platform.*",
-			"*.platform.*",
-			"*",
-			"*AVanillaEmpty, *BVanillaEmpty",
-			"*VanillaEmpty"
-	})
-	//@formatter:on
-	@ParameterizedTest
-	void alwaysIncludedClass(String pattern) {
-		var executionConditions = List.of(new AVanillaEmpty(), new BVanillaEmpty());
-		assertThat(executionConditions).filteredOn(ClassNamePatternFilterUtils.includeMatchingClasses(pattern)) //
-				.hasSize(2);
-	}
-
-	//@formatter:off
-	@ValueSource(strings = {
-			"org.junit.jupiter.*",
-			"org.junit.platform.*.NonExistentClass",
-			"*.NonExistentClass*",
-			"*NonExistentClass*",
-			"AVanillaEmpty, BVanillaEmpty"
-	})
-	//@formatter:on
-	@ParameterizedTest
-	void neverIncludedClassName(String pattern) {
-		var executionConditions = List.of("org.junit.platform.commons.util.classes.AVanillaEmpty",
-			"org.junit.platform.commons.util.classes.BVanillaEmpty");
-		assertThat(executionConditions).filteredOn(ClassNamePatternFilterUtils.includeMatchingClassNames(pattern)) //
-				.isEmpty();
-	}
-
-	//@formatter:off
-	@ValueSource(strings = {
-			"org.junit.platform.*",
-			"*.platform.*",
-			"*",
-			"*AVanillaEmpty, *BVanillaEmpty",
-			"*VanillaEmpty"
-	})
-	//@formatter:on
-	@ParameterizedTest
-	void alwaysIncludedClassName(String pattern) {
-		var executionConditions = List.of("org.junit.platform.commons.util.classes.AVanillaEmpty",
-			"org.junit.platform.commons.util.classes.BVanillaEmpty");
-		assertThat(executionConditions).filteredOn(ClassNamePatternFilterUtils.includeMatchingClassNames(pattern)) //
-				.hasSize(2);
-	}
-
-	//@formatter:off
-	@ValueSource(strings = {
-			"org.junit.platform.*",
-			"*.platform.*",
-			"*",
-			"*AVanillaEmpty, *BVanillaEmpty",
-			"*VanillaEmpty"
-	})
-	//@formatter:on
-	@ParameterizedTest
-	void includeAndExcludeSame(String pattern) {
-		var executionConditions = List.of("org.junit.platform.commons.util.classes.AVanillaEmpty",
-			"org.junit.platform.commons.util.classes.BVanillaEmpty");
-		assertThat(executionConditions).filteredOn(ClassNamePatternFilterUtils.includeMatchingClassNames(pattern)) //
-				.hasSize(2);
-	}
-
 }
