diff --git a/CHANGELOG.md b/CHANGELOG.md
index 1e690134c..7650582ac 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -12,6 +12,8 @@ Currently the versioning policy of this project follows [Semantic Versioning v2.
 - Fixed an `HSM_HIDING_METHOD` false positive when ECJ generates a synthetic method for an enum switch ([#3305](https://github.com/spotbugs/spotbugs/issues/3305))
 - Fix `AT_UNSAFE_RESOURCE_ACCESS_IN_THREAD` false negatives, detector depending on method order.
 - Fix `THROWS_METHOD_THROWS_CLAUSE_THROWABLE` reported in a method calling `MethodHandle.invokeExact` due to its polymorphic signature ([#3309](https://github.com/spotbugs/spotbugs/issues/3309))
+- Fix `AT_STALE_THREAD_WRITE_OF_PRIMITIVE` false positive in inner class ([#3310](https://github.com/spotbugs/spotbugs/issues/3310)).
+- Fix `AT_STALE_THREAD_WRITE_OF_PRIMITIVE` false positive for ECJ compiled enum switches ([#3316](https://github.com/spotbugs/spotbugs/issues/3316))
 
 ### Removed
 - Removed the `TLW_TWO_LOCK_NOTIFY`, `LI_LAZY_INIT_INSTANCE`, `BRSA_BAD_RESULTSET_ACCESS`, `BC_NULL_INSTANCEOF`, `NP_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR` and `RCN_REDUNDANT_CHECKED_NULL_COMPARISON` deprecated bug patterns.
diff --git a/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/SharedVariableAtomicityDetector.java b/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/SharedVariableAtomicityDetector.java
index 64f12afc3..75c78306b 100644
--- a/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/SharedVariableAtomicityDetector.java
+++ b/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/SharedVariableAtomicityDetector.java
@@ -140,13 +140,13 @@ public class SharedVariableAtomicityDetector extends OpcodeStackDetector {
 
     private void collectFieldReadsAndInnerMethodCalls(int seen, XMethod method) {
         if (seen == Const.GETFIELD || seen == Const.GETSTATIC) {
-            addNonFinalFields(getXFieldOperand(), method, readFieldsByMethods);
+            addNonFinalFieldsOfClass(getXFieldOperand(), method, readFieldsByMethods);
 
         } else if (seen == Const.IFGE || seen == Const.IFGT || seen == Const.IFLT || seen == Const.IFLE || seen == Const.IFNE || seen == Const.IFEQ) {
-            XField lhs = stack.getStackItem(0).getXField();
+            XField lhs = stack.getStackDepth() > 0 ? stack.getStackItem(0).getXField() : null;
             XField rhs = stack.getStackDepth() > 1 ? stack.getStackItem(1).getXField() : null;
-            addNonFinalFields(lhs, method, readFieldsByMethods);
-            addNonFinalFields(rhs, method, readFieldsByMethods);
+            addNonFinalFieldsOfClass(lhs, method, readFieldsByMethods);
+            addNonFinalFieldsOfClass(rhs, method, readFieldsByMethods);
 
         } else if (seen == Const.INVOKEINTERFACE || seen == Const.INVOKESPECIAL || seen == Const.INVOKEVIRTUAL || seen == Const.INVOKESTATIC) {
             XMethod calledMethod = getXMethodOperand();
@@ -156,8 +156,8 @@ public class SharedVariableAtomicityDetector extends OpcodeStackDetector {
         }
     }
 
-    private void addNonFinalFields(XField field, XMethod method, Map<XMethod, Set<XField>> map) {
-        if (field != null && !field.isFinal()) {
+    private void addNonFinalFieldsOfClass(XField field, XMethod method, Map<XMethod, Set<XField>> map) {
+        if (field != null && !field.isFinal() && !field.isSynthetic() && field.getClassDescriptor().equals(method.getClassDescriptor())) {
             map.computeIfAbsent(method, k -> new HashSet<>()).add(field);
         }
     }
@@ -191,12 +191,12 @@ public class SharedVariableAtomicityDetector extends OpcodeStackDetector {
     private void checkAndReportBug(int seen, XMethod method) {
         if (seen == Const.GETFIELD || seen == Const.GETSTATIC) {
             XField field = getXFieldOperand();
-            if (field != null) {
+            if (field != null && !field.isSynthetic()) {
                 relevantFields.add(field);
             }
         } else if (seen == Const.PUTFIELD || seen == Const.PUTSTATIC) {
             XField field = getXFieldOperand();
-            if (field != null && !field.isFinal()) {
+            if (field != null && !field.isFinal() && !field.isSynthetic() && field.getClassDescriptor().equals(method.getClassDescriptor())) {
                 boolean fieldReadInOtherMethod = mapContainsFieldWithOtherMethod(field, method, readFieldsByMethods);
                 if (fieldReadInOtherMethod) {
                     if (!relevantFields.isEmpty() && relevantFields.contains(field) && isPrimitiveOrItsBoxingType(field.getSignature())) {
diff --git a/spotbugs/src/main/java/edu/umd/cs/findbugs/util/MultiThreadedCodeIdentifierUtils.java b/spotbugs/src/main/java/edu/umd/cs/findbugs/util/MultiThreadedCodeIdentifierUtils.java
index 728294ec2..ec52949b6 100644
--- a/spotbugs/src/main/java/edu/umd/cs/findbugs/util/MultiThreadedCodeIdentifierUtils.java
+++ b/spotbugs/src/main/java/edu/umd/cs/findbugs/util/MultiThreadedCodeIdentifierUtils.java
@@ -66,6 +66,11 @@ public class MultiThreadedCodeIdentifierUtils {
     }
 
     public static boolean isMethodMultiThreaded(Method method, ClassContext classContext) {
+        // TODO: probably should check that as well to avoid false positives?
+        // if (method.isSynthetic()) {
+        // return false;
+        // }
+
         if (method.isSynchronized()) {
             return true;
         }
@@ -118,6 +123,9 @@ public class MultiThreadedCodeIdentifierUtils {
     }
 
     private static boolean isFieldIndicatingMultiThreadedContainer(Field field) {
+        if (field.isSynthetic()) {
+            return false;
+        }
         return field.isVolatile() || isFromAtomicPackage(field.getSignature())
                 || isInstanceOfLock(ClassName.fromFieldSignatureToDottedClassName(field.getSignature()));
     }
diff --git a/spotbugsTestCases/src/classSamples/ecjSwitchTable/MyClass$MyEnum.class b/spotbugsTestCases/src/classSamples/ecjSwitchTable/MyClass$MyEnum.class
new file mode 100644
index 000000000..a5806d5c7
Binary files /dev/null and b/spotbugsTestCases/src/classSamples/ecjSwitchTable/MyClass$MyEnum.class differ
diff --git a/spotbugsTestCases/src/classSamples/ecjSwitchTable/MyClass.class b/spotbugsTestCases/src/classSamples/ecjSwitchTable/MyClass.class
new file mode 100644
index 000000000..f54941d6c
Binary files /dev/null and b/spotbugsTestCases/src/classSamples/ecjSwitchTable/MyClass.class differ
diff --git a/spotbugsTestCases/src/java/ghIssues/Issue3310.java b/spotbugsTestCases/src/java/ghIssues/Issue3310.java
new file mode 100644
index 000000000..5d66fce30
--- /dev/null
+++ b/spotbugsTestCases/src/java/ghIssues/Issue3310.java
@@ -0,0 +1,26 @@
+package ghIssues;
+
+import java.util.Map;
+
+public class Issue3310 {
+	private volatile int x;
+
+	public <K, V> Object test(Map<K, V> map, K key) {
+		Result result = new Result();
+		map.compute(key, (k, oldValue) -> {
+			V newValue = oldValue;
+			result.written = true;
+			return newValue;
+		});
+
+		if (result.written) {
+			return result;
+		} else {
+			return null;
+		}
+	}
+
+	public static class Result {
+		boolean written;
+	}
+}
