diff --git a/ktor-client/ktor-client-core/api/ktor-client-core.api b/ktor-client/ktor-client-core/api/ktor-client-core.api
index dfa0cb5cf..f6d545259 100644
--- a/ktor-client/ktor-client-core/api/ktor-client-core.api
+++ b/ktor-client/ktor-client-core/api/ktor-client-core.api
@@ -748,7 +748,6 @@ public final class io/ktor/client/plugins/internal/SaveBodyAbandonedReadExceptio
 }
 
 public final class io/ktor/client/plugins/observer/DelegatedCallKt {
-	public static final fun wrap (Lio/ktor/client/call/HttpClientCall;Lio/ktor/http/Headers;Lkotlin/jvm/functions/Function0;)Lio/ktor/client/call/HttpClientCall;
 	public static final fun wrap (Lio/ktor/client/call/HttpClientCall;Lio/ktor/utils/io/ByteReadChannel;Lio/ktor/http/Headers;)Lio/ktor/client/call/HttpClientCall;
 	public static final fun wrapWithContent (Lio/ktor/client/call/HttpClientCall;Lio/ktor/utils/io/ByteReadChannel;)Lio/ktor/client/call/HttpClientCall;
 	public static final fun wrapWithContent (Lio/ktor/client/call/HttpClientCall;Lkotlin/jvm/functions/Function0;)Lio/ktor/client/call/HttpClientCall;
diff --git a/ktor-client/ktor-client-core/api/ktor-client-core.klib.api b/ktor-client/ktor-client-core/api/ktor-client-core.klib.api
index 5e96cae44..d98087465 100644
--- a/ktor-client/ktor-client-core/api/ktor-client-core.klib.api
+++ b/ktor-client/ktor-client-core/api/ktor-client-core.klib.api
@@ -1367,7 +1367,6 @@ final var io.ktor.client.request/port // io.ktor.client.request/port|@io.ktor.cl
     final fun (io.ktor.client.request/HttpRequestBuilder).<get-port>(): kotlin/Int // io.ktor.client.request/port.<get-port>|<get-port>@io.ktor.client.request.HttpRequestBuilder(){}[0]
     final fun (io.ktor.client.request/HttpRequestBuilder).<set-port>(kotlin/Int) // io.ktor.client.request/port.<set-port>|<set-port>@io.ktor.client.request.HttpRequestBuilder(kotlin.Int){}[0]
 
-final fun (io.ktor.client.call/HttpClientCall).io.ktor.client.plugins.observer/wrap(io.ktor.http/Headers, kotlin/Function0<io.ktor.utils.io/ByteReadChannel>): io.ktor.client.call/HttpClientCall // io.ktor.client.plugins.observer/wrap|wrap@io.ktor.client.call.HttpClientCall(io.ktor.http.Headers;kotlin.Function0<io.ktor.utils.io.ByteReadChannel>){}[0]
 final fun (io.ktor.client.call/HttpClientCall).io.ktor.client.plugins.observer/wrap(io.ktor.utils.io/ByteReadChannel, io.ktor.http/Headers): io.ktor.client.call/HttpClientCall // io.ktor.client.plugins.observer/wrap|wrap@io.ktor.client.call.HttpClientCall(io.ktor.utils.io.ByteReadChannel;io.ktor.http.Headers){}[0]
 final fun (io.ktor.client.call/HttpClientCall).io.ktor.client.plugins.observer/wrapWithContent(io.ktor.utils.io/ByteReadChannel): io.ktor.client.call/HttpClientCall // io.ktor.client.plugins.observer/wrapWithContent|wrapWithContent@io.ktor.client.call.HttpClientCall(io.ktor.utils.io.ByteReadChannel){}[0]
 final fun (io.ktor.client.call/HttpClientCall).io.ktor.client.plugins.observer/wrapWithContent(kotlin/Function0<io.ktor.utils.io/ByteReadChannel>): io.ktor.client.call/HttpClientCall // io.ktor.client.plugins.observer/wrapWithContent|wrapWithContent@io.ktor.client.call.HttpClientCall(kotlin.Function0<io.ktor.utils.io.ByteReadChannel>){}[0]
diff --git a/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/observer/DelegatedCall.kt b/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/observer/DelegatedCall.kt
index 22bf5854b..57b7e1751 100644
--- a/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/observer/DelegatedCall.kt
+++ b/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/observer/DelegatedCall.kt
@@ -23,7 +23,7 @@ public fun HttpClientCall.wrapWithContent(content: ByteReadChannel): HttpClientC
 }
 
 /**
- * Wrap existing [HttpClientCall] with new content produced by the given [block].
+ * Wrap existing [HttpClientCall] with new [content].
  *
  * [Report a problem](https://ktor.io/feedback/?fqname=io.ktor.client.plugins.observer.wrapWithContent)
  */
@@ -40,25 +40,6 @@ public fun HttpClientCall.wrap(content: ByteReadChannel, headers: Headers): Http
     return DelegatedCall(client, content, this, headers)
 }
 
-/**
- * Wrap existing [HttpClientCall] with new [headers] and content produced by the given [block].
- * The [block] will be called each time the response content is requested.
- *
- * ```
- * // Example: Content decompression. See ContentEncoding implementation for full example
- * val originalContent = originalCall.response.content
- * val decodedCall = originalCall.wrap(headersOf("Content-Encoding", "identity")) {
- *     decodeGzip(originalContent) // returns a new ByteReadChannel with decoded content
- * }
- * ```
- *
- * [Report a problem](https://ktor.io/feedback/?fqname=io.ktor.client.plugins.observer.wrap)
- */
-@InternalAPI
-public fun HttpClientCall.wrap(headers: Headers, block: () -> ByteReadChannel): HttpClientCall {
-    return DelegatedCall(client, block, this, headers)
-}
-
 internal class DelegatedCall(
     client: HttpClient,
     block: () -> ByteReadChannel,
@@ -92,6 +73,13 @@ internal class DelegatedResponse(
     override val headers: Headers = origin.headers
 ) : HttpResponse() {
 
+    constructor(
+        call: HttpClientCall,
+        content: ByteReadChannel,
+        origin: HttpResponse,
+        headers: Headers = origin.headers
+    ) : this(call, { content }, origin, headers)
+
     override val rawContent: ByteReadChannel get() = block()
 
     override val coroutineContext: CoroutineContext = origin.coroutineContext
diff --git a/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/observer/ResponseObserver.kt b/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/observer/ResponseObserver.kt
index 0c066a9d9..de157b3b9 100644
--- a/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/observer/ResponseObserver.kt
+++ b/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/observer/ResponseObserver.kt
@@ -6,15 +6,13 @@ package io.ktor.client.plugins.observer
 
 import io.ktor.client.*
 import io.ktor.client.call.*
-import io.ktor.client.plugins.*
 import io.ktor.client.plugins.api.*
 import io.ktor.client.statement.*
 import io.ktor.util.*
 import io.ktor.util.pipeline.*
 import io.ktor.utils.io.*
-import kotlinx.coroutines.launch
-import kotlinx.coroutines.withContext
-import kotlin.coroutines.CoroutineContext
+import kotlinx.coroutines.*
+import kotlin.coroutines.*
 
 /**
  * [ResponseObserver] callback.
@@ -65,23 +63,18 @@ public val ResponseObserver: ClientPlugin<ResponseObserverConfig> = createClient
     on(AfterReceiveHook) { response ->
         if (filter?.invoke(response.call) == false) return@on
 
-        if (response.isSaved) {
-            withContext(getResponseObserverContext()) {
-                runCatching { responseHandler(response) }
-            }
-            proceedWith(response)
-            return@on
-        }
-
         val (loggingContent, responseContent) = response.rawContent.split(response)
 
         val newResponse = response.call.wrapWithContent(responseContent).response
         val sideResponse = response.call.wrapWithContent(loggingContent).response
 
-        // Launch responseHandler in parallel as we don't want to wait for its finish for streaming responses
         client.launch(getResponseObserverContext()) {
             runCatching { responseHandler(sideResponse) }
-            runCatching { sideResponse.rawContent.discard() }
+
+            val content = sideResponse.rawContent
+            if (!content.isClosedForRead) {
+                runCatching { content.discard() }
+            }
         }
 
         proceedWith(newResponse)
diff --git a/ktor-client/ktor-client-plugins/ktor-client-encoding/common/src/ContentEncoding.kt b/ktor-client/ktor-client-plugins/ktor-client-encoding/common/src/ContentEncoding.kt
index 51df742b9..1c6bda867 100644
--- a/ktor-client/ktor-client-plugins/ktor-client-encoding/common/src/ContentEncoding.kt
+++ b/ktor-client/ktor-client-plugins/ktor-client-encoding/common/src/ContentEncoding.kt
@@ -128,28 +128,24 @@ public val ContentEncoding: ClientPlugin<ContentEncodingConfig> = createClientPl
         }
     }
 
-    fun HttpResponse.decodeContent(encoders: List<ContentEncoder>): ByteReadChannel {
-        var current = rawContent
-        for (encoder in encoders) {
-            LOGGER.trace { "Decoding response with $encoder for ${call.request.url}" }
-            current = encoder.decode(current, coroutineContext)
-        }
-
-        return current
-    }
-
     fun CoroutineScope.decode(response: HttpResponse): HttpResponse {
-        val contentEncodingHeader = response.headers[HttpHeaders.ContentEncoding] ?: run {
-            LOGGER.trace {
-                "Empty or no Content-Encoding header in response. " +
-                    "Skipping ContentEncoding for ${response.call.request.url}"
+        val encodings =
+            response.headers[HttpHeaders.ContentEncoding]?.split(",")?.map { it.trim().lowercase() } ?: run {
+                LOGGER.trace(
+                    "Empty or no Content-Encoding header in response. " +
+                        "Skipping ContentEncoding for ${response.call.request.url}"
+                )
+                return response
             }
-            return response
-        }
-        val encodings = contentEncodingHeader.split(",").map { it.trim().lowercase() }
 
-        val selectedEncoders = encodings.asReversed().map { encoding ->
-            encoders[encoding] ?: throw UnsupportedContentEncodingException(encoding)
+        var current = response.rawContent
+        for (encoding in encodings.reversed()) {
+            val encoder: Encoder = encoders[encoding] ?: throw UnsupportedContentEncodingException(encoding)
+
+            LOGGER.trace("Decoding response with $encoder for ${response.call.request.url}")
+            with(encoder) {
+                current = decode(current, response.coroutineContext)
+            }
         }
 
         val headers = headers {
@@ -170,13 +166,13 @@ public val ContentEncoding: ClientPlugin<ContentEncodingConfig> = createClientPl
             }
         }
         response.call.attributes.put(DecompressionListAttribute, encodings)
-        return response.call.wrap(headers) { response.decodeContent(selectedEncoders) }.response
+        return response.call.wrap(current, headers).response
     }
 
     onRequest { request, _ ->
         if (!mode.response) return@onRequest
         if (request.headers.contains(HttpHeaders.AcceptEncoding)) return@onRequest
-        LOGGER.trace { "Adding Accept-Encoding=$requestHeader for ${request.url}" }
+        LOGGER.trace("Adding Accept-Encoding=$requestHeader for ${request.url}")
         request.headers[HttpHeaders.AcceptEncoding] = requestHeader
     }
 
@@ -184,11 +180,11 @@ public val ContentEncoding: ClientPlugin<ContentEncodingConfig> = createClientPl
         if (!mode.request) return@on null
 
         val encoderNames = request.attributes.getOrNull(CompressionListAttribute) ?: run {
-            LOGGER.trace { "Skipping request compression for ${request.url} because no compressions set" }
+            LOGGER.trace("Skipping request compression for ${request.url} because no compressions set")
             return@on null
         }
 
-        LOGGER.trace { "Compressing request body for ${request.url} using $encoderNames" }
+        LOGGER.trace("Compressing request body for ${request.url} using $encoderNames")
         val selectedEncoders = encoderNames.map {
             encoders[it] ?: throw UnsupportedContentEncodingException(it)
         }
diff --git a/ktor-client/ktor-client-plugins/ktor-client-logging/common/src/io/ktor/client/plugins/logging/Logging.kt b/ktor-client/ktor-client-plugins/ktor-client-logging/common/src/io/ktor/client/plugins/logging/Logging.kt
index 6645093d8..4fff79286 100644
--- a/ktor-client/ktor-client-plugins/ktor-client-logging/common/src/io/ktor/client/plugins/logging/Logging.kt
+++ b/ktor-client/ktor-client-plugins/ktor-client-logging/common/src/io/ktor/client/plugins/logging/Logging.kt
@@ -6,8 +6,8 @@ package io.ktor.client.plugins.logging
 
 import io.ktor.client.*
 import io.ktor.client.call.*
-import io.ktor.client.plugins.*
 import io.ktor.client.plugins.api.*
+import io.ktor.client.plugins.isSaved
 import io.ktor.client.plugins.observer.*
 import io.ktor.client.request.*
 import io.ktor.client.statement.*
@@ -18,8 +18,13 @@ import io.ktor.util.*
 import io.ktor.util.pipeline.*
 import io.ktor.utils.io.*
 import io.ktor.utils.io.charsets.*
-import io.ktor.utils.io.core.*
-import kotlinx.coroutines.*
+import io.ktor.utils.io.core.readText
+import io.ktor.utils.io.core.writeFully
+import kotlinx.coroutines.DelicateCoroutinesApi
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.GlobalScope
+import kotlinx.coroutines.async
+import kotlinx.coroutines.launch
 import kotlinx.io.Buffer
 
 private val ClientCallLogger = AttributeKey<HttpClientCallLogger>("CallLogger")
@@ -228,27 +233,22 @@ public val Logging: ClientPlugin<LoggingConfig> = createClientPlugin("Logging",
                 logRequestBody(content, bytes.size.toLong(), headers, method, logLines, ByteReadChannel(bytes))
                 null
             }
-
             is OutgoingContent.ContentWrapper -> {
                 logOutgoingContent(content.delegate(), method, headers, logLines, process)
             }
-
             is OutgoingContent.NoContent -> {
                 logLines.add("--> END ${method.value}")
                 null
             }
-
             is OutgoingContent.ProtocolUpgrade -> {
                 logLines.add("--> END ${method.value}")
                 null
             }
-
             is OutgoingContent.ReadChannelContent -> {
                 val (origChannel, newChannel) = content.readFrom().split(client)
                 logRequestBody(content, content.contentLength, headers, method, logLines, newChannel)
                 LoggedContent(content, origChannel)
             }
-
             is OutgoingContent.WriteChannelContent -> {
                 val channel = ByteChannel()
 
@@ -604,13 +604,7 @@ public val Logging: ClientPlugin<LoggingConfig> = createClientPlugin("Logging",
             throw cause
         } finally {
             callLogger.logResponseHeader(header.toString())
-            if (failed || !level.body) {
-                callLogger.closeResponseLog()
-            } else if (level.body && response.isSaved) {
-                // Log only saved response body here. Streaming responses are logged via ResponseObserver
-                callLogger.logResponseBody(response)
-                callLogger.closeResponseLog()
-            }
+            if (failed || !level.body) callLogger.closeResponseLog()
         }
     }
 
@@ -637,19 +631,24 @@ public val Logging: ClientPlugin<LoggingConfig> = createClientPlugin("Logging",
 
     if (!level.body) return@createClientPlugin
 
-    val responseObserver = ResponseObserver.prepare {
-        // Use observer to log streaming responses (responses that aren't saved in memory)
-        filter { !it.response.isSaved }
-
-        onResponse { response ->
-            if (level == LogLevel.NONE || response.call.attributes.contains(DisableLogging)) return@onResponse
+    @OptIn(InternalAPI::class)
+    val observer: ResponseHandler = observer@{
+        if (level == LogLevel.NONE || it.call.attributes.contains(DisableLogging)) {
+            return@observer
+        }
 
-            val callLogger = response.call.attributes[ClientCallLogger]
-            callLogger.logResponseBody(response)
+        val callLogger = it.call.attributes[ClientCallLogger]
+        val log = StringBuilder()
+        try {
+            logResponseBody(log, it.contentType(), it.rawContent)
+        } catch (_: Throwable) {
+        } finally {
+            callLogger.logResponseBody(log.toString().trim())
             callLogger.closeResponseLog()
         }
     }
-    ResponseObserver.install(responseObserver, client)
+
+    ResponseObserver.install(ResponseObserver.prepare { onResponse(observer) }, client)
 }
 
 private fun Url.pathQuery(): String {
diff --git a/ktor-client/ktor-client-plugins/ktor-client-logging/common/src/io/ktor/client/plugins/logging/LoggingUtils.kt b/ktor-client/ktor-client-plugins/ktor-client-logging/common/src/io/ktor/client/plugins/logging/LoggingUtils.kt
index bdd854f4f..0e079d329 100644
--- a/ktor-client/ktor-client-plugins/ktor-client-logging/common/src/io/ktor/client/plugins/logging/LoggingUtils.kt
+++ b/ktor-client/ktor-client-plugins/ktor-client-logging/common/src/io/ktor/client/plugins/logging/LoggingUtils.kt
@@ -52,25 +52,17 @@ internal suspend inline fun ByteReadChannel.tryReadText(charset: Charset): Strin
     null
 }
 
-@OptIn(InternalAPI::class)
-internal suspend fun HttpClientCallLogger.logResponseBody(response: HttpResponse) {
-    val log = StringBuilder()
-    try {
-        log.appendResponseBody(response.contentType(), response.rawContent)
-    } catch (_: Throwable) {
-    } finally {
-        logResponseBody(log.toString().trim())
-    }
-}
-
-internal suspend fun StringBuilder.appendResponseBody(
+internal suspend fun logResponseBody(
+    log: StringBuilder,
     contentType: ContentType?,
     content: ByteReadChannel
 ) {
-    appendLine("BODY Content-Type: $contentType")
-    appendLine("BODY START")
+    with(log) {
+        appendLine("BODY Content-Type: $contentType")
+        appendLine("BODY START")
 
-    val message = content.tryReadText(contentType?.charset() ?: Charsets.UTF_8) ?: "[response body omitted]"
-    appendLine(message)
-    append("BODY END")
+        val message = content.tryReadText(contentType?.charset() ?: Charsets.UTF_8) ?: "[response body omitted]"
+        appendLine(message)
+        append("BODY END")
+    }
 }
diff --git a/ktor-client/ktor-client-tests/common/test/io/ktor/client/tests/LoggingMockedTests.kt b/ktor-client/ktor-client-tests/common/test/io/ktor/client/tests/LoggingMockedTests.kt
index a4161d2e0..07cdbbccc 100644
--- a/ktor-client/ktor-client-tests/common/test/io/ktor/client/tests/LoggingMockedTests.kt
+++ b/ktor-client/ktor-client-tests/common/test/io/ktor/client/tests/LoggingMockedTests.kt
@@ -6,7 +6,6 @@ package io.ktor.client.tests
 
 import io.ktor.client.call.*
 import io.ktor.client.engine.mock.*
-import io.ktor.client.plugins.*
 import io.ktor.client.plugins.logging.*
 import io.ktor.client.request.*
 import io.ktor.client.request.forms.*
@@ -21,7 +20,6 @@ import kotlinx.coroutines.flow.channelFlow
 import kotlinx.coroutines.launch
 import kotlinx.coroutines.withTimeout
 import kotlin.test.Test
-import kotlin.test.assertEquals
 import kotlin.test.assertTrue
 import kotlin.time.Duration.Companion.seconds
 
@@ -345,32 +343,4 @@ class LoggingMockedTests {
             }
         }
     }
-
-    // Issue: KTOR-6474
-    @Test
-    fun testLoggingWithResponseValidator() = testWithEngine(MockEngine) {
-        val responseBody = "Hello, world!"
-
-        config {
-            install(Logging) {
-                level = LogLevel.ALL
-            }
-
-            HttpResponseValidator {
-                validateResponse {
-                    assertEquals(responseBody, it.bodyAsText())
-                }
-            }
-
-            engine {
-                addHandler {
-                    respondOk(responseBody)
-                }
-            }
-        }
-
-        test { client ->
-            assertEquals(responseBody, client.get("").bodyAsText())
-        }
-    }
 }
diff --git a/ktor-client/ktor-client-tests/common/test/io/ktor/client/tests/ResponseObserverTest.kt b/ktor-client/ktor-client-tests/common/test/io/ktor/client/tests/ResponseObserverTest.kt
index 669245119..e9847f472 100644
--- a/ktor-client/ktor-client-tests/common/test/io/ktor/client/tests/ResponseObserverTest.kt
+++ b/ktor-client/ktor-client-tests/common/test/io/ktor/client/tests/ResponseObserverTest.kt
@@ -4,13 +4,12 @@
 
 package io.ktor.client.tests
 
-import io.ktor.client.engine.mock.*
-import io.ktor.client.plugins.*
 import io.ktor.client.plugins.observer.*
 import io.ktor.client.request.*
-import io.ktor.client.statement.*
 import io.ktor.client.test.base.*
-import kotlin.test.*
+import kotlin.test.Test
+import kotlin.test.assertFalse
+import kotlin.test.assertTrue
 
 class ResponseObserverTest : ClientLoader() {
     private var observerCalled = false
@@ -93,44 +92,4 @@ class ResponseObserverTest : ClientLoader() {
             assertFalse { observerCalled }
         }
     }
-
-    @Test
-    fun testSavedResponseCanBeReadMultipleTimes() = testWithEngine(MockEngine) {
-        val bodyContent = "Hello"
-        var wasSaved: Boolean? = null
-
-        suspend fun assertBodyCanBeReadMultipleTimes(response: HttpResponse) {
-            assertEquals(bodyContent, response.bodyAsText(), "First read failed")
-            assertEquals(bodyContent, response.bodyAsText(), "It should be possible to read body multiple times")
-        }
-
-        config {
-            install(ResponseObserver) {
-                onResponse { response ->
-                    wasSaved = response.isSaved
-                    // In the response observer itself
-                    assertBodyCanBeReadMultipleTimes(response)
-                }
-            }
-
-            engine {
-                addHandler { respondOk(bodyContent) }
-            }
-        }
-
-        test { client ->
-            // In the pipeline after ResponseObserver
-            client.receivePipeline.intercept(HttpReceivePipeline.After) { response ->
-                assertBodyCanBeReadMultipleTimes(response)
-                proceedWith(response)
-            }
-
-            val response = client.get("/")
-            assertNotNull(wasSaved, "Response observer should be called")
-            assertTrue(wasSaved!!, "Response should be saved before reaching the response observer")
-
-            // After all pipelines
-            assertBodyCanBeReadMultipleTimes(response)
-        }
-    }
 }
