diff --git a/ktor-client/ktor-client-core/api/ktor-client-core.api b/ktor-client/ktor-client-core/api/ktor-client-core.api
index f6d545259..dfa0cb5cf 100644
--- a/ktor-client/ktor-client-core/api/ktor-client-core.api
+++ b/ktor-client/ktor-client-core/api/ktor-client-core.api
@@ -748,6 +748,7 @@ public final class io/ktor/client/plugins/internal/SaveBodyAbandonedReadExceptio
 }
 
 public final class io/ktor/client/plugins/observer/DelegatedCallKt {
+	public static final fun wrap (Lio/ktor/client/call/HttpClientCall;Lio/ktor/http/Headers;Lkotlin/jvm/functions/Function0;)Lio/ktor/client/call/HttpClientCall;
 	public static final fun wrap (Lio/ktor/client/call/HttpClientCall;Lio/ktor/utils/io/ByteReadChannel;Lio/ktor/http/Headers;)Lio/ktor/client/call/HttpClientCall;
 	public static final fun wrapWithContent (Lio/ktor/client/call/HttpClientCall;Lio/ktor/utils/io/ByteReadChannel;)Lio/ktor/client/call/HttpClientCall;
 	public static final fun wrapWithContent (Lio/ktor/client/call/HttpClientCall;Lkotlin/jvm/functions/Function0;)Lio/ktor/client/call/HttpClientCall;
diff --git a/ktor-client/ktor-client-core/api/ktor-client-core.klib.api b/ktor-client/ktor-client-core/api/ktor-client-core.klib.api
index d98087465..5e96cae44 100644
--- a/ktor-client/ktor-client-core/api/ktor-client-core.klib.api
+++ b/ktor-client/ktor-client-core/api/ktor-client-core.klib.api
@@ -1367,6 +1367,7 @@ final var io.ktor.client.request/port // io.ktor.client.request/port|@io.ktor.cl
     final fun (io.ktor.client.request/HttpRequestBuilder).<get-port>(): kotlin/Int // io.ktor.client.request/port.<get-port>|<get-port>@io.ktor.client.request.HttpRequestBuilder(){}[0]
     final fun (io.ktor.client.request/HttpRequestBuilder).<set-port>(kotlin/Int) // io.ktor.client.request/port.<set-port>|<set-port>@io.ktor.client.request.HttpRequestBuilder(kotlin.Int){}[0]
 
+final fun (io.ktor.client.call/HttpClientCall).io.ktor.client.plugins.observer/wrap(io.ktor.http/Headers, kotlin/Function0<io.ktor.utils.io/ByteReadChannel>): io.ktor.client.call/HttpClientCall // io.ktor.client.plugins.observer/wrap|wrap@io.ktor.client.call.HttpClientCall(io.ktor.http.Headers;kotlin.Function0<io.ktor.utils.io.ByteReadChannel>){}[0]
 final fun (io.ktor.client.call/HttpClientCall).io.ktor.client.plugins.observer/wrap(io.ktor.utils.io/ByteReadChannel, io.ktor.http/Headers): io.ktor.client.call/HttpClientCall // io.ktor.client.plugins.observer/wrap|wrap@io.ktor.client.call.HttpClientCall(io.ktor.utils.io.ByteReadChannel;io.ktor.http.Headers){}[0]
 final fun (io.ktor.client.call/HttpClientCall).io.ktor.client.plugins.observer/wrapWithContent(io.ktor.utils.io/ByteReadChannel): io.ktor.client.call/HttpClientCall // io.ktor.client.plugins.observer/wrapWithContent|wrapWithContent@io.ktor.client.call.HttpClientCall(io.ktor.utils.io.ByteReadChannel){}[0]
 final fun (io.ktor.client.call/HttpClientCall).io.ktor.client.plugins.observer/wrapWithContent(kotlin/Function0<io.ktor.utils.io/ByteReadChannel>): io.ktor.client.call/HttpClientCall // io.ktor.client.plugins.observer/wrapWithContent|wrapWithContent@io.ktor.client.call.HttpClientCall(kotlin.Function0<io.ktor.utils.io.ByteReadChannel>){}[0]
diff --git a/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/observer/DelegatedCall.kt b/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/observer/DelegatedCall.kt
index 57b7e1751..22bf5854b 100644
--- a/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/observer/DelegatedCall.kt
+++ b/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/observer/DelegatedCall.kt
@@ -23,7 +23,7 @@ public fun HttpClientCall.wrapWithContent(content: ByteReadChannel): HttpClientC
 }
 
 /**
- * Wrap existing [HttpClientCall] with new [content].
+ * Wrap existing [HttpClientCall] with new content produced by the given [block].
  *
  * [Report a problem](https://ktor.io/feedback/?fqname=io.ktor.client.plugins.observer.wrapWithContent)
  */
@@ -40,6 +40,25 @@ public fun HttpClientCall.wrap(content: ByteReadChannel, headers: Headers): Http
     return DelegatedCall(client, content, this, headers)
 }
 
+/**
+ * Wrap existing [HttpClientCall] with new [headers] and content produced by the given [block].
+ * The [block] will be called each time the response content is requested.
+ *
+ * ```
+ * // Example: Content decompression. See ContentEncoding implementation for full example
+ * val originalContent = originalCall.response.content
+ * val decodedCall = originalCall.wrap(headersOf("Content-Encoding", "identity")) {
+ *     decodeGzip(originalContent) // returns a new ByteReadChannel with decoded content
+ * }
+ * ```
+ *
+ * [Report a problem](https://ktor.io/feedback/?fqname=io.ktor.client.plugins.observer.wrap)
+ */
+@InternalAPI
+public fun HttpClientCall.wrap(headers: Headers, block: () -> ByteReadChannel): HttpClientCall {
+    return DelegatedCall(client, block, this, headers)
+}
+
 internal class DelegatedCall(
     client: HttpClient,
     block: () -> ByteReadChannel,
@@ -73,13 +92,6 @@ internal class DelegatedResponse(
     override val headers: Headers = origin.headers
 ) : HttpResponse() {
 
-    constructor(
-        call: HttpClientCall,
-        content: ByteReadChannel,
-        origin: HttpResponse,
-        headers: Headers = origin.headers
-    ) : this(call, { content }, origin, headers)
-
     override val rawContent: ByteReadChannel get() = block()
 
     override val coroutineContext: CoroutineContext = origin.coroutineContext
diff --git a/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/observer/ResponseObserver.kt b/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/observer/ResponseObserver.kt
index de157b3b9..0c066a9d9 100644
--- a/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/observer/ResponseObserver.kt
+++ b/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/observer/ResponseObserver.kt
@@ -6,13 +6,15 @@ package io.ktor.client.plugins.observer
 
 import io.ktor.client.*
 import io.ktor.client.call.*
+import io.ktor.client.plugins.*
 import io.ktor.client.plugins.api.*
 import io.ktor.client.statement.*
 import io.ktor.util.*
 import io.ktor.util.pipeline.*
 import io.ktor.utils.io.*
-import kotlinx.coroutines.*
-import kotlin.coroutines.*
+import kotlinx.coroutines.launch
+import kotlinx.coroutines.withContext
+import kotlin.coroutines.CoroutineContext
 
 /**
  * [ResponseObserver] callback.
@@ -63,18 +65,23 @@ public val ResponseObserver: ClientPlugin<ResponseObserverConfig> = createClient
     on(AfterReceiveHook) { response ->
         if (filter?.invoke(response.call) == false) return@on
 
+        if (response.isSaved) {
+            withContext(getResponseObserverContext()) {
+                runCatching { responseHandler(response) }
+            }
+            proceedWith(response)
+            return@on
+        }
+
         val (loggingContent, responseContent) = response.rawContent.split(response)
 
         val newResponse = response.call.wrapWithContent(responseContent).response
         val sideResponse = response.call.wrapWithContent(loggingContent).response
 
+        // Launch responseHandler in parallel as we don't want to wait for its finish for streaming responses
         client.launch(getResponseObserverContext()) {
             runCatching { responseHandler(sideResponse) }
-
-            val content = sideResponse.rawContent
-            if (!content.isClosedForRead) {
-                runCatching { content.discard() }
-            }
+            runCatching { sideResponse.rawContent.discard() }
         }
 
         proceedWith(newResponse)
diff --git a/ktor-client/ktor-client-plugins/ktor-client-encoding/common/src/ContentEncoding.kt b/ktor-client/ktor-client-plugins/ktor-client-encoding/common/src/ContentEncoding.kt
index 1c6bda867..51df742b9 100644
--- a/ktor-client/ktor-client-plugins/ktor-client-encoding/common/src/ContentEncoding.kt
+++ b/ktor-client/ktor-client-plugins/ktor-client-encoding/common/src/ContentEncoding.kt
@@ -128,24 +128,28 @@ public val ContentEncoding: ClientPlugin<ContentEncodingConfig> = createClientPl
         }
     }
 
-    fun CoroutineScope.decode(response: HttpResponse): HttpResponse {
-        val encodings =
-            response.headers[HttpHeaders.ContentEncoding]?.split(",")?.map { it.trim().lowercase() } ?: run {
-                LOGGER.trace(
-                    "Empty or no Content-Encoding header in response. " +
-                        "Skipping ContentEncoding for ${response.call.request.url}"
-                )
-                return response
-            }
+    fun HttpResponse.decodeContent(encoders: List<ContentEncoder>): ByteReadChannel {
+        var current = rawContent
+        for (encoder in encoders) {
+            LOGGER.trace { "Decoding response with $encoder for ${call.request.url}" }
+            current = encoder.decode(current, coroutineContext)
+        }
 
-        var current = response.rawContent
-        for (encoding in encodings.reversed()) {
-            val encoder: Encoder = encoders[encoding] ?: throw UnsupportedContentEncodingException(encoding)
+        return current
+    }
 
-            LOGGER.trace("Decoding response with $encoder for ${response.call.request.url}")
-            with(encoder) {
-                current = decode(current, response.coroutineContext)
+    fun CoroutineScope.decode(response: HttpResponse): HttpResponse {
+        val contentEncodingHeader = response.headers[HttpHeaders.ContentEncoding] ?: run {
+            LOGGER.trace {
+                "Empty or no Content-Encoding header in response. " +
+                    "Skipping ContentEncoding for ${response.call.request.url}"
             }
+            return response
+        }
+        val encodings = contentEncodingHeader.split(",").map { it.trim().lowercase() }
+
+        val selectedEncoders = encodings.asReversed().map { encoding ->
+            encoders[encoding] ?: throw UnsupportedContentEncodingException(encoding)
         }
 
         val headers = headers {
@@ -166,13 +170,13 @@ public val ContentEncoding: ClientPlugin<ContentEncodingConfig> = createClientPl
             }
         }
         response.call.attributes.put(DecompressionListAttribute, encodings)
-        return response.call.wrap(current, headers).response
+        return response.call.wrap(headers) { response.decodeContent(selectedEncoders) }.response
     }
 
     onRequest { request, _ ->
         if (!mode.response) return@onRequest
         if (request.headers.contains(HttpHeaders.AcceptEncoding)) return@onRequest
-        LOGGER.trace("Adding Accept-Encoding=$requestHeader for ${request.url}")
+        LOGGER.trace { "Adding Accept-Encoding=$requestHeader for ${request.url}" }
         request.headers[HttpHeaders.AcceptEncoding] = requestHeader
     }
 
@@ -180,11 +184,11 @@ public val ContentEncoding: ClientPlugin<ContentEncodingConfig> = createClientPl
         if (!mode.request) return@on null
 
         val encoderNames = request.attributes.getOrNull(CompressionListAttribute) ?: run {
-            LOGGER.trace("Skipping request compression for ${request.url} because no compressions set")
+            LOGGER.trace { "Skipping request compression for ${request.url} because no compressions set" }
             return@on null
         }
 
-        LOGGER.trace("Compressing request body for ${request.url} using $encoderNames")
+        LOGGER.trace { "Compressing request body for ${request.url} using $encoderNames" }
         val selectedEncoders = encoderNames.map {
             encoders[it] ?: throw UnsupportedContentEncodingException(it)
         }
diff --git a/ktor-client/ktor-client-plugins/ktor-client-logging/common/src/io/ktor/client/plugins/logging/Logging.kt b/ktor-client/ktor-client-plugins/ktor-client-logging/common/src/io/ktor/client/plugins/logging/Logging.kt
index 4fff79286..6645093d8 100644
--- a/ktor-client/ktor-client-plugins/ktor-client-logging/common/src/io/ktor/client/plugins/logging/Logging.kt
+++ b/ktor-client/ktor-client-plugins/ktor-client-logging/common/src/io/ktor/client/plugins/logging/Logging.kt
@@ -6,8 +6,8 @@ package io.ktor.client.plugins.logging
 
 import io.ktor.client.*
 import io.ktor.client.call.*
+import io.ktor.client.plugins.*
 import io.ktor.client.plugins.api.*
-import io.ktor.client.plugins.isSaved
 import io.ktor.client.plugins.observer.*
 import io.ktor.client.request.*
 import io.ktor.client.statement.*
@@ -18,13 +18,8 @@ import io.ktor.util.*
 import io.ktor.util.pipeline.*
 import io.ktor.utils.io.*
 import io.ktor.utils.io.charsets.*
-import io.ktor.utils.io.core.readText
-import io.ktor.utils.io.core.writeFully
-import kotlinx.coroutines.DelicateCoroutinesApi
-import kotlinx.coroutines.Dispatchers
-import kotlinx.coroutines.GlobalScope
-import kotlinx.coroutines.async
-import kotlinx.coroutines.launch
+import io.ktor.utils.io.core.*
+import kotlinx.coroutines.*
 import kotlinx.io.Buffer
 
 private val ClientCallLogger = AttributeKey<HttpClientCallLogger>("CallLogger")
@@ -233,22 +228,27 @@ public val Logging: ClientPlugin<LoggingConfig> = createClientPlugin("Logging",
                 logRequestBody(content, bytes.size.toLong(), headers, method, logLines, ByteReadChannel(bytes))
                 null
             }
+
             is OutgoingContent.ContentWrapper -> {
                 logOutgoingContent(content.delegate(), method, headers, logLines, process)
             }
+
             is OutgoingContent.NoContent -> {
                 logLines.add("--> END ${method.value}")
                 null
             }
+
             is OutgoingContent.ProtocolUpgrade -> {
                 logLines.add("--> END ${method.value}")
                 null
             }
+
             is OutgoingContent.ReadChannelContent -> {
                 val (origChannel, newChannel) = content.readFrom().split(client)
                 logRequestBody(content, content.contentLength, headers, method, logLines, newChannel)
                 LoggedContent(content, origChannel)
             }
+
             is OutgoingContent.WriteChannelContent -> {
                 val channel = ByteChannel()
 
@@ -604,7 +604,13 @@ public val Logging: ClientPlugin<LoggingConfig> = createClientPlugin("Logging",
             throw cause
         } finally {
             callLogger.logResponseHeader(header.toString())
-            if (failed || !level.body) callLogger.closeResponseLog()
+            if (failed || !level.body) {
+                callLogger.closeResponseLog()
+            } else if (level.body && response.isSaved) {
+                // Log only saved response body here. Streaming responses are logged via ResponseObserver
+                callLogger.logResponseBody(response)
+                callLogger.closeResponseLog()
+            }
         }
     }
 
@@ -631,24 +637,19 @@ public val Logging: ClientPlugin<LoggingConfig> = createClientPlugin("Logging",
 
     if (!level.body) return@createClientPlugin
 
-    @OptIn(InternalAPI::class)
-    val observer: ResponseHandler = observer@{
-        if (level == LogLevel.NONE || it.call.attributes.contains(DisableLogging)) {
-            return@observer
-        }
+    val responseObserver = ResponseObserver.prepare {
+        // Use observer to log streaming responses (responses that aren't saved in memory)
+        filter { !it.response.isSaved }
 
-        val callLogger = it.call.attributes[ClientCallLogger]
-        val log = StringBuilder()
-        try {
-            logResponseBody(log, it.contentType(), it.rawContent)
-        } catch (_: Throwable) {
-        } finally {
-            callLogger.logResponseBody(log.toString().trim())
+        onResponse { response ->
+            if (level == LogLevel.NONE || response.call.attributes.contains(DisableLogging)) return@onResponse
+
+            val callLogger = response.call.attributes[ClientCallLogger]
+            callLogger.logResponseBody(response)
             callLogger.closeResponseLog()
         }
     }
-
-    ResponseObserver.install(ResponseObserver.prepare { onResponse(observer) }, client)
+    ResponseObserver.install(responseObserver, client)
 }
 
 private fun Url.pathQuery(): String {
diff --git a/ktor-client/ktor-client-plugins/ktor-client-logging/common/src/io/ktor/client/plugins/logging/LoggingUtils.kt b/ktor-client/ktor-client-plugins/ktor-client-logging/common/src/io/ktor/client/plugins/logging/LoggingUtils.kt
index 0e079d329..bdd854f4f 100644
--- a/ktor-client/ktor-client-plugins/ktor-client-logging/common/src/io/ktor/client/plugins/logging/LoggingUtils.kt
+++ b/ktor-client/ktor-client-plugins/ktor-client-logging/common/src/io/ktor/client/plugins/logging/LoggingUtils.kt
@@ -52,17 +52,25 @@ internal suspend inline fun ByteReadChannel.tryReadText(charset: Charset): Strin
     null
 }
 
-internal suspend fun logResponseBody(
-    log: StringBuilder,
+@OptIn(InternalAPI::class)
+internal suspend fun HttpClientCallLogger.logResponseBody(response: HttpResponse) {
+    val log = StringBuilder()
+    try {
+        log.appendResponseBody(response.contentType(), response.rawContent)
+    } catch (_: Throwable) {
+    } finally {
+        logResponseBody(log.toString().trim())
+    }
+}
+
+internal suspend fun StringBuilder.appendResponseBody(
     contentType: ContentType?,
     content: ByteReadChannel
 ) {
-    with(log) {
-        appendLine("BODY Content-Type: $contentType")
-        appendLine("BODY START")
+    appendLine("BODY Content-Type: $contentType")
+    appendLine("BODY START")
 
-        val message = content.tryReadText(contentType?.charset() ?: Charsets.UTF_8) ?: "[response body omitted]"
-        appendLine(message)
-        append("BODY END")
-    }
+    val message = content.tryReadText(contentType?.charset() ?: Charsets.UTF_8) ?: "[response body omitted]"
+    appendLine(message)
+    append("BODY END")
 }
