diff --git a/documentation/src/docs/asciidoc/user-guide/advanced-topics/launcher-api.adoc b/documentation/src/docs/asciidoc/user-guide/advanced-topics/launcher-api.adoc
index 2c8b25e7c..3daf564d1 100644
--- a/documentation/src/docs/asciidoc/user-guide/advanced-topics/launcher-api.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/advanced-topics/launcher-api.adoc
@@ -97,12 +97,12 @@ Registered implementations of `{LauncherSessionListener}` are notified when a
 and closed (when no more tests will be discovered or executed). They can be registered
 programmatically via the `{LauncherConfig}` that is passed to the `{LauncherFactory}`, or
 they can be discovered at runtime via Java's `{ServiceLoader}` mechanism and automatically
-registered with `LauncherSession` (unless automatic registration is disabled.)
+registered with `{LauncherSession}` (unless automatic registration is disabled.)
 
 [[launcher-api-launcher-session-listeners-tool-support]]
 ===== Tool Support
 
-The following build tools and IDEs are known to provide full support for `LauncherSession`:
+The following build tools and IDEs are known to provide full support for `{LauncherSession}`:
 
 * Gradle 4.6 and later
 * Maven Surefire/Failsafe 3.0.0-M6 and later
@@ -113,7 +113,7 @@ Other tools might also work but have not been tested explicitly.
 [[launcher-api-launcher-session-listeners-tool-example-usage]]
 ===== Example Usage
 
-A `LauncherSessionListener` is well suited for implementing once-per-JVM setup/teardown
+A `{LauncherSessionListener}` is well suited for implementing once-per-JVM setup/teardown
 behavior since it's called before the first and after the last test in a launcher session,
 respectively. The scope of a launcher session depends on the used IDE or build tool but
 usually corresponds to the lifecycle of the test JVM. A custom listener that starts an
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AfterAll.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AfterAll.java
index d40593801..a5ab2e1ab 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AfterAll.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AfterAll.java
@@ -43,8 +43,10 @@ import org.apiguardian.api.API;
  * <h2>Inheritance and Execution Order</h2>
  *
  * <p>{@code @AfterAll} methods are inherited from superclasses as long as
- * they are not <em>hidden</em> or <em>overridden</em>. Furthermore,
- * {@code @AfterAll} methods from superclasses will be executed after
+ * they are not <em>hidden</em> (default mode with {@code static} modifier), or
+ * <em>overridden</em>, or <em>superseded</em> (i.e., replaced based on
+ * signature only, irrespective of Java's visibility rules). Furthermore,
+ * {@code @AfterAll} methods from superclasses will be executed before
  * {@code @AfterAll} methods in subclasses.
  *
  * <p>Similarly, {@code @AfterAll} methods declared in an interface are
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AfterEach.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AfterEach.java
index 3595b3fab..c6340076e 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AfterEach.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AfterEach.java
@@ -36,8 +36,10 @@ import org.apiguardian.api.API;
  * <h2>Inheritance and Execution Order</h2>
  *
  * <p>{@code @AfterEach} methods are inherited from superclasses as long as
- * they are not overridden. Furthermore, {@code @AfterEach} methods from
- * superclasses will be executed after {@code @AfterEach} methods in subclasses.
+ * they are not overridden or <em>superseded</em> (i.e., replaced based on
+ * signature only, irrespective of Java's visibility rules). Furthermore,
+ * {@code @AfterEach} methods from superclasses will be executed after
+ * {@code @AfterEach} methods in subclasses.
  *
  * <p>Similarly, {@code @AfterEach} methods declared as <em>interface default
  * methods</em> are inherited as long as they are not overridden, and
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertIterableEquals.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertIterableEquals.java
index dd581398d..c0edc0825 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertIterableEquals.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertIterableEquals.java
@@ -103,7 +103,7 @@ class AssertIterableEquals {
 				return;
 			}
 
-			// If the pair is already under investigation, we fail in order to avoid infinite recursion.
+			// If the pair is already under investigation, we fail to avoid infinite recursion.
 			if (status == Status.UNDER_INVESTIGATION) {
 				indexes.removeLast();
 				failIterablesNotEqual(expected, actual, indexes, messageOrSupplier);
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/BeforeAll.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/BeforeAll.java
index 5023334c6..5c85c196d 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/BeforeAll.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/BeforeAll.java
@@ -43,7 +43,9 @@ import org.apiguardian.api.API;
  * <h2>Inheritance and Execution Order</h2>
  *
  * <p>{@code @BeforeAll} methods are inherited from superclasses as long as
- * they are not <em>hidden</em> or <em>overridden</em>. Furthermore,
+ * they are not <em>hidden</em> (default mode with {@code static} modifier), or
+ * <em>overridden</em>, or <em>superseded</em> (i.e., replaced based on
+ * signature only, irrespective of Java's visibility rules). Furthermore,
  * {@code @BeforeAll} methods from superclasses will be executed before
  * {@code @BeforeAll} methods in subclasses.
  *
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/BeforeEach.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/BeforeEach.java
index eb8fa9aaf..b6247315b 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/BeforeEach.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/BeforeEach.java
@@ -36,8 +36,10 @@ import org.apiguardian.api.API;
  * <h2>Inheritance and Execution Order</h2>
  *
  * <p>{@code @BeforeEach} methods are inherited from superclasses as long as
- * they are not overridden. Furthermore, {@code @BeforeEach} methods from
- * superclasses will be executed before {@code @BeforeEach} methods in subclasses.
+ * they are not overridden or <em>superseded</em> (i.e., replaced based on
+ * signature only, irrespective of Java's visibility rules). Furthermore,
+ * {@code @BeforeEach} methods from superclasses will be executed before
+ * {@code @BeforeEach} methods in subclasses.
  *
  * <p>Similarly, {@code @BeforeEach} methods declared as <em>interface default
  * methods</em> are inherited as long as they are not overridden, and
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/LifecycleMethodUtils.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/LifecycleMethodUtils.java
index 53a2a5c53..9b9a43a73 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/LifecycleMethodUtils.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/LifecycleMethodUtils.java
@@ -37,19 +37,21 @@ final class LifecycleMethodUtils {
 	}
 
 	static List<Method> findBeforeAllMethods(Class<?> testClass, boolean requireStatic) {
-		return findMethodsAndAssertStatic(testClass, requireStatic, BeforeAll.class, HierarchyTraversalMode.TOP_DOWN);
+		return findMethodsAndAssertStaticAndNonPrivate(testClass, requireStatic, BeforeAll.class,
+			HierarchyTraversalMode.TOP_DOWN);
 	}
 
 	static List<Method> findAfterAllMethods(Class<?> testClass, boolean requireStatic) {
-		return findMethodsAndAssertStatic(testClass, requireStatic, AfterAll.class, HierarchyTraversalMode.BOTTOM_UP);
+		return findMethodsAndAssertStaticAndNonPrivate(testClass, requireStatic, AfterAll.class,
+			HierarchyTraversalMode.BOTTOM_UP);
 	}
 
 	static List<Method> findBeforeEachMethods(Class<?> testClass) {
-		return findMethodsAndAssertNonStatic(testClass, BeforeEach.class, HierarchyTraversalMode.TOP_DOWN);
+		return findMethodsAndAssertNonStaticAndNonPrivate(testClass, BeforeEach.class, HierarchyTraversalMode.TOP_DOWN);
 	}
 
 	static List<Method> findAfterEachMethods(Class<?> testClass) {
-		return findMethodsAndAssertNonStatic(testClass, AfterEach.class, HierarchyTraversalMode.BOTTOM_UP);
+		return findMethodsAndAssertNonStaticAndNonPrivate(testClass, AfterEach.class, HierarchyTraversalMode.BOTTOM_UP);
 	}
 
 	private static void assertStatic(Class<? extends Annotation> annotationType, Method method) {
@@ -67,6 +69,13 @@ final class LifecycleMethodUtils {
 		}
 	}
 
+	private static void assertNonPrivate(Class<? extends Annotation> annotationType, Method method) {
+		if (ReflectionUtils.isPrivate(method)) {
+			throw new JUnitException(String.format("@%s method '%s' must not be private.",
+				annotationType.getSimpleName(), method.toGenericString()));
+		}
+	}
+
 	private static void assertVoid(Class<? extends Annotation> annotationType, Method method) {
 		if (!returnsVoid(method)) {
 			throw new JUnitException(String.format("@%s method '%s' must not return a value.",
@@ -74,19 +83,25 @@ final class LifecycleMethodUtils {
 		}
 	}
 
-	private static List<Method> findMethodsAndAssertStatic(Class<?> testClass, boolean requireStatic,
+	private static List<Method> findMethodsAndAssertStaticAndNonPrivate(Class<?> testClass, boolean requireStatic,
 			Class<? extends Annotation> annotationType, HierarchyTraversalMode traversalMode) {
 		List<Method> methods = findMethodsAndCheckVoidReturnType(testClass, annotationType, traversalMode);
 		if (requireStatic) {
 			methods.forEach(method -> assertStatic(annotationType, method));
 		}
+		methods.forEach(method -> assertNonPrivate(annotationType, method));
+
 		return methods;
 	}
 
-	private static List<Method> findMethodsAndAssertNonStatic(Class<?> testClass,
+	private static List<Method> findMethodsAndAssertNonStaticAndNonPrivate(Class<?> testClass,
 			Class<? extends Annotation> annotationType, HierarchyTraversalMode traversalMode) {
 		List<Method> methods = findMethodsAndCheckVoidReturnType(testClass, annotationType, traversalMode);
-		methods.forEach(method -> assertNonStatic(annotationType, method));
+		methods.forEach(method -> {
+			assertNonStatic(annotationType, method);
+			assertNonPrivate(annotationType, method);
+		});
+
 		return methods;
 	}
 
